{"pages":[{"title":"","text":"body { background-color: #95c2de; } .mainbox { background-color: #95c2de; margin: auto; height: 600px; width: 600px; position: relative; } .err { color: #ffffff; font-family: 'Nunito Sans', sans-serif; font-size: 11rem; position:absolute; left: 20%; top: 8%; } .far { position: absolute; font-size: 8.5rem; left: 42%; top: 15%; color: #ffffff; } .err2 { color: #ffffff; font-family: 'Nunito Sans', sans-serif; font-size: 11rem; position:absolute; left: 68%; top: 8%; } .msg { text-align: center; font-family: 'Nunito Sans', sans-serif; font-size: 1.6rem; position:absolute; left: 16%; top: 45%; width: 75%; } a { text-decoration: none; color: white; } a:hover { text-decoration: underline; } 4 4 블로그에 없는 URL입니다. 메인화면으로 갑니다.","link":"/404.html"},{"title":"about","text":"","link":"/about/index.html"}],"posts":[{"title":"API Gateway기반의 번역 웹 서비스","text":"실습 요약 번역 API 게이트웨이용 람다 함수 생성A. 람다 함수 생성(람다 함수 이름 : lambda_for_translate_Service)B. 람다 함수 실행 역할 생성(람다 역할 이름 : role_for_translate_Service) 람다 함수 소스코드 작성 람다 함수 역할 수정A. 정책 생성 및 검토(정책 이름 : role_for_translate_Service)B. 기존 관리형 정책 선택(TranslateFullAccess) 람다 API 게이트웨이 설정 index.html 파일 수정 및 S3버킷 생성 S3 버킷에 수정 파일 업로드 번역 서비스 정적 웹 사이트 설정 및 테스트 API 게이트웨이용 람다 함수를 생성한다 함수 이름에 lambda_for_translate_Service를 입력한다 AWS 정책 템플릿에서 새 역할 생성 선택 role_for_translate_Service 입력 정책 템플릿은 ‘기본 Lambda@Edge’ 입력 람다 함수 코드는 다음과 같이 작성 1234567891011121314151617181920212223242526272829303132333435363738/* AWS SDK 를 가져옵니다.*/var AWS = require('aws-sdk');AWS.config.update({ region: 'us-east-1' });var translate = new AWS.Translate();exports.handler = function (event, context, callback) { console.log(JSON.stringify(event.body)); const response = JSON.parse(event.body); //event.body로 POST로 받은 데이터를 받습니다. try { const translateParams = { SourceLanguageCode: 'ko', TargetLanguageCode: 'en', Text: response.text, }; //translate SDK를 불러옵니다. translate.translateText(translateParams, function (err, data) { if (err) callback(err); callback(null, { statusCode: 200, headers: { 'Access-Control-Allow-Origin': '*', //S3에서 요청을 할 수 있도록 허용해줍니다. 'Access-Control-Allow-Credentials': true, }, body: data.TranslatedText, }); }); } catch (e) { callback(null, { statusCode: 200, body: JSON.stringify(e), }); }}; 람다 함수 역할을 수정 권한의 실행 역할에서 role_for_translate_Service 선택 기존에 있는 권한인 TranslateFullAccess를 선택 새롭게 translate로의 접근 권한이 생김 추가 트리거를 통하여 API 게이트웨이를 연간함 API 생성을 선택 보안은 열기로 설정 API 엔드포인트를 보면 주소가 생김 해당 주소가 홈페이지를 통해 서비스르 만들어 요청할 주소 웹 페이지를 다음과 같이 생성 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;번역웹사이트&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://stackpath.bootstrapcdn.com/bootstrap/4.2.1/css/bootstrap.min.css&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col align-self-center&quot;&gt; &lt;h5 id=&quot;resultText&quot;&gt;&lt;/h5&gt; &lt;form action=&quot;javascript:void(0)&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label&gt;텍스트를 입력해주세요.&lt;/label&gt; &lt;textarea class=&quot;form-control&quot; id=&quot;textInput&quot; rows=&quot;3&quot;&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;button onclick=&quot;sendReqeust()&quot; class=&quot;btn btn-primary&quot;&gt;Submit&lt;/button&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;script type=&quot;text/javascript&quot;&gt; var inputSelector = document.querySelector('#textInput'); var resultText = document.querySelector('#resultText'); function sendReqeust() { resultText.innerHTML = '로딩중...'; fetch('https://0pmjclpe95.execute-api.ap-northeast-2.amazonaws.com/default/lambda_for_translate_service', { method: 'POST', body: JSON.stringify({ text: inputSelector.value, }), }).then(function (response) { return response.text().then(function (text) { resultText.innerHTML = text; }); }); } &lt;/script&gt;&lt;/html&gt; 이때, fetch 안에 아까 람다 함수의 API 게이트웨이 엔드포인트를 복사한다. S3 버킷을 생성 버킷 이름은 전세계에서 유일한 이름으로 설정해야 함 이때, 퍼블릭 액세스 차단을 위한 버킷 설정에서 모든 퍼블릭 액세스 차단을 해제하고, 경고문을 체크 해당 버킷에 방금 생성한 index.html 파일을 업로드 한다. 이때 중요한점은 해당 index.html 파일을 퍼블릭으로 설정해야 함 정적 웹 사이트 호스팅 편집에서 활성화를 선택 인덱스 문서로 index.html, 파일은 없지만 오류 문서로 error.html을 입력 버킷 웹 사이트 엔드포인트가 뜨는데, 이것이 바로 번역 사이트의 엔드 포인트 사이트 접속 시 해당 화면이 나오는 것을 볼 수 있음 텍스트 입력 후 submit 선택 시 번역이 작동되는 것을 확인","link":"/2020/11/10/API-Gateway%EA%B8%B0%EB%B0%98%EC%9D%98-%EB%B2%88%EC%97%AD-%EC%9B%B9-%EC%84%9C%EB%B9%84%EC%8A%A4/"},{"title":"Chocolatey 사용하기","text":"Chocolatey Chocolatey는 Windows 소프트웨어용 명령줄 패키지 관리자 및 설치 프로그램이다. Windows powerSHell을 이용하여 소프트웨어를 다운로드 및 설치 프로세스를 단순화한다. https://chocolatey.org/ 설치 후 바로 콘솔에서 테스트가 가능하다. 만약에 choco를 사용하지 않는다면 path 설정과 같은 복잡한 과정이 필요하다. 다음과 같은 명령어로 설치한다. 1Set-ExecutionPolicy Bypass -Scope Process -Force; [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString('https://community.chocolatey.org/install.ps1')) 설치를 확인한다. 주의 사항 powershell을 관리자 버전으로 실행하여야 한다. windows terminal 설치 choco를 이용하여 Windows Terminal을 설치한다. 1choco install microsoft-windows-terminal a를 선택하여 모두 설치한다. 주의 사항 powershell을 관리자 버전으로 실행하여야 한다.","link":"/2022/01/27/Chocolatey-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0/"},{"title":"API 게이트웨이 시작하기","text":"API 게이트웨이는 HTTP 프로토콜을 이용하여 API를 개발자가 손쉽게 구축할 수 있는 완전 관리형 서비스입니다. 실습 요약 API 게이트웨이용 람다 함수 생성A. 람다 함수 생성(람다 함수 이름 : lambda_for_apigateway_get)B. 람다 함수 실행 역할 생성(람다 함수 역할 이름 : role_for_apigateway) API 게이트웨이용 람다 이벤트 구성 람다 함수 소스코드 작성 다이나모 DB 서비스 실행 권한을 위한 IAM 생성A. 정책 생성 및 검토(정책 이름 : policy_dynamodb_crud)B. 역할 생성(역할 이름 : role_for_apigateway_get) 다이나모 DB 생성 람다 함수 수정 API Gateway 테스트 및 다이나모 DB GET 확인 AWS 콘솔에서 람다 함수를 선택하고, 함수 생성을 선택 함수 이름을 lambda_for_apigateway_get로 지정 권한은 AWS 정책 템플릿에서 새 역할 생성을 선택 역할 이름은 role_for_apigateway 정책 템플릿은 Lambda@Edge 선택 람다 함수 에디터 부분의 코드를 다음과 같이 입력 1234567exports.handler = async (event) =&gt; { const response = { statusCode: 200, body: JSON.stringify(event.queryStringParameters), }; return response;}; 추가 트리거를 선택한 후 API 게이트웨이를 선택 API 생성을 선택한 후 보안을 열기로 선택 추기를 선택하면 다음과 같이 화면이 뜸 API 게이트웨이가 추가되면 기존에는 없던 리소스 경로가 뜸 API 엔드포인트라는 항목과 URL이 나타나는데 함수를 실행시키기 위해 접속해야 하는 주소 ?”key”=”value”&amp;”key”=”value” 형태로 URL 뒤에 붙혀서 URI를 만들어 준다 화면에 GET으로 보내준 파라매터가 뜨는 것을 확인할 수 있음 다이나모DB에 대한 권한을 주기 위해 권한에 들어감 role_for_apigateway_get을 선택하면 다음과 같은 화면이 뜸 정책 연결을 선택 정책 생성을 선택 서비스는 DynamoDB, 리소스는 모든 리소스, 작업은 수동작업으로 모든 DynamoDB 작업을 선택 정책 검토를 선택 정책 이름으로 policy_dynamodb_crud를 입력 정책 생성을 선택 검색에서 이전에 만들었던 role_for_apigateway_get을 입력한 후 표시되는 역할을 선택 요약정보가 뜨며, 정책 연결을 선택 이전에 만든 정책 이름을 입력하여 검색 체크 박스 선택 후 하단 정책 연결 버튼을 선택 policy_dynamodb_crud역할에 role_forapigateway 정책이 성공적으로 연결 이제 람다 함수가 다이나모 DB에 접근 가능함 다이나모DB에서 테이블 만들기를 선택하며, 테이블 이름은 dynamo_apigateway_query를 입력한 후, 기본 키는 id를 입력 테이블 생성 람다 함수로 돌아와서 함수 코드를 다음과 같이 입력 123456789101112131415161718192021222324252627282930313233343536373839404142//aws-sdk를 불러옵니다.const AWS = require('aws-sdk');//다이나모디비 클라이언트를 초기화합니다.const dynamodb = new AWS.DynamoDB.DocumentClient();exports.handler = async (event) =&gt; { //리턴할 값을 선언합니다. let response; //queryStringParameters즉 GET값들이 들어오는지 들어온다면 id가 있는지 체크합니다. if (!event.queryStringParameters || !event.queryStringParameters.id) { response = { statusCode: 400, body: JSON.stringify('id가 없습니다.'), }; return response; } else { let params = { Item: { id: event.queryStringParameters.id, data: event.queryStringParameters, }, TableName: 'dynamo_apigateway_query', }; await dynamodb .put(params) .promise() .catch((e) =&gt; { response = { statusCode: 500, body: JSON.stringify('에러가 발생하였습니다:' + e), }; return response; }); response = { statusCode: 200, body: JSON.stringify('데이터가 성공적으로 저장되었습니다..'), }; return response; }}; queryStringParameter를 인자로 받아 다이나모 DB에 저장하고 GET에이터나 id 값이 없다면 400, 저장하는데 문제가 발생한다면 500, 성공적으로 데이터를 넣었다면 200을 반환 파라매터가 없는경우 파라매터를 정상적을 넣는 경우 다이나오 DB에 들어가보면 데이터가 정상적으로 들어가 있음을 확인할 수 있음 1234{ &quot;text&quot;: &quot;hello world&quot;, &quot;number&quot;: &quot;+821012345678&quot;}","link":"/2020/11/03/API-%EA%B2%8C%EC%9D%B4%ED%8A%B8%EC%9B%A8%EC%9D%B4-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/"},{"title":"DynamoDB 시작하기","text":"관계형 DB vs NO SQL 비교 관계형 DB 정형 데이터 대용량 처리 시 성능 하향 미리 정해진 스키마 존재 트랜잭션을 통해 일관성 유지 보장 조인 등의 복잡한 검색 기능 클러스터 환경에 적합하지 않음 고가의 라이센스 비용 Oracle, MySql, MSSql 등 NO SQL 정형, 반정형, 비정형 데이터 대용량 데이터 처리 지원 스키마가 없거나 변경이 자유로움 트랜잭션 지원하지 않음, 일관성이 보장 어려움(사실, 보장 하지만 관계형 DB보다는 여유롭게 보장) 단순히 데이터 검색 기능 클러스터 환경에 적합 오픈 소스 카산드라, 몽고DB 등 DynamoDB는 크게 쿼리와 스캔이라는 데이터 탐색 방법을 제공 - 쿼리 : 삽입된 기본키를 기준으로 데이터를 찾는 방법 - 스캔 : 조건 값과 맞는 데이터를 찾을 때까지 모든 데이터를 검색 구축 과정 다이나모DB 테이블 만들기A. 테이블 이름 : univStudentB. 기본키 : univ_name + univ_id 테이블 데이터 추가 데이터 수정 및 삭제 데이터 스캔과 쿼리 테이블 삭제 AWS console에서 DynamoDB를 선택 죄측 대시보드 밑의 테이블을 선택 테이블 만들기를 선택 테이블 이름은 univStudent, 기본키는 univ_name과 univ_id를 선택 후 생성 버튼을 클릭 항목 만들기 선택 내용을 입력 이 때, + 키를 누른 후 append를 클릭하여 데이터를 추가할 수 있음 저장을 클릭 데이터를 여러개 넣을 수 있으며, 형식이 전부 통일되지 않아도 됨 해당 데이터를 선택한 후 작업의 삭제를 통하여 데이터를 삭제할 수 있음 스캔은 조건값이 맞는 데이터를 찾을 때까지 모든 데이터를 탐색해서 어떤 조건 값에 맞는 데이터를 몇 개 찾아와라라는 명령어가 없다고, 모든 데이터를 찾음 필터를 통해서 조건을 줄 수 있음 쿼리는 아무런 값도 없이 검색을 누르면 에러가 발생 쿼리는 기본키를 입력하여 데이터를 검색하는 방법 글로벌 보조 인덱스는 동일한 데이터를 갖지만, 다른 키 값과 정렬키를 갖는 클론 테이블을 만들어서 테이블을 만들때와 같은 처리 용량이 필요함 인덱스를 만드는 시간은 오래 걸리지만 상태가 활성이 되면 완료된 것 스캔을 인덱스로 변경한 후 검색 시작을 선택하면 major가 포함된 데이터만 표시 됨 인덱스를 만든 테이블에서는 major을 기본키로 하기 때문에 원 테이블에서 major가 포함되지 않은 데이터는 가져올 수 가 없음 쿼리는 키 값을 찾아 데이터를 검색하는 방법 원 테이블에서 스캔으로 major을 찾는 것보다 인덱스에서 쿼리로 찾는 것이 처리용량이 더 작음 좌측 상단의 테이블 삭제를 클릭하여 안전하게 테이블을 삭제할 수 있음","link":"/2020/10/13/DynamoDB-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/"},{"title":"Docker 시작하기","text":"docker 설치 도커 설치 : https://www.docker.com/get-started docker desktop을 설치 powershell에서 도커 버전 확인 명령어 : docker –version docker 설치 시 주의사항 windows에서 설치할 경우 WSL 2와 관련된 설정이 나올 텐데 이를 허용해야 한다. 실습 환경 설정 git clone https://gitlab.com/yalco/practice-docker.git DokerStudy Node.js : 브라우저가 아닌 컴퓨터 환경에서 자바스크립트를 돌리게 해줌 실습 코드 수행 npm install –global http-server : global로 설치를 해야 http-server 명령어 이용 가능합니다. cd frontend로 들어간 후 http-server -p 8080 ./public 명령으로 서버 실행 그러나 이러한 Node.js와 http-server 없이 실행하기 위해 도커를 사용한다. docker 실행 docker run -it node : 만약 permission 관련 오류 발생 시 sudo를 붙이면 됨 Node.js 깔린 것처럼 입력 콘솔이 출력된다 이 Node.js 환경은 이미지 형태인데, docker의 이미지란 것은 캡쳐해서 박제한 것이다 docker 설명 run은 다운 후 이미지를 해동해서 컨테이너로 만든다 -it는 컨테이너를 연 다음 cli를 사용하겠다는 의미이다 그 후 node 명령어가 실행되므로 입력 화면이 나오는 것이다 docker 조작하기 docker images : 설치 된 것 확인, 설치 되었으니 docker run -it node 명령어 사용하면 설치없이 바로 실행 docker ps : 컨테이너 확인 가능 docker exec -it (docker ps 명령어로 확인한 컨테이너 명) bash root@f44956de125d:/# 가 뜨면서 컨테이너 내부를 통해 가상의 리눅스 환경으로 들어간 것이다 ls를 입력하면 리눅스 기본 디렉터리들이 보인다 -&gt; 컨테이너마다 각각 이 파일 시스템과 네트워크가 존재, 도커 데스크탑 프로그램으로 구현된 것!!! 도커의 컨테이너들은 리눅스 가상 환경의 형태로 돌아감! docker 종료하기 node cli에서 ctrl+c를 하면 컨테이너 안의 Node와 회의를 끝마친 것이다 이 후 docker ps를 입력하더라도 컨테이너가 나타나지 않는다 docker ps -a : 모든 컨테이너를 보여줌, 현재 중지된 컨테이너도 보임 이 디렉터리에서만 확인할 수 있는 것이 아니라 docker에 의해 다른 곳에서 관리 되므로 어떠한 디렉터리에서도 확인이 가능 docker container 삭제 한번에 도커 컨테이너 삭제 docker stop $(docker ps -aq) docker system pune -a Dockerfile 이미지를 만들기 위한 설계서 Dockerfile 내용 FROM node:12.18.4 : node version RUN npm install -g http-server : 이미지를 생성할 과정에서 실행할 명령어 WORKDIR /home/node/app : 이 안에서 명령어를 수행할 위치 CMD [“http-server”, “-p”, “8080”, “./public”] : 이미지로부터 컨테이너가 만들어져 가동될 때 기본적으로 바로 실행되는 명령어 Dockerfile 실행 cli에서 이 폴더로 들어온 다음 -t 뒤에 원하는 이미지명을 적은 뒤 Docker file로의 상대 경로를 적는다 파일이 Dockerfile이면 따로 명시할 필요가 없음 docker build -t frontend-img . docker images 명령어를 통하여 node 이미지가 다운 받아지고 이를 기반으로 frontend-img 이미지가 만들어진다 image run 시키기 docker run –name frontend-con -v $(pwd):/home/node/app -p 8080:8080 frontend-img docker run –name frontend-con -v “%cd%”:/home/node/app -p 8080:8080 frontend-img 아까는 도커가 임의의 컨테이너명을 지어줬지만 이번에는 frontend-con이라는 이름을 지어준다 -v는 볼륨의 약자인데 컨테이너의 특정 폴더를 공유 코드를 짠 후 그 파일을 거실 탁자에 두면 그 거실 탁자는 Node.js가 일하는 컨테이너의 /home/node/app 서랍과 연결된 것 pwd는 현재 디렉터리 컨테이너가 언제 몇개가 만들어지든 각 컨테이너의 app 서랍에서는 거실에 둔 파일들로 얼마든지 서비스를 실행 이를 통하여 CMD [“http-server”, “-p”, “8080”, “./public”]로 파일 실행이 가능한 것이다 Port 설명 -p는 포트 컨테이너는 CMD [“http-server”, “-p”, “8080”, “./public”]를 통하여 8080 포트로 송출할 거니까집에서도 같은 곳으로 송출한다는 의미이다 Dockerfile database file FROM mysql:5.7 : mySql 사용하겠다 환경변수 : 어떤 사용자? 비번? 디비명? 등등 설정 ENV MYSQL_USER mysql_user ENV MYSQL_PASSWORD mysql_password ENV MYSQL_ROOT_PASSWORD mysql_root_password ENV MYSQL_DATABASE visitlog COPY ./scripts/ /docker-entrypoint-initdb.d/ : script 안의 파일들을 이미지 내부의 /docker-entrypoint-initdb.d/로 저장 mysql이 실행이 될 때 /docker-entrypoint-initdb.d/안의 명령어들을 실행 script 파일들은 컨테이너 초기화 과정에서 필요한 것들이니까 copy로 이미지 안에 미리 넣어두는 것이 좋을 것이다 copy와 run의 차이점 copy는 run처럼 이미지를 생성하는 과정에서 해당 이미지 안에 특정 파일을 미리 넣어두는 것이고 volume은 CMD 처럼 컨테이너가 생성되어 실행될 때 그 내부의 폴더를 외부의 것과 연결하는 것이다!!! Dokcerfile 실행 docker build -t database-img . docker run –name database-con -p 3306:3306 database-img 컨테이너명과 포트만 지정하면 됨 -&gt; 실전에서는 데이터를 유지해야 하니까 데이터 폴더를 -v 옵션으로 집의 데이터 창고와 볼륨 창고를 연동할 것이다 docker run –name database-con -p 3306:3306 -d database-img : daemon의 줄임말, 뒤의 안보이는 곳에 가서 알아서 컨테이너 설치 및 실행… 현재 어떻게 실행되는지 보고 싶다면 : docker logs -f database-con Dockerfile backend file FROM python:3.8.5 RUN pip3 install flask flask-cors flask-mysql : flask로 api를 돌림 WORKDIR /usr/src/app CMD [“python3”, “backend.py”] : 백엔드 서버를 실행 docker-compose 이처럼 서비스를 구성하는 3개의 요소가 각각의 폴더에 Dockerfile를 통해 도커에서 어떻게 실행될지 설정이 되어 있는 것이다 각각의 네트워크로 분리되어 있기 때문에 백엔드와 데이터베이스는 데이터를 주고 받지 못한다 요소 연결 및 서비스 간편하게 실행? 이를 위해 사용되는 것이 거시적인 설계도인 docker-compose version: ‘3’ : 버전이며 지금의 최신 버전이 3이다 각각의 docker의 내용들이 services란 항목의 내부 항목들로 들어간다 docker-compose 내용 설명 항목명은 각 서비스들의 이름 (database:) 이며 이들간의 네트워크에서 각각의 호스트명이 된다 build: 는 도커 파일의 위치이다 compose 파일로부터.. ports: 는 외부에 개방할 포트이다 run 실행마다 작성해야되었던 명령어를 문서로 미리 작성한 것이다 backend에서는 volume을 사용하기 때문에 volumes:를 작성한다 환경 변수도 compose에서 environment:로 미리 설정할 수 있다 docker-compose 실행 docker-compose/yml이 있는 위치에서 docker-compose up을 실행 docker-compose up -d를 하면 뒤에서 알아서 컨테이너 생성 및 실행 마무리 이를 통하여 어느 서버에서든 도커 환경만 설치되어 있으면 git 등으로 이 프로젝트를 다운 받고 도커를 실행해서 이 컴퓨터와 똑같은 환경을 조성하고 문제없이 서비스를 돌릴 수 있을 것이다!!! 추가 라이브러리들을 일일히 하지 않아도 된다. 구름 IDE는 도커 기반의 서비스이다 -&gt; 도커 안의 도커 설치는 현재에서는 안된다 윈도우에서는 WSL로 실습할 수 있지만 오류가 많을 수도 있음 우분투에서는 ubuntu onstall docker를 검색한 후에 도커 설치할 수 있고 docker-compose도 따로 설치해야 함 docker-compose up","link":"/2021/12/07/Docker-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/"},{"title":"Git Blog 시작","text":"","link":"/2020/09/18/Git-Blog-%EC%8B%9C%EC%9E%91/"},{"title":"Git Branch","text":"git branch git branch : 치면 *master라고 뜨는데 기본 브랜치를 의미한다. git branch exp(생성할 브랜치명) : branch를 생성한다 -&gt; 현재 브랜치 상태를 그대로 복사한다. 현재 사용되는 브랜치에 *가 뜬다 git checkout git checkout exp : 브랜치를 exp 브랜치로 이동 f1.txt라는 파일이 어떤 브랜치에 있냐에 따라 내용이 완전히 달라짐 (exp branch에서 f2.txt를 만들고 add, commit하고 master branch로 넘어가면 f2.txt파일이 보이지 않음, 그러나 f2.txt파일을 만들고 add, commit을 하지 않으면 master branch로 넘어가도 사라지지 않음) git log –branches –decorate –graph 자신이 체크아웃된 브랜치 말고 모든 브랜치를 보여줌 HEAD -&gt; exp 되면 현재의 브랜치 –graph 하면 흐름을 알 수 있음 git log –branches –decorate –graph –oneline 1줄로 현재의 상태를 보여줌 git log master..exp : 2개의 브랜치 사이의 차이를 보여줌 git log exp..master : exp에는 없고 master에는 있는 것들 git log -p exp..master : 소스코드의 차이까지 보여줌 git diff master..exp : master와 exp의 현재 상태를 비교 함 Branch 병합exp에서 작업했던 내용을 master로 병합을 하고 싶다 (그 반대와는 다름) exp =&gt; master로 병합을 원할 경우 master에 checkout을 한 후 master에서 merge 명령어를 작성 git merge exp : master에서 실행하면 exp를 master로 병합 merge된 commit은 2개의 부모를 갖는다 (exp와 master였던 것) git checkout exp -&gt; git merge master git branch -d exp : exp branch를 삭제한다 병합 순서 git checkout -b test = git branch test -&gt; git checkout test merge를 했을 때 Fast-forward가 뜰 경우 branch 후 아무 일도 하지 않고 merge를 할 경우 이동만 시키면 병합 작업이 끝남 fast-forword하면 별도의 commit을 생성하지 않음, 바꾸기만 함 merge made by the ‘recursive’ strategy가 뜰 경우 fast-forward를 할 수 없는 경우이다 두 commit의 공통의 조상을 찾고, 두 commit을 합치고 합친 것을 알려주고, 합친 새로운 commit을 자동으로 생성한다. fast-forard가 아닌 방식은 merge commit을 생성한다. Stash branch에서 작업하다가 다른 branch로 checkout해야 하는 경우, commit하기도 애매하고 commit하지 않으면 checkout을 할수 없을 경우에 사용 작업한 내용을 숨겨놓고 그 브랜치의 최신 commit(head)의 버전으로 이동해서 깔끔하게 하고 다른 브랜치로 checkout 할 수 있음 exp 브랜치에서 작업하였지만, add, commit을 하지 않으면 master로 checkout을 했을때 add되지 않았다고 뜸 -&gt; exp에서 한 작업이 master에게 까지 영향을 미침 git stash Saved working directory and index state WIP on exp: b416d47 Merge branch ‘exp’, 워킹 디렉터리의 내용이 저장되었고 인덱스 내용도 세이브되었음 exp에 exp, master에서 git status하면 작업했던 내용들이 숨겨져서 사라짐 git stash apply : 숨겨진 파일을 다시 불러옴 git stash list : list를 볼 수 있음 git reset –hard HEAD 가장 최신 커밋 상태로 우리의 워킹 카피를 보냄, stash의 내용은 사라지지 않음! -&gt; 명시적으로 삭제를 하지 않는한 살아있음 git stash apply를 통하여 다시 숨겨놓은 것을 받아올 수 있음 (가장 최근의 stash를 적용함) git stash drop : 가장 최근의 stash를 삭제 stash를 전부 적용하기 위해 apply -&gt; drop -&gt; apply -&gt; drop을 반복한다 git stash pop : apply drop까지 됨 stash는 워킹 디렉터리의 변경사항을 감추는 것이다 add 하지 않은 것은 stash를 하더라도 숨겨지지 않는다 (untracked) -&gt; stash는 최소한 버전관리중인 파일에 대해서만 적용이 된다. Branch 상세 .git의 HEAD 파일 -&gt; refs/heads/master : objects의 id, 즉 commit의 object id를 가리키고 있음 새로운 commit 시 방금 commit으로 바뀜(가장 최신의 commits), 그리고 해당 commit의 parent를 통해서 탐색해 갈 수 있음 새로운 branch 생성 refs/heads/exp가 생성되며 최신 commits을 가리킨다 rm .git/refs/heads/exp를 하면 삭제 가능 git에서 브랜치는 매우 중요하지만 단순한 파일일 뿐이다 HEAD는 head를 가리킴 git checkout 시 HEAD 내용이 바뀜 Branch 병합 과정의 충돌 merge 과정에서 파일의 내용이 다를 경우 같은 파일임에도 서로 수정하는 위치가 다르다면 자동으로 합쳐준다 ex} master -&gt; function a(기존), function b(추가) exp -&gt; function c(추가), function a(기존) merge -&gt; function c, finction a, function b but, 수정하는 위치가 같다면 ex) function a(master){}, function a(exp){} 123CONFLICT (add/add): Merge conflict in common.txtAuto-merging common.txtAutomatic merge failed; fix conflicts and then commit the result. git status 시123Unmerged paths: (use &quot;git add &lt;file&gt;...&quot; to mark resolution) both added: common.txt vi common.txt 시123- ======= 구분자 중심으로- &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD : 현재 checkout branch- &gt;&gt;&gt;&gt;&gt;&gt;&gt; exp : exp branch의 내용 자기가 자동 merge 실패하였기 때문에 충돌을 해결하라 충돌이 난 부분 표시이다 -&gt; 문제를 수정하자 그 후 git add common.txt git commit (보면 충돌난 것 해결했다고 메시지가 뜸) git add 없이 merge를 또 시도할 경우 뜨는 에러1234error: Merging is not possible because you have unmerged files.hint: Fix them up in the work tree, and then use 'git add/rm &lt;file&gt;'hint: as appropriate to mark resolution and make a commit.fatal: Exiting because of an unresolved conflict.","link":"/2021/02/21/Git-Branch/"},{"title":"EC2를 활용한 Node.js 서버 구축!","text":"실습 요약 EC2, Ubuntu를 이용하여 인스턴스를 생성한다 Node.js를 설치하며, MariaDB를 설치한다. 간단한 예제를 통하여 환경을 테스트 한다. EC2의 새 인스턴스 생성을 통하여 다음과 같은 화면이 나온다. Ubuntu Server 20.04 LTS를 선택한다. 인스턴스 유형은 프리티어이므로 t2.micro를 선택한다. 인스턴스 세부 정보 구성은 건드리지 않는다. 스토리지 추가에서도 아무것도 선택하지 않는다. 태그 추가에서는 키에 Name을 입력하고 값에 TestServer를 입력한다. 이는 추후 인스턴스의 이름이 된다. 보안 그룹 구성에서는 기본으로 SSH가 있을 것이다. HTTP와 HTTPS를 추가하며 소스는 모두가 접근할 수 있도록 0.0.0.0/0을 선택한다. 인스턴스 시작 검토는 현재까지 설정한 정보를 볼 수 있다. 문제가 없다면 시작하기를 선택한다. 키를 발급 받는다. 기존에 가지고 있는 키를 선택해도 되며, 새로운 키를 발급 받아도 된다. 해당 키를 재발급이 불가능 하므로 반드시 저장을 해야한다. 인스턴스가 실행되면 연결 버튼을 통하여 다음의 정보를 얻을 수 있다. 이때 ec2-3-87-0-78.compute-1.amazonaws.com는 우리의 인스턴스의 퍼블릭 Ip의 역할을 한다. 인스턴스 요약을 통하여 5.87.0.78의 ip도 얻을 수 있는데, 이는 위의 ec2-3-87-0-78.compute-1.amazonaws.com와 같다. Putty를 통해 접속을 시도한다. 이때 Connection -&gt; SSH -&gt; Auth에 방금 발급 받은 키를 넣어줘야 한다. 주의할 점은 putty에서는 발급받은 pem이 아니라 ppk로 변환을 해줘야 하는데, 이 부분은 추후에 포스팅 한다. Putty의 Session에 Host Name에 방금 얻은 ec2-3-87-0-78.compute-1.amazonaws.com를 입력한다. 또한, ubuntu 계정으로 접근을 위해 앞에 ubuntu@를 붙인다. 1ubuntu@ec2-3-87-0-78.compute-1.amazonaws.com 연결을 누르게 되면 ubuntu 계정으로 로그인된 것을 볼 수 있다. Node.js 설치와 MariaDB는 ec2의 ubuntu에서 좀 다르게 설치된다. Node.js 설치법 https://docs.aws.amazon.com/ko_kr/sdk-for-javascript/v2/developer-guide/setting-up-node-on-ec2-instance.html 노드의 설치 방법은 위 사이트에 나와있다. 아래의 코드를 한줄씩 입력한다. 1234567curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.34.0/install.sh | bash. ~/.nvm/nvm.shnvm install nodenode -e &quot;console.log('Running Node.js ' + process.version)&quot; 위의 명령어를 통해 Node.js가 설치되고, 버전을 확인할 수 있다. Node.js가 설치된 후 다음의 명령어를 통해 예제 코드 실행을 위한 모듈을 설치한다. 12345678npm install ejsnpm install jadenp install expressnpm install cookie-parsernpm install body-parsernpm install express-sessionnpm install mysqlnpm install sync-mysql 한줄씩 입력하여 모듈을 설치한다. MariaDB 설치 https://downloads.mariadb.org/mariadb/repositories MariaDB를 설치하는 코드는 다음과 같다. 1234567891011sudo apt-get install software-properties-commonsudo apt-key adv --fetch-keys 'https://mariadb.org/mariadb_release_signing_key.asc'sudo add-apt-repository 'deb [arch=amd64,arm64,ppc64el] https://ftp.harukasan.org/mariadb/repo/10.5/ubuntu focal main'sudo apt updatesudo apt install mariadb-servermysql -V 위 코드를 통해 MariaDB가 설치되고 버전을 확인할 수 있다. 접속을 위해 MariaDB의 환경 설정을 해야한다. 12345cd /etc/mysql/mariadb.conf.dsudo cp 50-server.cnf server.cnf.backupsudo vi 50-server.cnf bind-addess = 127.0.0.1을 주석 처리한다. bind-addess = 127.0.0.1 -&gt; #bind-addess = 127.0.0.1 mariaDB를 재시작 시키며, 접속을 위한 비밀번호를 설정 123sudo systemctl restart mariadb.servicesudo mysqladmin -u root password 'gachon654321' 123456789sudo mysql -u root -pEnter password: *set password for root@localhost = password('gachon654321');use mysql;flush privileges;exitmysql -u root -pgachon654321 예제 페이지를 위해 테이블을 하나 만든다 12create database mydb;create table member ( name varchar(10), uid varchar(10), pass varchar(10)); Atom으로 접속을 한다. 이때 자세한 환경 세팅은 다음 포스팅에서 실시한다. ftp-remote을 통하여 .ftpconfig 파일을 다음과 같이 작성한다. 12345678910111213141516171819202122{ &quot;protocol&quot;: &quot;sftp&quot;, &quot;host&quot;: &quot;ec2-3-87-0-78.compute-1.amazonaws.com&quot;, &quot;port&quot;: 22, &quot;user&quot;: &quot;ubuntu&quot;, &quot;promptForPass&quot;: false, &quot;remote&quot;: &quot;/home/ubuntu&quot;, &quot;local&quot;: &quot;&quot;, &quot;agent&quot;: &quot;&quot;, &quot;privatekey&quot;: &quot;C:/users/ghdrl/Desktop/MyFiles/AwsKey/aws_password.pem&quot;, &quot;passphrase&quot;: &quot;&quot;, &quot;hosthash&quot;: &quot;&quot;, &quot;ignorehost&quot;: true, &quot;connTimeout&quot;: 10000, &quot;keepalive&quot;: 10000, &quot;keyboardInteractive&quot;: false, &quot;keyboardInteractiveForPass&quot;: false, &quot;remoteCommand&quot;: &quot;&quot;, &quot;remoteShell&quot;: &quot;&quot;, &quot;watch&quot;: [], &quot;watchTimeout&quot;: 500} 소스 코드 작성 예제를 돌려보기 위해 소스 코드를 다음과 같이 작성한다. mydbsvr.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960const fs = require('fs');const ejs = require('ejs');const mysql = require('mysql');const express = require('express');const bodyParser = require('body-parser');// MySQL DB 연결const client = mysql.createConnection({ host: 'localhost', // DB서버 IP주소 port: 3306, // DB서버 Port주소 user: 'root', // DB접속 아이디 password: 'gachon654321', // DB암호 database: 'mydb', //사용할 DB명});// 서버를 생성합니다.const app = express();app.use( bodyParser.urlencoded({ extended: false, }));// 서버를 실행합니다.app.listen(65001, function () { console.log('server running at http://127.0.0.1:65001');});app.get('/insert', (request, response) =&gt; { fs.readFile('9-insert.html', 'utf8', (error, data) =&gt; { //회원가입화면 response.send(data); // 회원가입 화면전송 });});app.get('/members', (request, response) =&gt; { fs.readFile('9-list.ejs', 'utf8', (error, data) =&gt; { // List화면 // 데이터베이스 쿼리를 실행합니다. client.query('SELECT * FROM member', (error, results) =&gt; { // 응답합니다. response.send( ejs.render(data, { data: results, // 회원조회 결과화면 }) ); }); });});app.post('/insert', function (request, response) { // 변수를 선언합니다. var body = request.body; console.log(body.name); console.log(body.uid); console.log(body.pass); // 데이터베이스 쿼리를 실행합니다. client.query('INSERT INTO member (name, uid, pass) VALUES (?, ?, ?)', [body.name, body.uid, body.pass], () =&gt; { console.log('Insertion into DB was completed !'); response.end(); });}); 9-insert.html 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;회원가입&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;회원가입&lt;/h1&gt; &lt;hr /&gt; &lt;form method=&quot;post&quot;&gt; &lt;fieldset&gt; &lt;legend&gt;회원가입&lt;/legend&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;&lt;label&gt;이름&lt;/label&gt;&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;name&quot; /&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;label&gt;사용자id&lt;/label&gt;&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;uid&quot; /&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;label&gt;비밀번호&lt;/label&gt;&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;password&quot; name=&quot;pass&quot; /&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;input type=&quot;submit&quot; value = &quot;가입&quot; /&gt; &lt;/fieldset&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 9-list.ejs 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;List Page&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;List Page&lt;/h1&gt; &lt;hr /&gt; &lt;table width=&quot;100%&quot; border=&quot;1&quot;&gt; &lt;tr&gt; &lt;th&gt;Name&lt;/th&gt; &lt;th&gt;Model Number&lt;/th&gt; &lt;th&gt;Series&lt;/th&gt; &lt;/tr&gt; &lt;% data.forEach(function (item, index) { %&gt; &lt;tr&gt; &lt;td&gt;&lt;%= item.name %&gt;&lt;/td&gt; &lt;td&gt;&lt;%= item.uid %&gt;&lt;/td&gt; &lt;td&gt;&lt;%= item.pass %&gt;&lt;/td&gt; &lt;/tr&gt; &lt;% }); %&gt; &lt;/table&gt; &lt;/body&gt;&lt;/html&gt; Node mydbsvr.js 명령을 통하여 예제 페이지를 실행한다. 3.87.0.78:65001/insert 그러나 접속을 하더라도 페이지가 제대로 뜨지 않는 것을 확인할 수 있다. 이는 Ec2의 보안 설정에서 포트 65001을 허용하지 않았기 때문이다. 해당 인스턴스의 보안그룹을 들어가면 인바운드 규칙을 볼 수 있다. 인바운드 규칙 편집을 선택한다. 유형을 사용자 지정 TCP로 하며 포트 범위를 65001로 한다. 그 후 0.0.0.0/0을 선택한 후 저장을 누른다. 같은 URL로 접속하면 정상적으로 뜨는 것을 확인할 수 있다. 입력 후 /members로 들어가게 되면 정상적으로 출력되는 것으 확인할 수 있다. DB에 접속해보면 입력한 데이터가 정상적으로 저장되어 있는 것을 확인할 수 있다.","link":"/2020/11/30/EC2%EB%A5%BC-%ED%99%9C%EC%9A%A9%ED%95%9C-Node-js-%EC%84%9C%EB%B2%84-%EA%B5%AC%EC%B6%95/"},{"title":"Git Tag","text":"Tag 태그는 언제나 똑같은 것을 가리켜야 한다 현재 버전의 상태를 다운로드 하고 싶다 git tag 1.0.0 현재 master 브랜치에서 태그가 만들어진다 git tag master git tag (커밋번호) 브랜치와는 달리 태그는 항상 일정한 것을 가리킨다 git checkout 1.0.0(태그명) : 테그명을 입력하면 해당 커밋으로 넘어갈 수 있다. Annotated Tag 태그에 대해 좀 더 자세한 설명을 추가하고 싶을 때 git tag -a 1.1.0 -m “bug fix” master : 어노테이션 태그 git tag -v 1.1.0 : 상세한 태그 설명을 볼 수 있음 태그를 올리고 싶으면 git push –tags origin master : –tags가 없으면 태그는 원격 저장소로 가지 않음 올라갈 태그는 releases로 올라감 git tag -d 1.1.0 : 태그 삭제 Tag의 원리 git tag 1.1.2 refs/tags/1.1.2 : 텍스트 파일이고 내용은 objets id 가리키며, commit을 가리킨다. git tag -a 1.1.3 -m “bug fix” objects/3e/… 특정한 오비젝트 가리키며 커밋을 가리킴 태그 이름과 태그 내용 또한 저장됨 refs/tags/1.1.3 : 3e…인 objects밑의 태그를 가리킴","link":"/2021/02/21/Git-Tag/"},{"title":"Git merge","text":"merge &amp; conflict 충돌이 발생했을 때의 처리 방법 123CONFLICT (add/add): Merge conflict in common.txtAuto-merging common.txtAutomatic merge failed; fix conflicts and then commit the result. index 파일에는 보통 490c7285a63e6531ea7d4b3eb3f95d0784c6066d 0 f1.txt이지만 0이 늘어난다. 1 -&gt; 원본 2 -&gt; 현재 브랜치의 바뀐내용 3 -&gt; 병합하고 싶은 브랜치의 바뀐내용 자동으로 깃은 병합작업을 실시 MERGE_HEAD_ MERGE_MSG : 충돌 해결 했을 때 커밋시 메시지 3way merge vs 2 way merge12345ME Base Other 2way 3way A A x ? x B B B B B 1 C 2 ? ? x D D ? x 2way는 base를 보지 않고 2개의 차이점만을 본다 3way는 base를 참조해서 2개의 대상을 병합한다(훨씬 good)","link":"/2021/02/21/Git-merge/"},{"title":"Git rebase vs merge","text":"rebase vs merge 병합을 하지만 결과가 좀 다르다 merge master내용을 feature로 가져오고 싶다 git checkout feature git merge master -&gt; 공통 조상과 3way merge 실시, master는 하나 전을 가리키고 있음 rebase 공통 조장 : base git checkout feature git rebase master -&gt; 임시 저장소 어딘가에 feature의 커밋들이 저장되고, feature는 master의 최신 커밋으로 checkout된다. -&gt; 임시 저장소의 commit들과 f,m인 브랜치와 병합 -&gt; 임시에 2개 커밋 있었으면 1개하고 임시에서 1개 지우고 1개 하고 임시에서 1개 지워서 새 브랜치 만듬 merge의 경우 history가 병렬 rebase는 history가 1개로 나아감 역사 파악이 더 편함 rebase는 어렵고 위험하다 merge는 충돌 발생해도 해결이 쉬움","link":"/2021/02/21/Git-rebase-vs-merge/"},{"title":"Git 과거로 돌아가기","text":"Reset checkout 과거로 돌아가고 그 뒤에 있는 commit을 삭제하고 싶다. git reset –hard 490c7285a63e6531ea7d4b3eb3f95d0784c6066d HEAD인 refs/heads/master가 490c7285a63e6531ea7d4b3eb3f95d0784c6066d을 가리키게 된다. 그러나 정보는 최대한 지우지 않는다 reest 취소 방법 ORIG_HEAD 파일은 reset 전 head가 있다(현재 branch의 최신 commit, 즉 head가 가리키는 것을 저장) logs/refs/heads/master는 head 기록이 남는다 - 기록 역사(head 변경의 역사) git log –hard ORIG_HEAD : 기존의 head로 다시 돌아옴 git reflog : 각각의 commit들이 기록됨 checkout으로 돌아가는 법 checkout 뒤에다가 commit id를 직접 적을 수 있다 git checkout 490c7285a63e6531ea7d4b3eb3f95d0784c6066d 123You are in 'detached HEAD' state. You can look around, make experimentalchanges and commit them, and you can discard any commits you make in thisstate without impacting any branches by switching back to a branch. $ git branch (HEAD detached at 490c728) HEAD 파일을 보면 직접 commit id를 가리킴 다시 git checkout master를 통하여 돌아오면 됨","link":"/2021/02/21/Git-%EA%B3%BC%EA%B1%B0%EB%A1%9C-%EB%8F%8C%EC%95%84%EA%B0%80%EA%B8%B0/"},{"title":"Git 시작하기","text":"Git에 대한 기초 학습 내용Git version control system Backup, Recovery, Collaboration version control system : CVS, SVN, Git등 다양하다. Dropbox, Google Drive도 버전관리 시스템의 일종이다. 1git git 입력 시 사용할 수 있는 명령어 목록이 뜬다. git init Initialized empty Git repository in ~ git 저장소를 초기화 한다. .git Directory가 생성되며 version에 관련된 정보가 저장되므로 삭제하면 안됨 vim vim f1.txt 입력시 f1.txt 파일이 생성된다. 입력모드와 명령모드로 구분되어 있다.(i, a, o를 통하여 입력모드로, esc를 통하여 명령모드로 전환) :wq를 통하여 저장 후 나가기 git add Untracked files : 디렉터리 안에는 존재하지만, 버전관리를 하기 전까지는 git이 무시한다. git이 관리를 시작하기 위한 명령어가 add이다. git add f1.txt 후 Changes to be committed로 변경됨 프로젝트를 하다보면 프로젝트 핵심 파일과 임시 파일이 있는데 임시 파일은 버전 관리를 하면 안됨, 따라서 이를 배제하기 위해 관리해야 할 파일을 명확히 알려줌 초기 환경 설정 git config –global user.name KiHyeon-Hong git config –global user.email ghdrlgus96@gmail.com git commit version : 모든 변화는 버전이 아니라 의미 있는 변화이다. 새로운 버전으로 만들기, 일정한 작업이 완결된 상태 git commit 후 commit message를 적어야 하는데 vim이므로 vim 입력방식대로 입력을 해야 한다. 123[master (root-commit) 4347df6] first commit 1 file changed, 1 insertion(+) create mode 100644 f1.txt 수정한 후 add 명령어를 항상 적어야지 버전 관리를 시작한다. 새로운 파일을 버전 관리 뿐만이 아니라 버전 관리가 되고 있는 파일을 수정하더라도 add를 해야 함 Changes not staged for commit : 수정 시 뜨는 메시지 (git status) git log 버전 생성된 것 확인(commit history 확인) git은 왜 add를 해야 하는가? commit 하나는 하나의 작업을 담는게 이상적이다. add를 통해서 commit 하고자 하는 것만 commit 할 수 있다. git add f1.txt를 하면 f1.txt는 stage에 올라감, commit 대기중인 파일들 stage - repository commit 결과는 repository commit에는 각각의 고유한 id가 있음 (commit 4347df685c78fe904d0363550936367d17851481) git log의 옵션들1git log -p 각 commit 사이의 소스 코드 차이를 보여준다. 1git log 4347df685c78fe904d0363550936367d17851481 이 commit 이전의 commit만 보인다. 1git diff 4347df685c78fe904d0363550936367d17851481..8d49b7cfa3e2c42d2be75e33169b640bbb48d8e9 두 commit 사이의 소스 차이를 보여준다. 파일 수정 후 git diff 시 : 현재 어떠한 작업이 진행되었는지 알 수 있음 -&gt; 자기가 작업한 내용이 마지막으로 리뷰할 수 있는 기회 (git add 시 git diff로 보이지 않음, 이전 commit과의 차이를 보여줌) 과거로 돌아가기 commit을 취소하는 명령어 현재의 log를 취소해서 과거로 돌아가기 reset vs revert reset 시 1git reset 8d49b7cfa3e2c42d2be75e33169b640bbb48d8e9 --hard 8d49b7cfa3e2c42d2be75e33169b640bbb48d8e9가 head로 바뀌며 이 이후의 commit이 사라짐 (–hard, –soft등 다양한 요소가 있음) git reset을 하더라도 실제로 삭제되지는 않고 복구가 가능 협업을 하게되면 원격저장소에 올라가는데 공유한 후에는 reset을 절대로 하면 안됨, 로컬에서만 reset을 써야함 git revert : 버전을 새로 만들면서 이전 commit으로 돌아간다 git commit –help git commit -a : 수정 및 삭제 파일은 자동으로 add 후 commit git commit -m “commit message” git commit -am “2” : 한번도 버전 관리, 즉 add를 하지 않은 파일을 제외하고 전부 add 후 메시지도 입력받지 않음","link":"/2021/02/18/Git-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/"},{"title":"Git 원격 저장소","text":"GIT 원격 저장소 - Remote repository 원격 저장소에 올리기(backup. 협업) -&gt; 1대의 컴퓨터 안에서 원격 저장소 만드는 법, 이런 방법은 거의 활용하지도 않음 git init –bare remote –bare(작업을 할 수 없고 저장소로만 사용하겠다는 옵션으로 remote라는 디렉터리 생성), working 디렉터리가 없고 .git 내용만 있음, 수정같은 작업이 불가능 함, 원격 저장소 만들때는 bare 넣는다 git remote add origin /home/git/git/remote : origin이라는 별명으로 리모트 원격 저장소 연결함 git remote remove origin : origin 저장소를 지운다. git config –global push.default matching : git이 암시적으로 git config –global push.default simple : 새 버전부터 simple 방식으로 push 하는 것이 좋음 -&gt; 이에 대한 설정, 어디로 업로드 하겠다. git push origin master : origin 저장소에 master 브랜치를 저장한다 git push –set-upstream origin master : 앞으로 push는 origin에 master를 하겠다 Github 원격저장소는 구축하기 어렵기 때문에 제공해주는 서비스를 이용 그 중 대표적인 예가 Github -&gt; 오픈소스 프로젝트들의 작업장 이미 존재하는 오픈소스 가져오기 git/git : git에 대한 오픈소스 코드 commits : 지금까지 commit 횟수 branches : branch의 개수 contributes : 이 소스코드에 접근할 수 있는 사람들 watch : 지켜보는 사람들 star : 좋아요 수 fork : 해당 소스 코드를 내것으로 해서 수정이 가능(ghdrlgus96/git 이 된다) -&gt; fork의 수가 그 소스코드의 수준을 보여준다. git clone https://github.com/git/git.git gitsrc : gitsrc 이름으로 clone git log –reverse : log를 거꾸로 봄 -&gt; 첫번째 로그를 볼 수 있음 git checkout (해당 commit) : 해당 commit일때 상태로 이동 원격 저장소 만들기 new repository git init git add . git commit -m “1” git remote add origin https://github.com/ghdrlgus96/git.git : 원격 저장소(remote repository)를 연결 시키고 origin 이라는 별명을 부여하겠다. git remote : 원격저장소 확인 git remote -v : 상세 보기 작업한 내용을 여러 저장소를 remote로 해서 보낼 수 있다. git remote remove friend : friend remote 삭제 git push origin master : 현재 checkout 되어있는 브랜치를 origin의 master 브랜치를 서로 연결시킨다. git clone https://github.com/ghdrlgus96/git.git . git commit –amend : 최근 커밋의 메시지 변경 push 이후의 내용은 수정하지 말자 git push origin master //다른 로컬 저장소 git pull origin master : 가져오기(공재 저장소에서 가져오므로 비밀번호를 묻지 않음) git add . git commit -m “2” git push //다른 로컬 저장소 git pull … 지역 저장소에서 원격 저장소를 만들어 올리기 git init local cd local git commit -am “1” 원격 저장소 git init –bare remote cd remote 로컬 저장소 git remote add origin ssh://git@13.124.42.13/home/7. git/git/remote/ : ssh로 접속하는데 사용자 이름은 8. git git remote -v git push –set-upstream origin master 원격 저장소 git log 백업 및 동기화의 의미를 갖는다. git clone ssh://git@13.124.42.13/home/git/git/remote/ office push pull push 전에 로컬과 원격 저장소의 내용이 다르면 pull을 하고 push를 하라 분산관리 시스템 특징 : 로컬에서 버전관리 하다가 필요시 원격과 동기화 자주 pull, push를 하여 다른 사람의 push 기록을 자주 가져오도록 하자 pull - 작업 - push pull, push는 자주해야 충돌 가능성을 낮춘다. 원격 저장소 원리 git remote add origin git@github.com:ghdrlgus96/repo.git .git/config123[remote &quot;origin&quot;] url=git@github.com:ghdrlgus96/repo.git fetch =+refs/heads/*:refs/remotes/origin/* git push 1current branch master has no upstream breanch - 연결되어 있는 원격저장소 브랜치가 없다 git push –set-upstream origin master : origin의 master 브랜치에 연결 .git/config 123456[remote &quot;origin&quot;] url=git@github.com:ghdrlgus96/repo.git fetch =+refs/heads/*:refs/remotes/origin/*[branch &quot;master&quot;] remote=origin merge=refs/heads/master refs/remotes/origin/master 파일 origin으로 push한 commit이 무엇인가가 적혀있음 (원격 저장소의 master)refs/heads/master 지역 저장소의 master내용 둘이 같음 -&gt; 인터넷에서 가져온것이 아니라, 지역에서 마지막으로 원격으로 push 했던 기록일 뿐이다. git log –decorate –graph git pull, git fetchgit log –decorate –all –onelinepull 지역 저장소 master 브랜치와 원격저장소(origin)의 master의 브랜치가 같아짐 ORIG_HEAD는 이전 commit을 가리키고 있음 git fetch 지역저장소의 master 브랜치는 6, 원격저장소 origin의 master 브랜치는 7을 가리키고 있음 -&gt; merge되지 않음 ORIG_HEAD가 변하지 않음 원격 저장소로부터 받고 병합을 안하지 때문에 원격과 지역의 차이를 비교해 볼 수 있음 git diff HEAD origin/master : 최신 커밋과 원격의 최신을 비교 가능 git merge origin/master : git fetch 후 병합을 해야 함 git fetch -&gt; git merge origin/master","link":"/2021/02/21/Git-%EC%9B%90%EA%B2%A9-%EC%A0%80%EC%9E%A5%EC%86%8C/"},{"title":"Git 저장소 원리","text":"working copy &amp; index &amp; repository working directory(working tree, working copy), index(git add 시, staging area, chche), repository(commit이 저장, history, tree) git reset –hard하면 저장소, add, working까지 삭제됨 git reset –soft하면 repository만 삭제됨 git reset –mixed하면 레포지토리랑 add 삭제됨 git reset –soft 490c7285a63e6531ea7d4b3eb3f95d0784c6066d git diff : working copy와 index 비교 git reset –hard : 최신 커밋 상태로 바꿔버림 working copy까지","link":"/2021/02/21/Git-%EC%A0%80%EC%9E%A5%EC%86%8C-%EC%9B%90%EB%A6%AC/"},{"title":"HTTPS 시작하기","text":"HTTPS(HTTP Secure)는 HTTP 프로토콜의 암호화된 버전이다. 클라이언트와 서버 간의 모든 커뮤니케이션을 암호화하기 위해 SSL이나 TLS를 이용한다. 본 포스팅에서는 HTTPS 통신을 위해 SSL을 이용한다. OpenSSL 설치 http://slproweb.com/products/Win32OpenSSL.html 개발 및 테스트를 위해 OpenSSL을 다운로드하고 설치한다. 자신의 환경에 맞는 설치 파일을 다운로드하고 설치한다. Win64 OpenSSL v1.1.1L OpenSSL 환경 변수 설정 Path에 OpenSSL의 bin 폴더를 추가한다. 터미널에 openssl을 입력하여 다음과 같은 화면이 뜨면 설정 완료 1openssl 개인키와 공유키 생성 SSL 통신을 위해 개인키와 쌍을 이루는 공유키를 생성한다. 12openssl genrsa 1024 &gt; private.pemopenssl req -x509 -new -key private.pem &gt; public.pem HTTPS 프로토콜 사용 예시 Node.js를 이용한 HTTP 서버에서 HTTPS 서버로 변경한 예시 포트는 8080에서 3000으로 변경하였다. 개인키와 공유키를 받아온다. 123456789var http = require('http');var socketIO = require('socket.io');var fileServer = new nodeStatic.Server();var app = http .createServer(function (req, res) { fileServer.serve(req, res); }) .listen(8080); 12345678910111213// var http = require('http');const https = require('https');var socketIO = require('socket.io');const fs = require('fs');const options = { key: fs.readFileSync('./private.pem'), cert: fs.readFileSync('./public.pem') };var fileServer = new nodeStatic.Server();let app = https .createServer(options, (req, res) =&gt; { fileServer.serve(req, res); }) .listen(3000); HTTPS 서버 접속 예시 다음과 같이 https://localhost:3000을 이용하여 접속하는 것을 볼 수 있다.","link":"/2021/11/27/HTTPS-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/"},{"title":"Git 원리","text":".git directory git add 시 : index, objects directory가 변경됨 objects directory 내부에는 git add한 기록이 있으며, 이에 대한 자세한 내용은 index에 존재함index : 100644 8d49b7cfa3e2c42d2be75e33169b640bbb48d8e9 0 f1.txt cp 명령어로 파일을 복사할 경우 cp 명령어를 쓰면 같은 8d49b7cfa3e2c42d2be75e33169b640bbb48d8e9를 갖는다 -&gt; 같은 object를 갖는다 파일의 이름이 달라도 내용이 같으면 같은 object를 갖는다 내용이 a라면 같은 8d49b7cfa3e2c42d2be75e33169b640bbb48d8e9를 가질 것이다 (이 세상 누가 작성하더라도) objects 파일명과 원리SHA1 online -&gt; hash, 일정한 길이, git은 SHA1을 통과시켜서 hash값에서 2글자 빼고 objects 디렉터리를 만들고 그 나머지를 파일을 만들어서 정보를 저장한다. git add를 하면 git은 add한 파일의 내용과 부가적인 정보로 hash를 통과시키고 디렉터리와 파일을 만들고 그 정보를 저장한다음 index파일에서 이를 표시해준다. commit의 원리 git commit -m “1” 시 objects 디렉터리 안에 commit 정보가 저장, commit도 내부적으로는 객체 tree 8d49b7cfa3e2c42d2be75e33169b640bbb48d8e9 -&gt; 트리는 해당 버전의 파일의 이름과 그 내용 해쉬가 있음 parent에는 이전 commit을 볼 수 있음 각각의 버전은 그 버전이 만들었을 때의 스냅샷을 찍는다 objects 파일의 3가지 : 파일의 내용blob, 디렉터리 파일명과 파일명의 blob에 대한 정보tree, commit git status의 원리 index 파일은 무엇일까index와 최신 objects에 있는 commit을 비교 -&gt; 일치한다면 commit할 내용이 없음 index의 hash와 실제 디렉터리 hash가 다르면 수정되었음을 알림 add 하면 objects에 새로운 것이 생성되었고 index에 반영됨, 실제 파일과 hash는 같음, 그러나 가장 최신 커밋이 가리키는 f2.txt의 hash와는 다르므로 현재 f2.txt는 add되고 commit 대기 상태임을 알 수 있음 프로젝트 폴더(working directory, work tree), index, objects, 최신 commit이 전부 일치하면 commit할 것이 없다고 알려줌 working directory, work tree - index, staging area, cache - repository","link":"/2021/02/19/Git-%EC%9B%90%EB%A6%AC/"},{"title":"Javascript Async, Await 공부","text":"http://junil-hwang.com/blog/javascript-promise-async-await/ Async, Await 간단 설명 async, await는 비동기로 실행되는 것을 끝날 때까지 기다리는 방법 (동기처럼 사용) async, await를 사용하기 위해 Promise를 사용한다. 간단한 Promise 코드 작성 promise는 Promise 객체를 반환하며, 1초 후 입력받은 값에 1을 더한 값을 반환한다. 12345678const cnt0 = 0;const promise = (v) =&gt; { return new Promise((resolve) =&gt; { setTimeout(() =&gt; { resolve(v + 1); }, 1000); });}; Async, Await를 사용하지 않은 Promise 기존의 비동기를 사용하듯이 promise를 사용하는 방법 무한 callback에 빠진다. 123456789promise(cnt0).then((cnt1) =&gt; { console.log(cnt1); promise(cnt1).then((cnt2) =&gt; { console.log(cnt2); promise(cnt2).then((cnt3) =&gt; { console.log(cnt3); }); });}); 적절한 체이닝을 이용하여 promise를 조작하는 방법 비동기라는 특성에서 완전히 벗어나지는 못한다. 123456789101112promise(cnt0) .then((cnt1) =&gt; { console.log(cnt1); return promise(cnt1); }) .then((cnt2) =&gt; { console.log(cnt2); return promise(cnt2); }) .then((cnt3) =&gt; { console.log(cnt3); }); Async, Await를 사용한 Promise Promise를 반환하는 함수의 앞에 await를 사용한다. await를 사용하는 함수 앞에는 async라는 키워드를 사용한다. resolve의 인자가 await 구문으로 반환된다. 12345678(async () =&gt; { const cnt1 = await promise(cnt0); console.log(cnt1); const cnt2 = await promise(cnt1); console.log(cnt2); const cnt3 = await promise(cnt2); console.log(cnt3);})();","link":"/2021/11/26/Javascript-Async-Await-%EA%B3%B5%EB%B6%80/"},{"title":"Javascript Promise 공부","text":"출처: https://github.com/azu 한빛출판네트워크, JavaScript Promise에서 중요 부분만 발췌 Promise.prototype.then promise.then(onFulfilled, onRejected); 1234567891011var promise = new Promise(function (resolve, reject) { resolve('이 값은 then()에 전달된다.');});promise.then( function (value) { console.log(value); }, function (error) { console.error(error); }); promise 객체에 대한 onFulfilled와 onRejected 콜백 함수를 정의하고 새로운 promise 객체를 반환한다. 이 함수는 promise 객체가 완료resolve 또는 실패reject될 때 각각 호출된다. 처리 로직에서 반환한 값은 새로운 promise 객체의 onFulfilled 콜백 함수에 전달한다. 처리 로직에서 오류가 발생하면 error 객체를 새로운 promise 객체의 onRejected 콜백 함수에 전달한다. Promise.prototype.catch promise.catch(onRejected); 12345678910var promise = new Promise(function (resolve, reject) { reject(new Error('error 객체는 catch()에 전달된다.'));});promise .then(function (value) { console.log(value); }) .catch(function (error) { console.error(error); }); Promise.resolve Promise.resolve(promise); Promise.resolve(thenable); Promise.resolve(object); 12345678910111213var taskName = 'task 1';asyncTask(taskName) .then(function (value) { console.log(value); }) .catch(function (error) { console.error(error); });function asyncTask(name) { return Promise.resolve(name).then(function (value) { return 'Done! ' + value; });} Fulfilled 상태의 promise 객체를 반환한다. 전달받은 값은 then()으로 등록한 콜백 함수에 전달된다. 어떤 경우에도 promise 객체를 반환하지만 크게 세 가지 케이스로 나눌 수 있다.● promise 객체를 전달받은 경우엔 전달받은 객체를 반환한다.● thenable 객체를 전달받은 경우엔 promise 객체로 변환해서 반환한다.● 다른 값(객체나 null 포함)을 전달받은 경우엔 새로운 promise 객체를 생성해 반환한다. Promise.reject Promise.reject(object) 12var r = Promise.reject(new Error('error'));console.log(r === Promise.reject(r)); // false Rejected 상태의 promise 객체를 생성해 반환한다. reject()에는 error 객체를 전달해야 한다. 전달받은 값은 catch()로 등록한 콜백 함수에 전달된다. resolve()와는 달리 항상 새로운 객체를 생성한다. Promise.all Promise.all(promiseArray); 123456var p1 = Promise.resolve(1), p2 = Promise.resolve(2), p3 = Promise.resolve(3);Promise.all([p1, p2, p3]).then(function (results) { console.log(results); // [1, 2, 3]}); 새로운 promise 객체를 생성해 반환한다. 배열로 전달한 promise 객체의 처리가 모두 완료됐을 때 새로운 promise 객체도 완료된다. 객체 중 하나라도 실패하면 새로운 객체도 실패한다. 배열의 값은 Promise.resolve()로 다뤄지기 때문에 promise 객체 이외의 값이 존재해도 정상적으로 동작한다. Promise.race Promise.race(promiseArray); 123456var p1 = Promise.resolve(1), p2 = Promise.resolve(2), p3 = Promise.resolve(3);Promise.race([p1, p2, p3]).then(function (value) { console.log(value); // 1}); 새로운 promise 객체를 생성해 반환한다. 배열로 전달한 promise 객체 중 하나만 완료되면 새로운 promise 객체도 완료된다.","link":"/2021/11/26/Javascript-Promise-%EA%B3%B5%EB%B6%80/"},{"title":"Javascript 정규식 문법","text":"정규 표현식은 대 소문자를 구분함 정규 표현식은 띄어쓰기 개수를 구분함 ^who -&gt; who가 시작 위치에 있을 때 ^를 사용 who$ -&gt; who가 끝에 위치할 때 $를 사용 $12$ -\\ $25$ ^$ -&gt; $로 시작하는 것을 의미했더라도 $가 문자 끝을 의미해서 안됨 $ -&gt; \\는 그 기호 뒤에 따라오는 문자를 정규 표현식의 의미가 있는 문자가 아니라 단순한 문자로 바꿔줌 ^ -&gt; 단순한 문자열 ^$ -&gt; $가 처음 들어가는 문장을 의미함 $$ -&gt; $가 뒤에 들어가는 문장을 의미함 \\ -&gt; \\ 문자를 의미함 \\는 escape 문자라고 함 . -&gt; 모든 캐릭터를 매칭, 어떠한 문자 모든 것을 뜻함 …… -&gt; 어떠한 문자건 상관없이 6개의 문자를 의미 (6 덩어리씩 쪼개고 뒤에 남은 문자는 포함 안됨) . -&gt; . any character를 의미하는 의미가 아니라 .을 의미 ... -&gt; 문자. any character 문자.을 의미 (.K.) [] [oyu] -&gt; o나 y나 u를 찾는다 (first, all matches)에 따라 몇개인지 달라짐 [] 안에는 문자 하나하를 의미함 [dH]. -&gt; Ho 와 같이 d나 H 후 아무 문자 선택됨 [oyu][yow] -&gt; ow, yo 등이 추출됨 [-] -&gt; range [c-k] -&gt; c부터 k까지 범위의 문자 ([cdefghijk]와 같음) [2-6] -&gt; [23456] [c-k1-8] [^cdgh45] -&gt; [] 안의 ^는 not을 의미함, ABEF 등등이 추출됨 [^w-z] (on|ues|rida) -&gt; on, ues, rida 각각 1덩어리, 문자를 선택함 (Mon|Tues|Fri)day -&gt; (Monday|Tuesday|Friday) ..(id|esd|nd)ay -&gt; 앞의 아무 문자 2개까지 포함 Quantifiers -&gt; 수량자 *, +, ? a*b -&gt; a가 0 ~ 여러개, (ab, aab, b) a+b -&gt; a가 1 ~ 여러개, (aab, ab) a?b -&gt; a가 0 ~ 1개, (ab, b) .* -&gt; !@#$%^^&amp;&amp;등등 모든 텍스트 등등이 전부 선택 -A*- -&gt; - 앞에 A가 0 ~ 여러개, (–, -A-) [-@]* -&gt; (-@-, – 등등) *+ =&gt; (, \\*), *가 1개 이상이여야 함 -@+- -&gt; (-@@@-) @가 1개 이상있어야 함 [^ ]+ -&gt; 공백에 대한 부분이 아닌것이 전부 선택됨 -X?XX?X -&gt; (-XX) 등 -@?@?@?- -&gt; (–, -@-, -@@-, -@@@-) 원하는 수량 정하기 -&gt; {} .{5} -&gt; 모든 문자건 5글자여야 함, 만약에 12글자라면 5글자씩 2번 묶이고 2글자가 선택되지 않음 [els]{1,3} -&gt; 3개 이하 [a-z]{3,} -&gt; 3이상이란 의미 AB*A -&gt; AB{0,}A AB+A -&gt; AB{1,}A AB?A -&gt; AB{0,1}A r.* -&gt; *은 any character, r부터 모든 문자가 선택이 되어버림 r._? -&gt; 수량자 뒤에 ? 오면은 _?는 *는 최소인 0의 의미 (r) r.+? -&gt; +는 최소인 1의 의미가 됨, (ri, rk) r.?? -&gt; ?는 최소인 0을 의미 (r) .+ -> 비어있지 않은 div 태그 선택, 탐욕적인 수량자(Greedy) .+? -> lazy 선택자, 게으른 선택자 \\w -&gt; word = [A-z0-9_] \\w* [a-z]\\w* -&gt; (c3, d_4 등등) \\w{5} -&gt; 문자 5개 충족하면 추출 \\W -&gt; word가 아니다, 공백이랑 :, . @#$% 등이 선택됨 \\d -&gt; digit, (1, 123 등) \\D -&gt; 숫자가 아닌 것들 \\b. -&gt; 바운더리 \\B. \\A… -&gt; A는 시작점을 의미 시작에서 3문자 …\\Z -&gt; 맨끝에서 3문자 선택됨 ^과 \\A의 차이점 -&gt; multi line 시 \\A 하면 멅타라인이 있더라도 맨 앞 1개만 선택됨 \\w+(?=X) -&gt; ?=는 X를 문자를 검색하는 데에는 X를 쓰지만 선택은 하지 않음, (AAAX에서 AAA만 선택됨) \\w+(?=\\w) -&gt;","link":"/2021/02/11/Javascript-%EC%A0%95%EA%B7%9C%EC%8B%9D-%EB%AC%B8%EB%B2%95/"},{"title":"Javascript call, apply, 그리고 bind 공부","text":"https://www.youtube.com/watch?v=KfuyXQLFNW4&amp;list=PLZKTXPmaJk8JZ2NAC538UzhY_UNqMdZB4&amp;index=13 Call 모든 함수에서 사용할 수 있으며, this를 특정한 값으로 지정한다. 12345678910111213const mike = { name: 'Mike',};const tom = { name: 'Tom',};function showThisName() { console.log(this.name);}showThisName(); // errorshowThisName.call(mike); // Mike 첫 번째 매개 변수는 this로 사용할 값이며, 나머지 뒤의 매개 변수는 함수의 파라매터 123456function update(birthYear, occupation) { this.birthYear = birthYear; this.occupation = occupation;}update.call(mike, 1999, 'singer'); Apply 함수의 매개변수를 처리하는 방법을 제외하면 call과 완전히 동일하다. call은 일반적인 함수와 마찬가지로 매개 변수를 직접 받지만, apply는 매개변수를 배열로 받는다. 12345678update.apply(mike, [1999, 'singer']);const num = [3, 2, 1, 5, 4];// 동일한 결과를 갖는다.const min = Math.min(...num);const min = Math.min.apply(null, num);const min = Math.min.call(null, ...num); Bind 함수의 this 값을 영구히 바꾼다. 12const updateMike = update.bind(mike);updateMike(mike);","link":"/2021/11/26/Javascript-call-apply-%EA%B7%B8%EB%A6%AC%EA%B3%A0-bind-%EA%B3%B5%EB%B6%80/"},{"title":"Javascript 정규표현식 정리","text":"정규표현식이란? pattern과 flag를 이용한다. 1/regex?/i 사용법1/Hi/gm Hi와 정확히 일치하는 것을 찾는다. 1/Hi|Hello/gm Hi 또는 Hello와 정확히 일치하는 것을 찾는다. 1/(Hi|Hello)/gm 소괄호를 통해 묶어주면, match도 되고, group1에 Hi가 지정된다. 1/(Hi|Hello)|(to)/gm group1에는 Hi or Hello, group2에는 to와 일치하는 것을 찾으며, 없을 경우 undefined 1/((Hi|Hello)|(to))/gm group1은 Hi, Hello, to를 찾으며, group2에는 Hi or Hello, group3에는 to와 일치하는 것을 찾으며, 없을 경우 undefined 1/gr(e|a)y/ grey, gray를 찾는다. 이러할 경우 e, a가 그룹으로 묶이는데, 만약 그룹으로 묶고 싶지 않다면 그룹 앞에 ?:을 붙인다. 1/gr(?:e|a)y/ 1/gr[ae]y/ /gr(e|a)y/와 동일하며, 찾고싶은 문자열 집합체를 작성한다. 하나라도 만족하는 것을 찾는다. 1/gr[abcdef]y/ /gr[a-f]y/와 동일하다 1/gr[^a-f]y/ a부터 f까지를 제외한 문자열을 찾는다. Quantifiers1/gra?y/ ?는 없거나 있거나 이다. (gray, gry) 1/gra*y/ 없거나 있거나 많거나 이다. (gry, gray, graay, graaay) 1/gra+y/ 하나 있거나 많거나 이다. (gray, graay, graaay) 1/gra{2}y/ a가 2번 나오는 단어를 찾는다. (graay) 1/gra{2,3}y/ a가 2~3번 나오는 단어를 찾는다. (graay, graaay) 1/gra{2,}y/ a가 2번 이상 나오는 단어를 찾는다. (graay, graaay, graaaay) Boundary-type1/\\bYa/ \\b를 앞에 사용하면 단어의 맨 앞에서 나오는 Ya만 매칭한다. 1/Ya\\b/ \\b를 뒤에 사용하면 단어의 맨 뒤에서 나오는 Ya만 매칭한다. 1/\\BYa/ \\b를 앞에 사용하면 단어의 맨 앞에서 나오는 Ya만 빼고 전부 매칭한다. 1/Ya\\B/ \\b를 뒤에 사용하면 단어의 맨 뒤에서 나오는 Ya만 빼고 전부 매칭한다. 1/^Ya/ ^는 문장에서 시작하는 Ya를 찾는다. 1/Ya$/ $는 문장에서 끝나는 Ya를 찾는다. 이때 플래그의 멀티라인을 작성하지 않으면, 문장 전체에서 시작하는 Ya와 문장 전체에서 끝나는 Ya를 찾기 때문에 아무 것도 선택되지 않을 수도 있다. Character classes1/./ 줄바꿈 문자를 제외한 모든 문자열을 선택한다. 만약에 .를 진짜로 찾고 싶은것이라면, \\를 이용해야 한다. 1/\\./ 특수 문자인 경우에는 \\ 다음에 작성을 해야된다. 1/\\d/ 숫자를 전부 찾는다. 1/\\D/ 숫자를 제외하고 전부 찾는다. 1/\\w/ 문자를 전부 찾는다. 1/\\W/ 문자를 제외하고 전부 찾는다. 1/\\s/ 공백을 전부 찾는다. 1/\\S/ 공백을 제외하고 전부 찾는다. 자바스크립트에서 사용 방법1234const regex = /\\d/;const s = 'abcdefg';s.match(regex);","link":"/2022/01/27/Javascript-%EC%A0%95%EA%B7%9C%ED%91%9C%ED%98%84%EC%8B%9D-%EC%A0%95%EB%A6%AC/"},{"title":"Javascript 정규표현식 정리2","text":"자바스크립트 정규표현식 메소드 exec: 대응되는 문자열을 찾는 RegExp 메소드, 정보를 가지고 있는 배열을 반환하며, 대응되는 문자열이 없을 경우 null을 반환 test: 대응되는 문자열이 있는지 검사하는 RegExp 메소드, true or false match: 대응되는 문자열을 찾는 string 메소드, 정보를 가지고 있는 배열을 반환하며, 대응되는 문자열이 없을 경우 null을 반환 search: 대응되는 문자열이 있는지 검사하는 string 메소드, 대응되는 부분의 인덱스를 반환, 없다면 -1 replace: 대응되는 문자열을 찾아 다른 문자열로 치환하는 string 메소드 split: 정규식 혹은 문자열로 대상 문자열을 나누어 배열로 반환하는 string 메소드 1234567var myRe = /d(b+)d/g;console.log(myRe.exec('cdbbdbsbz'));console.log(/d(b+)d/g.exec('cdbbdbsbz'));// 문자열로 표현한 형식입니다.myRe = new RegExp('d(b+)d', 'g');console.log(myRe.exec('cdbbdbsbz')); index: 입력된 문자열에서 대응된 부분에 해당하는 인덱스 input: 입력된 원본 문자열 [0]: 마지막으로 대응된 문자열 lastIndex: 다음 검색 시 시작할 인덱스(g 옵션을 설정한 정규식에서만 가능) source: 패턴 문자열 123var myRe = /d(b+)d/g;var myArray = myRe.exec('cdbbdbsbz');console.log('The value of lastIndex is ' + myRe.lastIndex); 괄호로 둘러 싼 패턴 사용하기123456var re = /(\\w+)\\s(\\w+)/;var str = 'John Smith';var newstr = str.replace(re, '$2, $1');console.log(re.exec(str));console.log(newstr); 플래그 g: 전역 검색 i: 대소문자 구분 없는 검색 m: 다중행 검색 s: .에 개행 문자도 매칭 u: 유니코드, 패턴을 유니코드 코드 포인트의 나열로 취급 y: “sticky”검색을 수행. 문자열의 현재 위치부터 검색을 수행 12345var re = /\\w+\\s/g;var str = 'fee fi fo fum';var myArray = str.match(re);console.log(myArray); var re = /\\w+\\s/g; var re = new RegExp(“\\w+\\s”, “g”); 이 둘은 동일하다. str.match(re) re.exec(str) match와 exec는 사용방법이 다르다 12345678910111213var xArray;while ((xArray = re.exec(str))) console.log(xArray);console.log();console.log(re.exec(str));console.log(re.exec(str));console.log(re.exec(str));console.log(re.exec(str));console.log(re.exec(str));console.log(re.exec(str));console.log(re.exec(str));console.log(re.exec(str));console.log(); m 플래그는 여러 줄의 입력 문자열이 실제로 여러 줄로 다뤄져야 하는 경우에 사용함 만약 m 플래그가 사용되면 ^, $ 문자는 전체 문자열의 시작과 끝에 대응되지 않고, 각 라인의 시작과 끝에 대응됨","link":"/2022/01/28/Javascript-%EC%A0%95%EA%B7%9C%ED%91%9C%ED%98%84%EC%8B%9D-%EC%A0%95%EB%A6%AC2/"},{"title":"Javascript 정규표현식","text":"Javascript 정규표현식패턴 생성12let pattern = /a/;let pattern - new RegExp('a'); RegExp 객체의 정규 표현식RegExp.exec() 실행 결과는 문자열 a를 값으로 하는 배열을 리턴한다. a가 없다면 null을 리턴한다. 필요 정보 추출 12console.log(pattern.exec('abcdef')); // ['a']console.log(pattern.exec('bcdef')); // null RegExp.test() 정보가 존재하는지 확인 12console.log(pattern.test('abcdef')); // trueconsole.log(pattern.test('bcdef')); // false String 객체의 정규 표현식String.match()12345let str = 'abcdef';str.match(pattern); // ['a']let str = 'bcdef';str.match(pattern); // null String.replace()12let str = 'abcdef';str.match(pattern, 'A'); // 'Abcdef' 옵션i 대소문자를 구분하지 않는다. 12345let pattern = /a/;console.log('Abcdef'.match(pattern)); // nulllet pattern = /a/i;console.log('Abcdef'.match(pattern)); // ['A'] g 모든 결과를 반환한다. 12345let pattern = /a/;console.log('abcdefa'.match(pattern)); // ['a']let pattern = /a/g;console.log('abcdefa'.match(pattern)); // ['a', 'a']","link":"/2021/11/17/Javascript-%EC%A0%95%EA%B7%9C%ED%91%9C%ED%98%84%EC%8B%9D/"},{"title":"Lightsail 시작하기","text":"lightsail은 플랫폼과 시작 이미지를 선택하는 것만으로 인스턴스를 바로 시작할 수 있다. 웹 사이트 블로그 단순 앱 개발 및 테스트 환경 소수의 서버로 구성된 비즈니스 소프트웨어 구축 과정 AWS Lightsail 접속 Lightsail 인스턴스 생성 Lightsail 인스턴스 확인 wordpress 사용자 설정 wordpress 관리자 설정A. 사용자명, 패스워드 설정을 위한 원격 서버 접속B. Bitnami(SSH) 접속을 통한 아이디 패스워드 생성/확인C. wordpress 관리자 페이지 접속/확인 AWS console에서 lightsail 접속 인스턴스 생성을 누른다. 첫번째는 인스턴스 이미지를 선택하는 과정이다. 플랫폼과 블루푸린트 메뉴가 존재한다. 플랫폼은 Linux/Unix를 선택하며, 블루프린트는 Wordpress를 선택한다. 시작 스크립트는 맨 처음 서버가 구성될 때 실행되는 스크립트이며, 사용자에 따라 필수적으로 설치해야 하는 소프트웨어가 있을 경우 선택한다. SSH 키 페어는 원격 서버 접속을 위해 사용한다. 인스턴스 플랜은 프리티어 가입 후 첫 달 무료 서비스를 이용하기 위해 가장 저렴한 플랜을 선택한다. 인스턴스 확인에서 고유한 이름을 선택해야하며, 인스턴스 수를 늘릴경우 추가 요금이 발생할 수 있다. 처음 인스턴스를 생성하면 실행 중 메시지가 뜨며, IP 주소가 할당된다. 해당 IP 주소를 웹 브라우저에 입력하면 기본으로 생성되는 포스트와 블로그 레이아웃을 볼 수 있다. 관리자 페이지는 퍼블릭IP/wp-damin 이다. 관리자 대시보드를 이용하기 위해서는 유저명과 비밀번호를 입력해야 한다. lightsail 대시보드에 돌아가 이름 옆의 콘솔 창을 클릭한다. CLI console창이 뜬다. 1$ cat bitnami_credentials 명령어를 입력하면 default userName과 password를 출력한다. bitnami 관리자 정보는 잘 보관되어야 한다. 관리자 정보를 통하여 관리자 대시보드로 접속 가능하다. Setting의 General에서 Site Language를 한국어로 바꾸고 저장한다. wordpress와 polly wordpress 플러그인 설정 lightsail 기반 wordpress 사용을 위한 IAM 설정A. 정책 설정B. 정책 샐성 및 검토C. 사용자 설정D. 사용자 생성E. 기존 정책과 사용자 연결F. 사용자 키 보관 wordpress 플러그인 설정 및 사용 플러그인을 보면 AWS for WordPress가 보인다. 활성화를 클릭한다. 활성화를 하면 AWS라는 매뉴가 나타난다. 클릭하면 AWS access key와 AWS secret key를 입력하라는 메시지가 출력된다. 이를 이용하기 위해서는 IAM이 필요하다. IAM의 대시보드를 들어가면 액세스 관리에 사용자와 정책이 있다. 정책 생성을 클릭한 후 시각적 편집기가 아닌 JSON을 클릭한다. 1234567891011121314151617{ &quot;Version&quot;: &quot;2012-10-17&quot;, &quot;Statement&quot;: [ { &quot;Sid&quot;: &quot;Permissions1&quot;, &quot;Effect&quot;: &quot;Allow&quot;, &quot;Action&quot;: [&quot;s3:HeadBucket&quot;, &quot;polly:SynthesizeSpeech&quot;, &quot;polly:DescribeVoices&quot;, &quot;translate:TranslateText&quot;], &quot;Resource&quot;: &quot;*&quot; }, { &quot;Sid&quot;: &quot;Permissions2&quot;, &quot;Effect&quot;: &quot;Allow&quot;, &quot;Action&quot;: [&quot;s3:ListBucket&quot;, &quot;s3:GetBucketAcl&quot;, &quot;s3:GetBucketPolicy&quot;, &quot;s3:PutObject&quot;, &quot;s3:DeleteObject&quot;, &quot;s3:CreateBucket&quot;, &quot;s3:PutObjectAcl&quot;], &quot;Resource&quot;: [&quot;arn:aws:s3:::audio_for_wordpress*&quot;, &quot;arn:aws:s3:::audio-for-wordpress*&quot;] } ]} 해당 json 파일을 복사 &amp; 붙여넣기 한다. 정책 검토를 하면 다음과 같은 화면이 나온다. 정책 명을 policy_for_wordpress_polly으로 입력한 후 정책 생성을 클릭한다. 정책이 생성되었으면, 사용자에서 사용자 추가를 클릭한다. 사용자 이름은 userForWordpress로 하며, 액세스 유형은 일반 사용자가 아닌 워드프레스라는 애플리케이션을 통해 AWS에 서비스 접근하기 때문에 ‘프로그래밍 방식 액세스’를 선택한다. 기존 정책 직접 연결을 통하여 방금 생성한 정책을 선택한다. 태그 화면은 별도의 설정을 하지 않고 넘어간다. 이상이 없다면 사용자 만들기를 클릭한다. 프로그래밍 액세스 방식은 액세스 키와 비밀 액세스 키가 발급된다. 키는 .csv 파일로 보관할 수 있다. 앞서 생성한 키를 입력한다. 변경 사항 저장을 클릭한다. Text to Speech에서 source language를 한국어로 선택하며, Enable text-to-speech support를 체크한다. 글을 클릭한 후 새로 추가를 선택한다. 제목과 내용을 입력한 후 밑에 있는 enable Text-to-speech에 체크 박스를 선택한다. 우측 상단의 공개 버튼을 클릭한다. 다음과 같이 포스트된 글을 확인할 수 있으며, 재생 버튼을 통하여 polly 서비스를 확인할 수 있다. 다운로드도 가능하다. 첫 한달 간은 무료로 사용이 가능하지만, 그 이후로는 매달 $3.5의 금액이 나가므로, 실습 후 인스턴스를 삭제한다.","link":"/2020/09/29/Lightsail-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/"},{"title":"Lambda 시작하기","text":"AWS Lambda 함수 기반 문자 알림 서비스를 구축해본다. 구축 과정 SNS 서비스 실행 권한을 위한 IAM 정책 설정A. 정책 생성 및 검토(정책 이름 policy_for_publising_SNS)B. 역할 생성(역할 이름 role_for_sns_sending) SNS 람다 함수 만들기A. 람다 함수 생성(람다 함수 이름 : lambda_for_sns)B. 람다 함수 실행 역할 생성(람다 역할 이름 : role_for_sns_sending) SNS 람다 이벤트 구성A. 람다 함수 이벤트 이름(eventForSendingsSNS)B. 람다 함수 소스코드 작성 SNS 람다 함수 테스트 AIM 대시 보드에서 죄측 정책 메뉴를 클릭한 후 정책 생성을 선탣한다. 서비스 선택에서 SNS 입력 후 필터링 된 SNS를 선택한다. 문자 보내기는 사용자에게 알림 서비스를 생성하는 것이므로 액세스 레벨 “쓰기”에 해당한다. 리소스는 모든 리소스를 선택한다. 요청 조건은 기본 설정으로 하고 정책 검토를 클릭한다. 정책 이름은 policy_for_publising_SNS로 한 후 정책 생성을 클릭한다. 정책과 연결해 줄 역할을 만든다. 역할 만들기를 선택한다. 신뢰할 수 있는 유형의 개체로 AWS 서비스를 선택한다. 사용 사례 선택은 Lambda를 선택한다. 권한 정책 연결에서 policy_for_publising_SNS를 선택한다. 태그는 없으므로 넘어간다. 역할 이름에 role_for_sns_sending를 입력하고 역할 만들기를 선택한다. AWS console에서 Lambda를 클릭한다. 람다 함수 대시보드에서 함수 생성을 선택한다. 함수 이름은 lambda_for_sns로 입력한다. 권한은 기존 역할 사용을 선택하며, role_for_sns_sending을 선택한다. 함수 행성을 선택한다. 성공적으로 함수가 만들어진 후 이벤트 선택에서 테스트 이벤트 구성을 선택한다. 이벤트 이름은 eventForSendingsSns로 입력한 후, 코드는 다음과 같이 입력한다. 1234{ &quot;text&quot;: &quot;hello world&quot;, &quot;number&quot;: &quot;+821012345678&quot;} 함수 코드에는 다음과 같이 입력한다. 12345678910111213141516171819202122232425262728293031//AWS를 실행시키기위한 라이브러리를 가져옵니다.const AWS = require('aws-sdk');//이전과 다른부분이 있다면 context와 callback을 파라미터로 받습니다.//context에서는 현재 실행중인 람다의 메타정보를 받고//callback은 람다가 끝나는 시점 호출합니다.exports.handler = (event, context, callback) =&gt; { //위에 입력했던 json값이 event 즉 input으로 들어옵니다. //params에 Message와 PhonNumber 변수를 선언합니다. const params = { Message: event.text, PhoneNumber: event.number, }; // SNS SDK를 가져옵니다. // SNS서비스에서 메세지를 보내는것은 한정된 리전에서만 사용할 수 있기때문에 // region을 도쿄리전으로 설정해주어야합니다. 이를 위해 인자값으로 // region에 도쿄리전의 식별자인 'ap-northeast-1'을 입력합니다. const publishTextPromise = new AWS.SNS({ apiVersion: '2010-03-31', region: 'ap-northeast-1' }).publish(params).promise(); // SDK를 실행합니다. publishTextPromise .then(function (data) { //메세지가 있다면 첫번째에 null, 두번째에 메세지를 리턴합니다. callback(null, 'MessageID is ' + data.MessageId); }) .catch(function (err) { //에러가 있다면 err를 리턴합니다. callback(err); });}; 오른쪽 상단의 테스트 버튼을 클릭하면 함수가 실행된다. 입력한 텍스트가 문자로 온 것을 확인할 수 있다","link":"/2020/10/27/Lambda-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/"},{"title":"Node.js readline으로 입력 및 반환받기","text":"readline readline 모듈은 한 번에 한 줄씩 Readable 스트임에서 데이터를 읽기 위한 인터페이스를 제공한다. readline.createInterface()를 통해 생성 가능하며, close()를 통해 입력받는 것을 종료한다. 사용 예시한줄 씩 입력받기 한줄씩 입력 받으며, ‘quit’, ‘exit’, 그리고 ctrl + c 입력 때까지 반복한다. 123456789101112131415161718192021222324252627282930const readline = require('readline');const rl = readline.createInterface({ input: process.stdin, output: process.stdout,});function main() { rl.setPrompt(`Input data: `); rl.prompt();}rl.on('line', function (data) { switch (data) { case 'quit': case 'exit': rl.close(); } console.log(`Output data: ${data}\\n`); main();});rl.on('close', () =&gt; { console.log(); console.log('exit...'); process.exit();});main(); 일정 횟수 입력받기 5번 입력 받으며, 입력 종료 후 입력된 정보를 출력한다. 123456789101112131415161718192021222324252627282930313233343536373839404142const readline = require('readline');const rl = readline.createInterface({ input: process.stdin, output: process.stdout,});let question = ['첫 번째 질문', '두 번째 질문', '세 번째 질문', '네 번째 질문', '다섯 번째 질문'];let answer = [];let cnt = 0;function questionFunc() { rl.setPrompt(`${question[cnt]}: `); rl.prompt();}rl.on('line', function (data) { switch (data) { case 'quit': case 'exit': rl.close(); } answer.push(data); cnt++; if (cnt &lt; question.length) questionFunc(); else rl.close();});rl.on('close', function () { console.log(); question.map((v, i) =&gt; { console.log(`${v}에 대한 답: ${answer[i] === undefined ? '질문에 대답하지 않음' : answer[i]}`); }); process.exit();});questionFunc(); 입력 후 비동기 처리하기 입력된 정보를 일정 시간(5,000ms) 후 출력한다. 출력 후 다시 입력을 받도록 한다. 1234567891011121314151617181920212223242526272829303132333435363738const readline = require('readline');const rl = readline.createInterface({ input: process.stdin, output: process.stdout,});function main() { rl.setPrompt(`Input data: `); rl.prompt();}function asynchronous(data) { return new Promise((resolve) =&gt; { setTimeout(() =&gt; { return resolve(data); }, 5000); });}rl.on('line', async function (data) { switch (data) { case 'quit': case 'exit': rl.close(); } console.log(`Output data(5,000ms...): ${await asynchronous(data)}\\n`); main();});rl.on('close', () =&gt; { console.log(); console.log('exit...'); process.exit();});main();","link":"/2022/01/27/Node-js-readline%EC%9C%BC%EB%A1%9C-%EC%9E%85%EB%A0%A5-%EB%B0%8F-%EB%B0%98%ED%99%98%EB%B0%9B%EA%B8%B0/"},{"title":"Python 가상환경 설정하기","text":"파이썬 가상환경 파이썬의 venv 모듈은 자체 사이트 디렉터리를 갖는 경량 가상 환경을 만들고, 선택적으로 시스템 사이트 디렉터리에서 격리할 수 있도록 지원한다. 명령프롬프트에서 다음을 입력한다. 12345# 기본 명령어python -m venv venv# 현재의 파이썬 전역 패키지들을 설치python -m venv 가상환경이름 --system-site-packages 가상환경 접속1venv\\Scripts\\activate.bat 1(venv) C:\\Users\\user&gt; 가상환경이 활성화되었다. 주피터 노트북을 사용하기 위한 환경설정 주피터 노트북을 이용하기 위해 jupyter 모듈을 설치한다. 추가적으로 사용할 다양한 라이브러리를 설치한다. 1234pip3 install jupyterpip3 install matplotlib... 주피터 노트북 실행 명령어1python -m notebook 추후 접속하기 가상환경에 설치된 주피터 노트북을 실행하기 위해서는 다음 두 명령어를 입력한다. 12venv\\Scripts\\activate.batpython -m notebook 가상환경 삭제 가상환경의 삭제는 설치된 ‘venv’ (가상환경 디렉터리 이름) 디렉터리 자체를 그냥 삭제해주면 된다.","link":"/2022/01/27/Python-%EA%B0%80%EC%83%81%ED%99%98%EA%B2%BD-%EC%84%A4%EC%A0%95%ED%95%98%EA%B8%B0/"},{"title":"Raspberry Pi 4 gpio 시작하기","text":"Node.js 설치12345678910111213141516$ mkdir download$ cd download$ wget https://nodejs.org/dist/v8.11.4/node-v8.11.4-linux-armv7l.tar.xz$ tar -xvf node-v8.11.4-linux-armv7l.tar.xz$ cd node-v8.11.4-linux-armv7l$ sudo cp -R * /usr$ cd ../..$ node -vV8.11.4$ npm -v5.6.0$ gpio -vgpio version: 2.46 Raspberry Pi 4에서의 에러1$ gpio readall // error Raspberry Pi 3에서는 실행되는 명령어 Raspberry Pi 4에서는 에러가 발생 이는 루트 계정으로 접속하여 wiringpi를 업데이트 해준다. 123$ su$ wget https://project-downloads.drogon.net/wiringpi-latest.deb$ sudo dpkg -i wiringpi-latest.deb 루트 계정으로 접속하지 않으면 권한때문에 다운로드가 불가능하다. 12$ gpio readall$ exit gpio 테스트 Raspberry Pi 4에 LED를 연결 후 테스트 1$ npm install node-wiring-pi 123456789101112131415161718192021const gpio = require('node-wiring-pi');const LEDPIN = 29;var count = 0;const TimeOutHandler = function () { if (count &gt; 0) { gpio.digitalWrite(LEDPIN, 1); console.log('Node: LED on'); count = 0; } else { gpio.digitalWrite(LEDPIN, 0); console.log('Node: LED off'); count = 1; } setTimeout(TimeOutHandler, 1000);};gpio.setup('wpi');gpio.pinMode(LEDPIN, gpio.OUTPUT);setTimeout(TimeOutHandler, 1000);","link":"/2021/11/15/Raspberry-Pi-4-gpio-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/"},{"title":"Raspberry Pi mysql 시작하기","text":"mysql 설치1$ sudo apt-get install mariadb-server mysql 설정123$ cd /etc/mysql/mariadb.conf.d$ sudo cp 50-server.cnf server.cnf.backup$ sudo vi 50-server.cnf bind-address = 127.0.0.1를 주석처리 한다. 1# bind-address = 127.0.0.1 mysql 시작하기123$ sudo systemctl restart mariadb.service$ cd -$ sudo mysqladmin -u root password 'gachon654321' 12345678910$ sudo mysql -u root -pEnter password: *MariaDB &gt; set password for root@localhost = password('gachon654321');MariaDB &gt; use mysql;MariaDB &gt; update user set authentication_string=password(''), plugin='mysql_native_password' where user='root';MariaDB &gt; flush privileges;MariaDB &gt; exit$ mysql -u root -pEnter password: *MariaDB &gt; mysql 테스트 추후 진행할 9축센서 데이터를 이용한 충격감지 알고리즘 개발을 위한 데이터베이스 생성 12create database 9axisdb;use 9axisdb; 123456create table ShockData(time datetime(3), shocklevel int, shockdirection int, azimuthshockdirection int, shockvalue float, degree int, azimuth int, code int, message varchar(256));create table Log(time datetime(3), log varchar(256));desc ShockData;desc Log;","link":"/2021/11/15/Raspberry-Pi-mysql-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/"},{"title":"Raspberry Pi 4 초기 세팅하기","text":"Download http://www.etcher.io https://www.raspberrypi.org/downloads/raspbian 중요 설정1$ sudo raspi-config 12345678910111213141516171819202122231. System Options S5. Boot / Auto Login Select boot into desktop or to command line B4. Desktop Autologin Desktop GUI, automatically logged in as 'pi' user3. Interface Options P2. SSH -&gt; Yes P5. I2C -&gt; Yes5. Localisation Options L1. Locale en_GB.UTF-8 UTF-8 en_US.UTF-8 UTF-8 ko_KR.UTF-8 UTF-8 ko_KR.UTF-8 UTF-8 -&gt; Ok L2. TimeZone Asia/SeoulFinish -&gt; Reboot? -&gt; No 언어 설정12345$ sudo apt-get install ibus$ sudo apt-get -y install ibus-hangul$ sudo apt-get -y install fonts-unfonts-core$ sudo reboot root 계정 암호 설정 su 명령어를 사용하기 위해 필수적으로 설정 12345$ sudo passwd root새 UNIX 암호:$exit","link":"/2021/11/15/Raspberry-Pi-4-%EC%B4%88%EA%B8%B0-%EC%84%B8%ED%8C%85%ED%95%98%EA%B8%B0/"},{"title":"Raspberry Pi 모니터 없이 ssh와 wifi 설정하기","text":"Raspberry Pi의 한계점 라즈베리 파이를 처음 설치한 후 ssh 접속을 위해서는 무선 연결, 또는 유선 연결을 하여야 한다. 또한, 무선 연결이나 유선 연결을 한 후 IP주소를 알아야 한다. 이는 만약에 모니터가 없거나 Serial 케이블이 없다면 알 수 있는 방법이 없다. 이를 해결하기 위해 라즈베리 파이의 파일 설정하는 방법을 알아야 한다. ssh 활성화 초기설정을 아직 진행하지 않은 Raspbian이 설치된 SD카드를 데스크탑에 연결한다. 포맷은 진행하지 않으며, 데스크탑에 연결할 경우 boot 파티션이 나타난다. boot 디렉터리에서 확장자 없이 ssh 파일을 생성한다. wifi 설정 초기설정을 아직 진행하지 않은 Raspbian이 설치된 SD카드를 데스크탑에 연결한다. 포맷은 진행하지 않으며, 데스크탑에 연결할 경우 boot 파티션이 나타난다. boot 디렉터리에서 확장자 없이 wpa_supplicant.conf 파일을 생성한다. 라즈비안 최신 버전인 ‘Stretch’의 경우 123456ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdevnetwork={ ssid=&quot;접속하고자 하는 wifi 이름&quot; psk=&quot;접속하고자 하는 wifi 비밀번호&quot; key_mgmt=WPA-PSK} 그 이전 버전 12345network={ ssid=&quot;접속하고자 하는 wifi 이름&quot; psk=&quot;접속하고자 하는 wifi 비밀번호&quot; key_mgmt=WPA-PSK} 다음과 같은 결과가 나타난다. ssh 접속 후 wifi 설정1sudo vi /etc/wpa_supplicant/wpa_supplicant.conf priority가 높은 것을 먼저 시도한다. 12345678910111213network={ ssid=&quot;~&quot; psk=&quot;~&quot; priority=1 key_mgmt=WPA-PSK}network={ ssid=&quot;~&quot; psk=&quot;~&quot; priority=2 key_mgmt=WPA-PSK}","link":"/2022/01/27/Raspberry-Pi-%EB%AA%A8%EB%8B%88%ED%84%B0-%EC%97%86%EC%9D%B4-ssh%EC%99%80-wifi-%EC%84%A4%EC%A0%95%ED%95%98%EA%B8%B0/"},{"title":"Raspberry Pi 부팅 시 프로그램 자동 수행","text":"텔레그램 서버를 라즈베리 파이가 부팅하는 동시에 실행하여 별도의 디스플레이 없이 ssh 접속 IP를 얻도록 한다. 라즈베리 파이가 부팅할 때 프로그램을 자동으로 수행 시키기 위해서는 루트 권한이 필요하다. su 명령어를 이용해 루트 계정으로 접속한다. 부팅 프로그램은 /etc 디렉터리에 존재하므로 cd 명령어를 이용해 이동한다. 부팅 프로그램 작성 전 중요 테스트 부팅 프로그램에서 실수를 한다면 부팅이 되지 않는 심각한 오류에 걸릴수도 있다. 이를 방지하기 위해 해당 디렉터리에서 절대 경로로 작성한 코드를 테스트 한다. 1node /home/user/Telegram/telegram.js rc.local 파일을 열고 exit 0 위에 실행할 명령어를 입력한다. 이 때, 중요한 점은 텔레그램 봇 서버와 같이 종료가 되지 않는 프로그램의 경우 &amp;를 붙여야 한다. 이를 통하여 텔레그램 봇 서버는 부팅과 별도로 수행된다. 12345678910vi rc.local~~node /home/user/Telegram/telegram.js &amp;exit 0:wq 라즈베리 파이를 재부팅하여 텔레그램 봇 서버가 정상적으로 동작하는 지 확인한다. 1sudo reboot 획인","link":"/2021/11/24/Raspberry-Pi-%EB%B6%80%ED%8C%85-%EC%8B%9C-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8-%EC%9E%90%EB%8F%99-%EC%88%98%ED%96%89/"},{"title":"Raspberry Pi에 code-server 설치하기","text":"Code-server란? 아이패드를 구입하고, 아이패드를 이용한 코딩을 하려고 시도하였지만, 아이패드에는 마땅한 어플이 존재하지 않는다. 따라서, 웹 브라우저를 이용해 서버의 환경에서 코딩을 할 수 있는 code-server를 이용하고자 한다. 이를 위해 goormide를 이용한 code-server를 구축하였지만, 이는 goormide가 켜저 있어야 하며, 이는 유료 플랜에서만 지원한다. 따라서, Raspberry Pi를 이용해 code-server를 구축하고, 이를 포트포워딩 하여 24시간 언제 어디에서나 코딩을 할 수 있는 환경을 구축하고자 한다. Code-server의 한계점 라즈베리파이에 보통 설치하는 운영체제는 라즈비안이다. 이는 32bit 운영체제만 지원하며, code-server가 지원하지 않아 동작이 불가능하다. 이를 해결하기 위해 라즈베리 파이에 64bit 운영체제인 우분투를 설치하여 해결한다. Raspberry Pi 우분투 설치 https://www.balena.io/etcher/ : SD카드를 라이브 USB로 만들기 위해 압축 폴더 뿐 아니라 iso파일, .img파일과 같은 이미지 파일을 저장매채에 기록하는 데 사용하는 무료 오픈 소스 유틸리티 https://ubuntu.com/download/raspberry-pi : 라즈베리파이 전용 우분투 (Ubuntu Desktop을 다운로드 한다.) Flash하여 SD카드에 우분투를 설치한다. 주의 사항 SD카드 파티션 재설정 후 포맷을 하지 않는다 -&gt; 오류가 발생 F: 드라이브의 디스크를 사용하기 전에 포맷해야 합니다. -&gt; 취소 초기 설정 Welcome -&gt; 한국어 키보드 레이아웃 -&gt; Korean -&gt; Korean (English(US)도 상관없다) 무선네트워크 설정 거주지 -&gt; Seoul 당신은 누구십니까? 이름: user 암호 선택: gachon654321 암호 확인: gachon654321 자동으로 로그인 (선택) Terminal 설치12345sudo apt-get install -y curlsudo apt-get install vimsudo apt install net-toolssudo apt install openssh-serversudo apt install nodejs Code-server 설치 code-server를 설치한다. 1curl -fsSL https://code-server.dev/install.sh | sh 실행 후 ctrl + c를 통해 종료한다. 처음 실행을 하여야 설정 파일이 생성된다. 설정 파일에서 접속 아이피와 비밀번호를 입력한다. 초기 비밀번호는 랜덤적인 문자열이므로, 반드시 수정하여야 한다. 1vim ~/.config/code-server/config.yaml 1234bind-addr: 127.0.0.1:8080auth: passwordpassword: ~~~~cert: false 1234bind-addr: 0.0.0.0:8080auth: passwordpassword: gachon654321cert: false bind-addr은 0.0.0.0:8080으로 수정한다. password는 원하는 비밀번호로 수정한다. code-server 재실행1code-server 비밀번호를 입력한 후 code-server를 이용할 수 있다. 포트포워딩 포트포워딩을 이용하여 외부에서 접속이 가능하다. nohup을 이용한 부팅 시 자동 실행 방법 nohup는 “no hangups”라는 의미로, 쉘 스크립트 파일을 데몬 형태로 실행하는 명령이다. 터미널이 끊겨도 실행한 프로세스는 계속 동작하게 된다. &amp;를 추가하여 백그라운드로 실행시킨다. 1nohup code-server &amp; 부팅 시 실행 방법 사용자의 메인 디렉터리에서 scripts.sh 파일에 부팅시 실행할 명령어를 입력한다. 1vi scripts.sh 1nohup code-server &amp; :wq로 저장한다. sh파일의 권한을 변경하여 실행이 가능하도록 한다. 1chmod +x scripts.sh crontab 명령어를 실행해서 예약 파일을 편집한다. 1crontab -e 맨밑에 추가한다. 1@reboot /home/user/scripts.sh 리부트 한다. 1reboot","link":"/2022/01/27/Raspberry-Pi%EC%97%90-code-server-%EC%84%A4%EC%B9%98%ED%95%98%EA%B8%B0/"},{"title":"Raspberry Pi에서 MPU9250을 이용한 9축 데이터 수집 with python","text":"참고 사이트 https://medium.com/@niru5/hands-on-with-rpi-and-mpu9250-part-3-232378fa6dbc MPU9250 9축 센서 모듈 연결 MPU9250은 3축 가속도 센서, 3축 자이로 센서, 그리고 3축 지자기 센서를 통합한 센서이다. 사용하는 핀은 3.3v, GND, SDA, 그리고 SCL이며, 다음과 같이 연결한다. 연결 후 테스트 1$ i2cdetect -y 1 Python 모듈 설치12$ pip3 install imusensor$ pip3 install easydict 테스트 코드123456789101112131415161718192021import osimport sysimport timeimport smbusfrom imusensor.MPU9250 import MPU9250address = 0x68bus = smbus.SMBus(1)imu = MPU9250.MPU9250(bus, address)imu.begin()while True: imu.readSensor() imu.computeOrientation() print (&quot;Accel x: {0} ; Accel y : {1} ; Accel z : {2}&quot;.format(imu.AccelVals[0], imu.AccelVals[1], imu.AccelVals[2])) print (&quot;Gyro x: {0} ; Gyro y : {1} ; Gyro z : {2}&quot;.format(imu.GyroVals[0], imu.GyroVals[1], imu.GyroVals[2])) print (&quot;Mag x: {0} ; Mag y : {1} ; Mag z : {2}&quot;.format(imu.MagVals[0], imu.MagVals[1], imu.MagVals[2])) print (&quot;roll: {0} ; pitch : {1} ; yaw : {2}&quot;.format(imu.roll, imu.pitch, imu.yaw)) time.sleep(0.1) 추후 작업을 위한 추가 설치 예를 들어, Raspberry Pi의 전원이 들어오는 동시에 측정을 하고자 한다면, root 계정에 Python 모듈의 추가 설치가 필요하다. 123$ su$ sudo pip3 install imusensor$ sudo pip3 install easydict","link":"/2021/11/15/Raspberry-Pi%EC%97%90%EC%84%9C-MPU9250%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%9C-9%EC%B6%95-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%88%98%EC%A7%91-with-python/"},{"title":"Raspberry Pi에서 MPU9250을 이용한 9축 데이터 수집 with Node.js","text":"참고 사이트 https://www.npmjs.com/package/mpu9250 MPU9250 9축 센서 모듈 연결 MPU9250은 3축 가속도 센서, 3축 자이로 센서, 그리고 3축 지자기 센서를 통합한 센서이다. 사용하는 핀은 3.3v, GND, SDA, 그리고 SCL이며, 다음과 같이 연결한다. 연결 후 테스트 1$ i2cdetect -y 1 Node.js 모듈 설치 모듈 설치는 권한 때문에 루트 계정으로 수행한다. 12$ su$ npm install mpu9250 테스트 코드123456789101112131415161718192021var mpu9250 = require('mpu9250');var mpu = new mpu9250({ device: '/dev/i2c-1', address: 0x68, UpMagneto: true, scaleValues: true, // 전처리 DEBUG: false, ak_address: 0x0c, GYRO_FS: 0, ACCEL_FS: 2, DLPF_CFG: mpu9250.MPU9250.DLPF_CFG_3600HZ, A_DLPF_CFG: mpu9250.MPU9250.A_DLPF_CFG_460HZ, SAMPLE_RATE: 8000,});mpu.initialize();setInterval(() =&gt; { console.log(mpu.getMotion9());}, 50);","link":"/2021/11/15/Raspberry-Pi%EC%97%90%EC%84%9C-MPU9250%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%9C-9%EC%B6%95-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%88%98%EC%A7%91-with-Node-js/"},{"title":"Raspbian Docker 설치하기","text":"Docker 설치하기 Raspbian은 Docker가 기본으로 설치되어 있지 않으므로, apt를 이용해 설치하는 과정이 필요하다. 12apt install docker.iodocker -v Docker 예제 실행하기 설치된 Docker를 이용해 예제를 빌드하고 실행한다. 해당 예제는 express.js 위에서 REST API 형태로 제공되는 기능이므로, Docker 내부의 포트를 외부의 포트와 연결하여야 한다. 12docker build . -t passwordsecurityserverdocker run -p 65001:65001 -d passwordsecurityserver 해당 컨테이너의 bash로 들어가기 위해서는 다음과 같이 exec 명령어를 사용한다. 1docker exec -it &lt;container ID&gt; /bin/bash 예제 실행하기 run 명령어를 통해 docker는 실행중이며, 다음과 같이 확인할 수 있다. 12# GEThttp://localhost:65001/passwordModelTrain?versionData=0.2&amp;comment=TestComment localhost:65001 : 비밀번호 보안성 학습모듈이 실행중인 IP와 포트 versionData=0.2 : 학습을 요청할 모델 버전 comment=TestComment : 코멘트 1234567891011// 버전 중복{ &quot;state&quot;: 301, &quot;comment&quot;: &quot;0.1은 중복된 버전&quot;}// 학습 정상 동작{ &quot;state&quot;: 200, &quot;comment&quot;: &quot;0.2 model 학습 시작&quot;}","link":"/2022/01/27/Raspbian-Docker-%EC%84%A4%EC%B9%98%ED%95%98%EA%B8%B0/"},{"title":"Raspbian OS BackUp 하기","text":"준비물 현재 시스템이 돌아가고 있는 Micro SD card BackUp을 위한 포맷이 완료된 Micro SD card BackUp 새로운 SD card를 SD card 리더기에 연결한 후 현재 사용중인 Raspberry Pi의 USB 포트에 연결한다. SD Card Copier에 접속 시작 메뉴 Accessories SD Card Copier SD Card Copier 설정 윗 부분(현재 시스템이 돌아가고 있는 SD card): SC16G(/dev/mmcblk0) 아래 부분(BackUp을 실행할 SD card): Generic Mass-Storage(/dev/sda) Start BackUp 완료 주의 사항 cloud not set flag 에러: 사용 중인 공간과 빈 공간을 그대로 가져오므로 현재 시스템이 돌아가고 있는 SD card와 동일, 또는 그 이상 크기의 SD card로 수행하여야 한다.","link":"/2021/11/29/Raspbian-OS-BackUp-%ED%95%98%EA%B8%B0/"},{"title":"S3 시작하기","text":"S3은 어디서나 원하는 양의 데이터를 저장하고 검색할 수 있도록 구축된 객체 스토리지이다. S3은 스토리지 형식으로 객체 스토리지를 사용한다. 계층 구조가 없고, 고유식별 번호와 데이터 그리고 메타 데이터 등 최소한의 정보만을 가지고 있기 때문에 파일 개수가 많아져도 파일 스토리지에 비해 훨씬 많은 수의 파일들을 처리할 수 있다. 높은 내구성 손쉬운 혹장성 보안성과 편리성 관리 유연성 &lt;부트 스토립을 이용한 반응형 페이지 생성 실습&gt; 부트스트랩 홈페이지 접속 부트스트랩 템플릿 다운로드 S3버킷 생성 부트스트랩 템플릿 파일 업로드 정적 웹 사이트 설정 엔드포인트 URL을 통한 부트스트랩 index.html 확인 AWS 콘솔에서 스토리지 서비스인 S3을 검색한다. 다음과 같은 화면이 나오면 버킷 만들기를 클릭한다. 버킷 이름과 리전을 선택한다. 이 때, 버킷 이름은 저세계에서 유일해야 하며, 리전은 Educate 버전 사용 시 버지니아 북부로 해야 한다. 옵션은 기본으로 설정하고 넘어간다. 모든 퍼블릭 엑세스 차단을 해제한다. 차단을 해제 하여야 외부 사람이 접근 가능하다. 검토 후 문제가 없다면 버킷 만들기를 선택한다. 버킷이 새로 만들어 졌다. 새로 새성한 버킷을 선택하면 다음과 같은 화면이 출력된다. https://startbootstrap.com/ 부트스트랩을 이용한 반응형 웹 페이지를 만드려고 한다. 부트스트랩 사이트에서 마음에 드는 템플릿을 다운 받는다 다운받은 템플릿의 압축을 풀면 다음과 같은 파일들이 생겨난다. 해당 파일 전부를 업로드를 한다. 퍼블릭 권한 관리에서 “이 객체를 퍼블릭 읽기 엑세스 권한을 부여함”을 선택한다. 스토리지 클래스는 기본인 스탠다드를 선택한다. 완료 후 속성의 정적 웹 사이트 호스팅을 선택한다. 이 버킷을 사용하여 웹 사이트를 호스팅합니다를 선탣한다. 인덱스 문서는 엔드 포인트로 index.html을 입력한다. 엔드포인트는 다음과 같다. 해당 엔드 포인트를 웹 브라우저에 입력하면 해당하는 웹 페이지가 정상적으로 뜨는 것을 볼 수 있다.","link":"/2020/10/06/S3-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/"},{"title":"Ubuntu 환경에서 Node.js와 Python 설치 및 관리","text":"Node.js 설치 https://github.com/nodesource/distributions 우분투는 기본적으로 Node.js가 설치되어 있지 않다. 따라서 이를 설치하고 관리하고자 한다. 12curl -fsSL https://deb.nodesource.com/setup_12.x | sudo -E bash -sudo apt-get install -y nodejs Node.js 버전 관리 https://github.com/nvm-sh/nvm nvm은 노드 버전을 쉽게 관리할 수 있게 해준다. 1curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.1/install.sh | bash nvm을 zsh가 읽을 수 있게 해줘야 한다. 만약 설치 후 nvm 명령어가 먹히지 않는다면 다음과 같은 명령어를 ~/.zshrc에 추가한다. 12export NVM_DIR=&quot;$([ -z &quot;${XDG_CONFIG_HOME-}&quot; ] &amp;&amp; printf %s &quot;${HOME}/.nvm&quot; || printf %s &quot;${XDG_CONFIG_HOME}/nvm&quot;)&quot;[ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; \\. &quot;$NVM_DIR/nvm.sh&quot; # This loads nvm 설정 후 변경이 가능한 모든 Node.js의 버전을 확인한다. 1nvm ls-remote 노드 버전을 설치한다. 12nvm install v16.13.1node -v Python 설치 파이썬은 기본적으로 python3 명령어를 통해 실행할 수 있다. 그러나, 버전 관리를 위해 좀 더 추가하도록 한다. 개인 페이지 (PPA) 추가 https://launchpad.net/~deadsnakes/+archive/ubuntu/ppa 123sudo add-apt-repository ppa:deadsnakes/ppa엔터sudo apt-get update 파이썬 3.8을 설치한다. 1sudo apt-get install python3.8 python3.8 명령어는 매우 귀찮으므로, ~/.zshrc 파일을 수정한다. 1alias python=python3.8 이를 통해 python 명령어로 python3.8을 실행할 수 있다.","link":"/2022/01/27/Ubuntu-%ED%99%98%EA%B2%BD%EC%97%90%EC%84%9C-Node-js%EC%99%80-Python-%EC%84%A4%EC%B9%98-%EB%B0%8F-%EA%B4%80%EB%A6%AC/"},{"title":"Windows 환경에서 Ubuntu 설치하기","text":"설치 전 참고 사항WSL 간편 설정 WSL 설치 및 세팅은 Docker를 설치한 후 실행하면 편하다. WSL2 업데이트가 나오는데, 커널 업데이트를 미리 실행할 것 https://www.docker.com/products/docker-desktop https://docs.microsoft.com/ko-kr/windows/wsl/install-manual#step-4---download-the-linux-kernel-update-package x64 머신용 최신 WSL2 Linux 커널 업데이트 패키지 다운 후 설치 Windows Terminal 설치 Windows Terminal을 chock 또는 microsoft store에서 설치를 할 것 Ubuntu 설치 Microsoft store에서 Ubuntu 18.0.4 LTS를 다운로드 한다. 처음 실행하면, username과 passowrd를 설정한다. sudo 명령어를 사용할 때, 해당 password를 이용하기 때문에 반드시 기억해야 한다. Windows Terminal을 보면 Ubuntu를 볼 수가 있는데, 이는 리눅스 환경에서 동작한다. WSL2 설치 확인 WSL2로 업데이트 및 확인을 위해 해당 명령어를 Ubuntu 콘솔에 작성한다. 만약 Docker를 설치하고, 커널 업데이트를 완료 했다면 다음과 같은 화면이 출력될 것이다. Windows Terminal 설정 Windows Terminal의 설정을 들어가면 Json 파일 열기가 있다. 이를 선택한다. Windows Terminal 선택 시 기본으로 열리는 콘솔을 Ubuntu로 하기 위해 settings.json의 “defaultProfile”을 수정한다. “Profiles”의 “list”를 보면 선택 가능한 콘솔이 있으며, “Ubuntu-18.04”의 “guid”를 복사해서 “defaultProfile”에 붙여넣는다. 12345678910111213141516{ &quot;$schema&quot;: &quot;https://aka.ms/terminal-profiles-schema&quot;, &quot;defaultProfile&quot;: &quot;{c6eaf9f4-32a7-5fdc-b5cf-066e8a4b1e40}&quot;, ... &quot;profiles&quot;: { &quot;list&quot;: [ ... { &quot;guid&quot;: &quot;{c6eaf9f4-32a7-5fdc-b5cf-066e8a4b1e40}&quot;, &quot;name&quot;: &quot;Ubuntu-18.04&quot;, &quot;source&quot;: &quot;Windows.Terminal.Wsl&quot; } ] }, ...} 재시작 하면 기본적으로 Ubuntu 환경으로 들어온다. Oh my zsh https://github.com/ohmyzsh/ohmyzsh zsh의 설정 관리를 위한 프레임워크인 oh-my-zsh를 설치한다. 이를 위해 먼저 zsh를 설치한다. 1sudo apt install zsh Oh my zsh를 설치한다. 1sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot; 콘솔이 바뀐 것을 확인할 수 있다. Powerlevel10k https://github.com/romkatv/powerlevel10k powerlevel10k는 zsh의 테마를 변경할 수 있다. 1sudo git clone --depth=1 https://github.com/romkatv/powerlevel10k.git ${ZSH_CUSTOM:-$HOME/.oh-my-zsh/custom}/themes/powerlevel10k .zshrc 파일을 수정한다. 이를 위해 .zshrc 파일을 열어야 한다.만약 code ~/.zshrc가 동작하지 않는다면 vi를 이용한다. 12code ~/.zshrcvi ~/.zshrc ZSH_THEME를 수정한다. 1ZSH_THEME=&quot;robbyrussell&quot; -&gt; ZSH_THEME=&quot;powerlevel10k/powerlevel10k&quot; :wq를 이용해 수정하고, 터미널을 재시작하면 다음과 같은 화면이 뜬다. 이는 powerlevel10k의 기본 설정이며, 처음 실행에서 나타난다. 이를 보면 사각형이 잘 나오지 않는 것을 볼 수가 있는데, 이는 폰트의 문제이다. powerlevel10k의 사이트에 들어가면 4개의 폰트가 있는데, 해당 4개 모두 다운로드 후 설치한다. Windows Terminal의 setting.json setting.json의 “defaults”에서 “FontFace”를 “MesloLGS NF”로 수정한다. 12345678910111213&quot;profiles&quot;: { &quot;defaults&quot;: { // Put settings here that you want to apply to all profiles. &quot;fontFace&quot;: &quot;MesloLGS NF&quot; }, &quot;list&quot;: [ { // Make changes here to the powershell.exe profile. &quot;guid&quot;: &quot;{61c54bbd-c2c6-5271-96e7-009a87ff44bf}&quot;, &quot;name&quot;: &quot;Windows PowerShell&quot;, &quot;commandline&quot;: &quot;powershell.exe&quot;, &quot;hidden&quot;: false }, Visual studio code 설정 File -&gt; Preferences -&gt; Settings 검색창에 integrated를 검색하면 Font Family가 있다 이를 “MesloLGS NF”로 수정한다. 콘솔 재시작 콘솔을 재시작하면 다음과 같이 정상적으로 나오는 것을 볼 수 있다. 원하는대로 설정을 모두 마치고 나면 다음과 같은 화면이 출력된다. ls color 변경 code ~/.zshrc 파일 맨 마지막 줄에 다음을 추가한다. 1LS_COLORS=&quot;ow=01;36;40&quot; &amp;&amp; export LS_COLOR powerlevel10k 재설정1p10k configure Windows에서 설치한 Ubuntu 상세 구조 분석 실제로 구현되는 구조는 아니라 가상화로 구현되는 구조이다. cmd, powershell, 그리고 Windows Terminal과 같은 window 환경에서 동작하는 터미널의 경우 C 드라이브가 루트이며, 이 이상으로 올라갈 수 없다. 그러나 가상화로 구현된 Ubuntu, 그리고 Ubuntu 위에서 동작하는 zsh 터미널은 루트 디렉터리까지 올라갈 수 있으며, Windows 환경은 mnt 디렉터리를 통해 들어간다. home 디렉터리의 user는 Ubuntu에서 생성한 사용자이며, 이는 user 사용자의 환경이다.","link":"/2022/01/27/Windows-%ED%99%98%EA%B2%BD%EC%97%90%EC%84%9C-Ubuntu-%EC%84%A4%EC%B9%98%ED%95%98%EA%B8%B0/"},{"title":"VSCode Remote-SSH 프로세스에서 없는 파이프에 쓰려고 했습니다 에러","text":"Rempte-SSH Remote-SSh는 VSCode의 확장 기능 중 하나로 SSH 접속을 위한 도구 Ctrl + Shift + p를 이용해 접속 가능 프로세스에서 없는 파이프에 쓰려고 했습니다 에러 동일한 IP를 이용해 전에 접속을 하였지만, 다른 기기나 환경이라면 다음과 같은 에러 발생 12345678910111213141516[20:37:25.006] Log Level: 2[20:37:25.012] remote-ssh@0.66.1[20:37:25.012] win32 x64...&gt; 프로세스에서 없는 파이프에 쓰려고 했습니다.[20:37:27.428] &quot;install&quot; terminal command done[20:37:27.430] Install terminal quit with output: 프로세스에서 없는 파이프에 쓰려고 했습니다.[20:37:27.431] Received install output: 프로세스에서 없는 파이프에 쓰려고 했습니다.[20:37:27.436] Failed to parse remote port from server output[20:37:27.440] Resolver error: Error:... 해결 방법 {user}/.ssh/known_hosts 해당 파일을 열면 다음과 같은 내용을 볼 수 있음 123192.168.1.106 ~192.168.1.105 ~192.168.0.22 ~ 방금 접속을 시도한 IP 주소를 지우고 다음과 같이 저장을 수행 12192.168.1.106 ~192.168.1.105 ~ Remote-SSH를 이용해 재접속 실시","link":"/2021/12/07/VSCode-Remote-SSH-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%97%90%EC%84%9C-%EC%97%86%EB%8A%94-%ED%8C%8C%EC%9D%B4%ED%94%84%EC%97%90-%EC%93%B0%EB%A0%A4%EA%B3%A0-%ED%96%88%EC%8A%B5%EB%8B%88%EB%8B%A4-%EC%97%90%EB%9F%AC/"},{"title":"goormide에 code-server 설치하기","text":"개발환경 설정 취지 아이패드를 구입하고 아이패드를 이용해 코딩을 하려고 했지만, 마땅한 어플이 존재하지 않는다. 따라서, 웹 브라우저로 간단하게 접속할 수 있는 code-server를 구축하여 아이패드를 이용해 코딩할 수 있는 환경을 구축하고자 한다. Code-server란? Visual studio code를 Node.js를 통해 Server에 올리고, 이를 웹 브라우저를 이용해 접속하는 프로그램이다. 이를 위해 접속할 환경에 code-server가 설치되어 있어야 하며, 이는 실행되어 있어야 한다. 외부에서 접속하기 위해 포트포워딩을 하여야 한다. https://vscode.dev/와의 차이점 https://vscode.dev/는 웹 브라우저를 이용해 로컬 환경에서 코딩을 하는 사이트이다. 이는 로컬 환경의 파일을 열어볼 수 없는, 또는 열기 힘든 아이패드와 같은 환경에서 적절하지 못하다. 그에 비해 code-server는 외부의 파일 디렉터리에 원격으로 접속하여 프로그래밍을 하므로, 아이패드의 제한적인 환경에 구애받지 않는다. goormide 설명 goormide는 웹 기반 클라우드 코딩 서비스이다. 컨테이너 기반의 개발 환경을 구축해준다. goormide를 이용한 code-server 설치 goormide의 컨테이너를 생성하며, 공개 범위는 public, 소프트웨어 스택은 node.js를 선택한다. 다음과 같은 명령어를 입력하여 code-server를 설치한다. 1vim ~/.config/code-server/config.yaml code-server를 실행하여 설정 파일을 생성한다. 123456789root@goorm:/workspace/code-server# code-server[2022-01-27T02:49:15.646Z] info Wrote default config file to ~/.config/code-server/config.yaml[2022-01-27T02:49:18.522Z] info code-server 4.0.1 735c6da829535969ff7193c79379299e4a1cb9bc[2022-01-27T02:49:18.525Z] info Using user-data-dir ~/.local/share/code-server[2022-01-27T02:49:18.555Z] info Using config file ~/.config/code-server/config.yaml[2022-01-27T02:49:18.555Z] info HTTP server listening on http://127.0.0.1:8080/[2022-01-27T02:49:18.556Z] info - Authentication is enabled[2022-01-27T02:49:18.619Z] info - Using password from ~/.config/code-server/config.yaml[2022-01-27T02:49:18.619Z] info - Not serving HTTPS ctrl+c로 종료 후 설정 파일을 연다. 1vi ~/.config/code-server/config.yaml 주소를 0.0.0.0:8080으로 수정한다. 비밀번호를 원하는 비밀번호로 수정한다. :wq 명령을 이용해 저장한다. code-server를 재실행한다. 1code-server 포트포워딩 goormide는 포트포워딩을 제공한다. 오른쪽 상단의 미리보기에서 실행 URL과 포트 설정을 선택한다. URL과 포트를 설정한다. 이때, 포트는 설정 파일에서 저장한 포트인 8080으로 한다. 웹브라우저를 이용해 해당 URL에 접속하면, 다음과 같은 화면이 나온다. 비밀번호를 입력한다. goormide의 디렉터리가 화면에 출력되는 것을 볼 수 있다.","link":"/2022/01/27/goormide%EC%97%90-code-server-%EC%84%A4%EC%B9%98%ED%95%98%EA%B8%B0/"},{"title":"Hello World!!!","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server -p 3000 More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2019/11/30/hello-world/"},{"title":"공인 아이피, 사설 아이피 NodeJS","text":"Node.js를 이용한 공인 아이피와 사설 아이피 확인12npm i ipnpm i request 1234567const request = require('request');const ip = require('ip');request.get({ url: 'https://api.ipify.org' }, function (_1, _2, body) { console.log('Public IP address &gt; ' + body); console.log('Virtual IP address &gt; ' + ip.address());}); API를 이용하지 않는 방법 특정 사이트에서 가져오는 데이터는 의존성을 갖는다. 따라서, request 대신 npm 모듈을 이용한다. 1npm i public-ip SyntaxError: Cannot use import statement outside a module 에러 Node.js의 모듈은 크게 commonjs와 module로 구분할 수 있다. 이는 임포트 방식이 다르며, 이를 위해 package.json에서 module로 인식할 수 있게 변경하여야 한다. 123456789{ ... &quot;dependencies&quot;: { &quot;ip&quot;: &quot;^1.1.5&quot;, &quot;public-ip&quot;: &quot;^5.0.0&quot;, &quot;request&quot;: &quot;^2.88.2&quot; }, &quot;type&quot;: &quot;module&quot;} 다음과 같이 package.json에 “type”: “module”를 추가한다. 임포트 방식 변경 이 방식으로 변경한 기존의 코드는 다음과 같다. 1234567import request from 'request';import ip from 'ip';request.get({ url: 'https://api.ipify.org' }, function (_1, _2, body) { console.log('Public IP address &gt; ' + body); console.log('Virtual IP address &gt; ' + ip.address());}); request 모듈을 사용하지 않는 방식은 다음과 같다. 12345import publicIp from 'public-ip';import ip from 'ip';console.log('Public IP address &gt; ' + (await publicIp.v4()));console.log('Virtual IP address &gt; ' + ip.address());","link":"/2021/11/14/%EA%B3%B5%EC%9D%B8-%EC%95%84%EC%9D%B4%ED%94%BC-%EC%82%AC%EC%84%A4-%EC%95%84%EC%9D%B4%ED%94%BC-NodeJS/"},{"title":"코딩테스트를 위한 기초 Javascript 문법 정리","text":"##","link":"/2021/12/02/%EC%BD%94%EB%94%A9%ED%85%8C%EC%8A%A4%ED%8A%B8%EB%A5%BC-%EC%9C%84%ED%95%9C-%EA%B8%B0%EC%B4%88-Javascript-%EB%AC%B8%EB%B2%95-%EC%A0%95%EB%A6%AC/"},{"title":"우분투 타임존 설정하기","text":"우분투 타임존 설정하기 우분투 기반의 환경에서 타임존 기본 설정이 한국으로 되어 있지 않은 경우가 있다. (예를 들어, AWS의 EC2) 타임존 설정이 맞지 않는다면, 데이터베이스의 시간 저장, git commit 시간에 오차가 발생하여 문제가 발생한다. 12root@SERVER:/# dateTue Sep 19 19:16:05 UTC 2017 tzselect를 이용해 타임존을 설정한다. 123456789101112131415root@SERVER:/# tzselectPlease identify a location so that time zone rules can be set correctly.Please select a continent, ocean, &quot;coord&quot;, or &quot;TZ&quot;.1) Africa2) Americas3) Antarctica4) Asia5) Atlantic Ocean6) Australia7) Europe8) Indian Ocean9) Pacific Ocean10) coord - I want to use geographical coordinates.11) TZ - I want to specify the time zone using the Posix TZ format.#? 4 12345678910111213141516171819Please select a country whose clocks agree with yours.1) Afghanistan 18) Israel 35) Palestine2) Armenia 19) Japan 36) Philippines3) Azerbaijan 20) Jordan 37) Qatar4) Bahrain 21) Kazakhstan 38) Russia5) Bangladesh 22) Korea (North) 39) Saudi Arabia6) Bhutan 23) Korea (South) 40) Singapore7) Brunei 24) Kuwait 41) Sri Lanka8) Cambodia 25) Kyrgyzstan 42) Syria9) China 26) Laos 43) Taiwan10) Cyprus 27) Lebanon 44) Tajikistan11) East Timor 28) Macau 45) Thailand12) Georgia 29) Malaysia 46) Turkmenistan13) Hong Kong 30) Mongolia 47) United Arab Emirates14) India 31) Myanmar (Burma) 48) Uzbekistan15) Indonesia 32) Nepal 49) Vietnam16) Iran 33) Oman 50) Yemen17) Iraq 34) Pakistan#? 23 1234567Therefore TZ='Asia/Seoul' will be used.Local time is now: Tue Sep 19 19:21:47 KST 2017.Universal Time is now: Tue Sep 19 10:21:47 UTC 2017.Is the above information OK?1) Yes2) No#? 1 12root@SERVER:/# dateTue Sep 19 19:22:28 KST 2017 tzselect 오류 tzselect가 작동하지 않을 경우 tzdata를 설치한다. 그 전에 .profile의 맨 밑에 다음을 입력한 후 리부팅 한다. 1TZ='Asia/Seoul'; export TZ tzdata 설치 1sudo apt install tzdata","link":"/2022/01/27/%EC%9A%B0%EB%B6%84%ED%88%AC-%ED%83%80%EC%9E%84%EC%A1%B4-%EC%84%A4%EC%A0%95%ED%95%98%EA%B8%B0/"},{"title":"텔레그램 봇 시작하기","text":"텔레그램을 이용하여 간단한 봇 구현 텔레그램에서 BotFather 검색 봇 생성 /newbot 이미 생성된 봇 이름은 선택할 수 없으며, bot으로 끝나는 이름을 선택한다. HTTP API를 이용하여 연결하므로 이를 기록해둔다. 봇 입장 생성한 봇 이름을 검색하여 생성한 봇과 채팅을 할 수 있다. 현재는 서버를 생성하지 않았으므로, 아무 작업을 하지 않는다. 텔레그램 봇 서버 구축 Node.js를 이용하여 봇 서버를 구축한다. https://www.npmjs.com/package/node-telegram-bot-api 프로젝트를 생성한 후 다음과 같이 터미널에 입력한다. 1npm init package.json에 다음과 같은 종속성을 추가한다. 1234567{ &quot;dependencies&quot;: { &quot;ip&quot;: &quot;^1.1.5&quot;, &quot;node-telegram-bot-api&quot;: &quot;^0.54.0&quot;, &quot;request&quot;: &quot;^2.88.2&quot; }} telegram.js 파일을 생성한 후 다음과 같은 코드를 작성한다. 1234567891011121314151617181920212223const request = require('request');const ip = require('ip');const TelegramBot = require('node-telegram-bot-api');const fs = require('fs');const token = fs.readFileSync(__dirname + '/token.txt', 'utf8');const bot = new TelegramBot(token, { polling: true });bot.onText(/\\/echo (.+)/, (msg, match) =&gt; { const chatId = msg.chat.id; const resp = match[1]; bot.sendMessage(chatId, resp);});bot.on('message', (msg) =&gt; { const chatId = msg.chat.id; console.log(chatId); request.get({ url: 'https://api.ipify.org' }, function (_1, _2, body) { bot.sendMessage(chatId, 'Public IP address &gt; ' + body + '\\nVirtual IP address &gt; ' + ip.address()); });}); token.txt 파일을 생성한 후 생성한 텔레그램 봇의 HTTP API를 입력한다. 코드 상에서 작성해도 문제없지만, 보안을 위한 작업이다. 봇 서버를 실행한다. 1node telegram.js 텔레그램 봇 테스트 봇에게 채팅을 하면, 텔레그램 봇이 돌아가고 있는 서버의 주소를 반환한다.","link":"/2021/11/24/%ED%85%94%EB%A0%88%EA%B7%B8%EB%9E%A8-%EB%B4%87-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/"}],"tags":[{"name":"API Gateway","slug":"API-Gateway","link":"/tags/API-Gateway/"},{"name":"AWS","slug":"AWS","link":"/tags/AWS/"},{"name":"Windows","slug":"Windows","link":"/tags/Windows/"},{"name":"DynamoDB","slug":"DynamoDB","link":"/tags/DynamoDB/"},{"name":"docker","slug":"docker","link":"/tags/docker/"},{"name":"git Blog","slug":"git-Blog","link":"/tags/git-Blog/"},{"name":"Git","slug":"Git","link":"/tags/Git/"},{"name":"EC2","slug":"EC2","link":"/tags/EC2/"},{"name":"HTTPS","slug":"HTTPS","link":"/tags/HTTPS/"},{"name":"Node.js","slug":"Node-js","link":"/tags/Node-js/"},{"name":"javascript","slug":"javascript","link":"/tags/javascript/"},{"name":"Promise","slug":"Promise","link":"/tags/Promise/"},{"name":"Asynchronous","slug":"Asynchronous","link":"/tags/Asynchronous/"},{"name":"lightsail","slug":"lightsail","link":"/tags/lightsail/"},{"name":"Lambda","slug":"Lambda","link":"/tags/Lambda/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"Raspberry Pi","slug":"Raspberry-Pi","link":"/tags/Raspberry-Pi/"},{"name":"gpio","slug":"gpio","link":"/tags/gpio/"},{"name":"mysql","slug":"mysql","link":"/tags/mysql/"},{"name":"Telegram","slug":"Telegram","link":"/tags/Telegram/"},{"name":"Code-server","slug":"Code-server","link":"/tags/Code-server/"},{"name":"MPU9250","slug":"MPU9250","link":"/tags/MPU9250/"},{"name":"I2C","slug":"I2C","link":"/tags/I2C/"},{"name":"S3","slug":"S3","link":"/tags/S3/"},{"name":"Ubuntu","slug":"Ubuntu","link":"/tags/Ubuntu/"},{"name":"VSCode","slug":"VSCode","link":"/tags/VSCode/"},{"name":"Error","slug":"Error","link":"/tags/Error/"},{"name":"Remote-SSH","slug":"Remote-SSH","link":"/tags/Remote-SSH/"},{"name":"Coding test","slug":"Coding-test","link":"/tags/Coding-test/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"}],"categories":[{"name":"AWS","slug":"AWS","link":"/categories/AWS/"},{"name":"Windows","slug":"Windows","link":"/categories/Windows/"},{"name":"docker","slug":"docker","link":"/categories/docker/"},{"name":"Git Blog","slug":"Git-Blog","link":"/categories/Git-Blog/"},{"name":"Git","slug":"Git","link":"/categories/Git/"},{"name":"HTTPS","slug":"HTTPS","link":"/categories/HTTPS/"},{"name":"Javascript","slug":"Javascript","link":"/categories/Javascript/"},{"name":"Python","slug":"Python","link":"/categories/Python/"},{"name":"Raspberry Pi","slug":"Raspberry-Pi","link":"/categories/Raspberry-Pi/"},{"name":"Asynchronous","slug":"Javascript/Asynchronous","link":"/categories/Javascript/Asynchronous/"},{"name":"Promise","slug":"Javascript/Promise","link":"/categories/Javascript/Promise/"},{"name":"Ubuntu","slug":"Ubuntu","link":"/categories/Ubuntu/"},{"name":"Ubuntu","slug":"Windows/Ubuntu","link":"/categories/Windows/Ubuntu/"},{"name":"VSCode","slug":"VSCode","link":"/categories/VSCode/"},{"name":"Development","slug":"Development","link":"/categories/Development/"},{"name":"Node.js","slug":"Node-js","link":"/categories/Node-js/"},{"name":"Coding test","slug":"Coding-test","link":"/categories/Coding-test/"},{"name":"Linux","slug":"Linux","link":"/categories/Linux/"},{"name":"Python","slug":"Raspberry-Pi/Python","link":"/categories/Raspberry-Pi/Python/"},{"name":"Node.js","slug":"Raspberry-Pi/Node-js","link":"/categories/Raspberry-Pi/Node-js/"},{"name":"docker","slug":"Raspberry-Pi/docker","link":"/categories/Raspberry-Pi/docker/"},{"name":"Error","slug":"VSCode/Error","link":"/categories/VSCode/Error/"},{"name":"Code-server","slug":"Development/Code-server","link":"/categories/Development/Code-server/"},{"name":"Javascript","slug":"Coding-test/Javascript","link":"/categories/Coding-test/Javascript/"},{"name":"Ubuntu","slug":"Linux/Ubuntu","link":"/categories/Linux/Ubuntu/"}]}