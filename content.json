{"pages":[{"title":"","text":"body { background-color: #95c2de; } .mainbox { background-color: #95c2de; margin: auto; height: 600px; width: 600px; position: relative; } .err { color: #ffffff; font-family: 'Nunito Sans', sans-serif; font-size: 11rem; position:absolute; left: 20%; top: 8%; } .far { position: absolute; font-size: 8.5rem; left: 42%; top: 15%; color: #ffffff; } .err2 { color: #ffffff; font-family: 'Nunito Sans', sans-serif; font-size: 11rem; position:absolute; left: 68%; top: 8%; } .msg { text-align: center; font-family: 'Nunito Sans', sans-serif; font-size: 1.6rem; position:absolute; left: 16%; top: 45%; width: 75%; } a { text-decoration: none; color: white; } a:hover { text-decoration: underline; } 4 4 블로그에 없는 URL입니다. 메인화면으로 갑니다.","link":"/404.html"},{"title":"about","text":"","link":"/about/index.html"}],"posts":[{"title":"AWS API 게이트웨이 시작하기","text":"API 게이트웨이 API 게이트웨이는 HTTP 프로토콜을 이용하여 API를 개발자가 손쉽게 구축할 수 있는 완전 관리형 서비스이다. 실습 요약 API 게이트웨이용 람다 함수를 생성한다.A. 람다 함수 생성(람다 함수 이름 : lambda_for_apigateway_get)B. 람다 함수 실행 역할 생성(람다 함수 역할 이름 : role_for_apigateway) API 게이트웨이용 람다 이벤트를 구성한다. 람다 함수 소스코드를 작성한다. 다이나모 DB 서비스 실행 권한을 위한 IAM을 생성한다.A. 정책 생성 및 검토(정책 이름 : policy_dynamodb_crud)B. 역할 생성(역할 이름 : role_for_apigateway_get) 다이나모 DB를 생성한다. 람다 함수를 수정한다. API Gateway 테스트 및 다이나모 DB GET 확인한다. 실습 AWS 콘솔에서 람다 함수를 선택하고, 함수 생성을 선택 함수 이름을 lambda_for_apigateway_get로 지정 권한은 AWS 정책 템플릿에서 새 역할 생성을 선택 역할 이름은 role_for_apigateway 정책 템플릿은 Lambda@Edge를 선택 람다 함수 에디터 부분의 코드를 다음과 같이 입력 1234567exports.handler = async (event) =&gt; { const response = { statusCode: 200, body: JSON.stringify(event.queryStringParameters), }; return response;}; 추가 트리거를 선택한 후 API 게이트웨이를 선택 API 생성을 선택한 후 보안을 열기로 선택 추기를 선택하면 다음과 같이 화면이 뜸 API 게이트웨이가 추가되면 기존에는 없던 리소스 경로가 뜸 API 엔드포인트라는 항목과 URL이 나타나는데 함수를 실행시키기 위해 접속해야 하는 주소 ?”key”=”value”&amp;”key”=”value” 형태로 URL 뒤에 붙혀서 URI를 만들어 준다 화면에 GET으로 보내준 파라매터가 뜨는 것을 확인할 수 있음 다이나모DB에 대한 권한을 주기 위해 권한에 들어감 role_for_apigateway_get을 선택하면 다음과 같은 화면이 뜸 정책 연결을 선택 정책 생성을 선택 서비스는 DynamoDB, 리소스는 모든 리소스, 작업은 수동작업으로 모든 DynamoDB 작업을 선택 정책 검토를 선택 정책 이름으로 policy_dynamodb_crud를 입력 정책 생성을 선택 검색에서 이전에 만들었던 role_for_apigateway_get을 입력한 후 표시되는 역할을 선택 요약정보가 뜨며, 정책 연결을 선택 이전에 만든 정책 이름을 입력하여 검색 체크 박스 선택 후 하단 정책 연결 버튼을 선택 policy_dynamodb_crud역할에 role_forapigateway 정책이 성공적으로 연결 이제 람다 함수가 다이나모 DB에 접근 가능함 다이나모DB에서 테이블 만들기를 선택하며, 테이블 이름은 dynamo_apigateway_query를 입력한 후, 기본 키는 id를 입력 테이블 생성 람다 함수로 돌아와서 함수 코드를 다음과 같이 입력 123456789101112131415161718192021222324252627282930313233343536373839404142//aws-sdk를 불러옵니다.const AWS = require('aws-sdk');//다이나모디비 클라이언트를 초기화합니다.const dynamodb = new AWS.DynamoDB.DocumentClient();exports.handler = async (event) =&gt; { //리턴할 값을 선언합니다. let response; //queryStringParameters즉 GET값들이 들어오는지 들어온다면 id가 있는지 체크합니다. if (!event.queryStringParameters || !event.queryStringParameters.id) { response = { statusCode: 400, body: JSON.stringify('id가 없습니다.'), }; return response; } else { let params = { Item: { id: event.queryStringParameters.id, data: event.queryStringParameters, }, TableName: 'dynamo_apigateway_query', }; await dynamodb .put(params) .promise() .catch((e) =&gt; { response = { statusCode: 500, body: JSON.stringify('에러가 발생하였습니다:' + e), }; return response; }); response = { statusCode: 200, body: JSON.stringify('데이터가 성공적으로 저장되었습니다..'), }; return response; }}; queryStringParameter를 인자로 받아 다이나모 DB에 저장하고 GET에이터나 id 값이 없다면 400, 저장하는데 문제가 발생한다면 500, 성공적으로 데이터를 넣었다면 200을 반환 파라매터가 없는경우 파라매터를 정상적을 넣는 경우 다이나오 DB에 들어가보면 데이터가 정상적으로 들어가 있음을 확인할 수 있음 1234{ &quot;text&quot;: &quot;hello world&quot;, &quot;number&quot;: &quot;+821012345678&quot;}","link":"/2020/11/03/AWS-API-%EA%B2%8C%EC%9D%B4%ED%8A%B8%EC%9B%A8%EC%9D%B4-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/"},{"title":"AWS EC2를 활용한 Node.js 서버 구축","text":"실습 요약 EC2, Ubuntu를 이용하여 인스턴스를 생성한다 Node.js를 설치하며, MariaDB를 설치한다. 간단한 예제를 통하여 환경을 테스트 한다. EC2의 새 인스턴스 생성을 통하여 다음과 같은 화면이 나온다. Ubuntu Server 20.04 LTS를 선택한다. 인스턴스 유형은 프리티어이므로 t2.micro를 선택한다. 인스턴스 세부 정보 구성은 건드리지 않는다. 스토리지 추가에서도 아무것도 선택하지 않는다. 태그 추가에서는 키에 Name을 입력하고 값에 TestServer를 입력한다. 이는 추후 인스턴스의 이름이 된다. 보안 그룹 구성에서는 기본으로 SSH가 있을 것이다. HTTP와 HTTPS를 추가하며 소스는 모두가 접근할 수 있도록 0.0.0.0/0을 선택한다. 인스턴스 시작 검토는 현재까지 설정한 정보를 볼 수 있다. 문제가 없다면 시작하기를 선택한다. 키를 발급 받는다. 기존에 가지고 있는 키를 선택해도 되며, 새로운 키를 발급 받아도 된다. 해당 키를 재발급이 불가능 하므로 반드시 저장을 해야한다. 인스턴스가 실행되면 연결 버튼을 통하여 다음의 정보를 얻을 수 있다. 이때 ec2-3-87-0-78.compute-1.amazonaws.com는 우리의 인스턴스의 퍼블릭 Ip의 역할을 한다. 인스턴스 요약을 통하여 5.87.0.78의 ip도 얻을 수 있는데, 이는 위의 ec2-3-87-0-78.compute-1.amazonaws.com와 같다. Putty를 통해 접속을 시도한다. 이때 Connection -&gt; SSH -&gt; Auth에 방금 발급 받은 키를 넣어줘야 한다. 주의할 점은 putty에서는 발급받은 pem이 아니라 ppk로 변환을 해줘야 하는데, 이 부분은 추후에 포스팅 한다. Putty의 Session에 Host Name에 방금 얻은 ec2-3-87-0-78.compute-1.amazonaws.com를 입력한다. 또한, ubuntu 계정으로 접근을 위해 앞에 ubuntu@를 붙인다. 1ubuntu@ec2-3-87-0-78.compute-1.amazonaws.com 연결을 누르게 되면 ubuntu 계정으로 로그인된 것을 볼 수 있다. Node.js 설치와 MariaDB는 ec2의 ubuntu에서 좀 다르게 설치된다. Node.js 설치법 https://docs.aws.amazon.com/ko_kr/sdk-for-javascript/v2/developer-guide/setting-up-node-on-ec2-instance.html 노드의 설치 방법은 위 사이트에 나와있다. 아래의 코드를 한줄씩 입력한다. 1234567curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.34.0/install.sh | bash. ~/.nvm/nvm.shnvm install nodenode -e &quot;console.log('Running Node.js ' + process.version)&quot; 위의 명령어를 통해 Node.js가 설치되고, 버전을 확인할 수 있다. Node.js가 설치된 후 다음의 명령어를 통해 예제 코드 실행을 위한 모듈을 설치한다. 12345678npm install ejsnpm install jadenp install expressnpm install cookie-parsernpm install body-parsernpm install express-sessionnpm install mysqlnpm install sync-mysql 한줄씩 입력하여 모듈을 설치한다. MariaDB 설치 https://downloads.mariadb.org/mariadb/repositories MariaDB를 설치하는 코드는 다음과 같다. 1234567891011sudo apt-get install software-properties-commonsudo apt-key adv --fetch-keys 'https://mariadb.org/mariadb_release_signing_key.asc'sudo add-apt-repository 'deb [arch=amd64,arm64,ppc64el] https://ftp.harukasan.org/mariadb/repo/10.5/ubuntu focal main'sudo apt updatesudo apt install mariadb-servermysql -V 위 코드를 통해 MariaDB가 설치되고 버전을 확인할 수 있다. 접속을 위해 MariaDB의 환경 설정을 해야한다. 12345cd /etc/mysql/mariadb.conf.dsudo cp 50-server.cnf server.cnf.backupsudo vi 50-server.cnf bind-addess = 127.0.0.1을 주석 처리한다. bind-addess = 127.0.0.1 -&gt; #bind-addess = 127.0.0.1 mariaDB를 재시작 시키며, 접속을 위한 비밀번호를 설정 123sudo systemctl restart mariadb.servicesudo mysqladmin -u root password 'gachon654321' 123456789sudo mysql -u root -pEnter password: *set password for root@localhost = password('gachon654321');use mysql;flush privileges;exitmysql -u root -pgachon654321 예제 페이지를 위해 테이블을 하나 만든다 12create database mydb;create table member ( name varchar(10), uid varchar(10), pass varchar(10)); Atom으로 접속을 한다. 이때 자세한 환경 세팅은 다음 포스팅에서 실시한다. ftp-remote을 통하여 .ftpconfig 파일을 다음과 같이 작성한다. 12345678910111213141516171819202122{ &quot;protocol&quot;: &quot;sftp&quot;, &quot;host&quot;: &quot;ec2-3-87-0-78.compute-1.amazonaws.com&quot;, &quot;port&quot;: 22, &quot;user&quot;: &quot;ubuntu&quot;, &quot;promptForPass&quot;: false, &quot;remote&quot;: &quot;/home/ubuntu&quot;, &quot;local&quot;: &quot;&quot;, &quot;agent&quot;: &quot;&quot;, &quot;privatekey&quot;: &quot;C:/users/ghdrl/Desktop/MyFiles/AwsKey/aws_password.pem&quot;, &quot;passphrase&quot;: &quot;&quot;, &quot;hosthash&quot;: &quot;&quot;, &quot;ignorehost&quot;: true, &quot;connTimeout&quot;: 10000, &quot;keepalive&quot;: 10000, &quot;keyboardInteractive&quot;: false, &quot;keyboardInteractiveForPass&quot;: false, &quot;remoteCommand&quot;: &quot;&quot;, &quot;remoteShell&quot;: &quot;&quot;, &quot;watch&quot;: [], &quot;watchTimeout&quot;: 500} 소스 코드 작성 예제를 돌려보기 위해 소스 코드를 다음과 같이 작성한다. mydbsvr.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960const fs = require('fs');const ejs = require('ejs');const mysql = require('mysql');const express = require('express');const bodyParser = require('body-parser');// MySQL DB 연결const client = mysql.createConnection({ host: 'localhost', // DB서버 IP주소 port: 3306, // DB서버 Port주소 user: 'root', // DB접속 아이디 password: 'gachon654321', // DB암호 database: 'mydb', //사용할 DB명});// 서버를 생성합니다.const app = express();app.use( bodyParser.urlencoded({ extended: false, }));// 서버를 실행합니다.app.listen(65001, function () { console.log('server running at http://127.0.0.1:65001');});app.get('/insert', (request, response) =&gt; { fs.readFile('9-insert.html', 'utf8', (error, data) =&gt; { //회원가입화면 response.send(data); // 회원가입 화면전송 });});app.get('/members', (request, response) =&gt; { fs.readFile('9-list.ejs', 'utf8', (error, data) =&gt; { // List화면 // 데이터베이스 쿼리를 실행합니다. client.query('SELECT * FROM member', (error, results) =&gt; { // 응답합니다. response.send( ejs.render(data, { data: results, // 회원조회 결과화면 }) ); }); });});app.post('/insert', function (request, response) { // 변수를 선언합니다. var body = request.body; console.log(body.name); console.log(body.uid); console.log(body.pass); // 데이터베이스 쿼리를 실행합니다. client.query('INSERT INTO member (name, uid, pass) VALUES (?, ?, ?)', [body.name, body.uid, body.pass], () =&gt; { console.log('Insertion into DB was completed !'); response.end(); });}); 9-insert.html 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;회원가입&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;회원가입&lt;/h1&gt; &lt;hr /&gt; &lt;form method=&quot;post&quot;&gt; &lt;fieldset&gt; &lt;legend&gt;회원가입&lt;/legend&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;&lt;label&gt;이름&lt;/label&gt;&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;name&quot; /&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;label&gt;사용자id&lt;/label&gt;&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;uid&quot; /&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;label&gt;비밀번호&lt;/label&gt;&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;password&quot; name=&quot;pass&quot; /&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;input type=&quot;submit&quot; value = &quot;가입&quot; /&gt; &lt;/fieldset&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 9-list.ejs 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;List Page&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;List Page&lt;/h1&gt; &lt;hr /&gt; &lt;table width=&quot;100%&quot; border=&quot;1&quot;&gt; &lt;tr&gt; &lt;th&gt;Name&lt;/th&gt; &lt;th&gt;Model Number&lt;/th&gt; &lt;th&gt;Series&lt;/th&gt; &lt;/tr&gt; &lt;% data.forEach(function (item, index) { %&gt; &lt;tr&gt; &lt;td&gt;&lt;%= item.name %&gt;&lt;/td&gt; &lt;td&gt;&lt;%= item.uid %&gt;&lt;/td&gt; &lt;td&gt;&lt;%= item.pass %&gt;&lt;/td&gt; &lt;/tr&gt; &lt;% }); %&gt; &lt;/table&gt; &lt;/body&gt;&lt;/html&gt; Node mydbsvr.js 명령을 통하여 예제 페이지를 실행한다. 3.87.0.78:65001/insert 그러나 접속을 하더라도 페이지가 제대로 뜨지 않는 것을 확인할 수 있다. 이는 Ec2의 보안 설정에서 포트 65001을 허용하지 않았기 때문이다. 해당 인스턴스의 보안그룹을 들어가면 인바운드 규칙을 볼 수 있다. 인바운드 규칙 편집을 선택한다. 유형을 사용자 지정 TCP로 하며 포트 범위를 65001로 한다. 그 후 0.0.0.0/0을 선택한 후 저장을 누른다. 같은 URL로 접속하면 정상적으로 뜨는 것을 확인할 수 있다. 입력 후 /members로 들어가게 되면 정상적으로 출력되는 것으 확인할 수 있다. DB에 접속해보면 입력한 데이터가 정상적으로 저장되어 있는 것을 확인할 수 있다.","link":"/2020/11/30/AWS-EC2%EB%A5%BC-%ED%99%9C%EC%9A%A9%ED%95%9C-Node-js-%EC%84%9C%EB%B2%84-%EA%B5%AC%EC%B6%95/"},{"title":"AWS Lambda 시작하기","text":"AWS Lambda 함수 기반 문자 알림 서비스를 구축해본다. 구축 과정 SNS 서비스 실행 권한을 위한 IAM 정책 설정A. 정책 생성 및 검토(정책 이름 policy_for_publising_SNS)B. 역할 생성(역할 이름 role_for_sns_sending) SNS 람다 함수 만들기A. 람다 함수 생성(람다 함수 이름 : lambda_for_sns)B. 람다 함수 실행 역할 생성(람다 역할 이름 : role_for_sns_sending) SNS 람다 이벤트 구성A. 람다 함수 이벤트 이름(eventForSendingsSNS)B. 람다 함수 소스코드 작성 SNS 람다 함수 테스트 AIM 대시 보드에서 죄측 정책 메뉴를 클릭한 후 정책 생성을 선탣한다. 서비스 선택에서 SNS 입력 후 필터링 된 SNS를 선택한다. 문자 보내기는 사용자에게 알림 서비스를 생성하는 것이므로 액세스 레벨 “쓰기”에 해당한다. 리소스는 모든 리소스를 선택한다. 요청 조건은 기본 설정으로 하고 정책 검토를 클릭한다. 정책 이름은 policy_for_publising_SNS로 한 후 정책 생성을 클릭한다. 정책과 연결해 줄 역할을 만든다. 역할 만들기를 선택한다. 신뢰할 수 있는 유형의 개체로 AWS 서비스를 선택한다. 사용 사례 선택은 Lambda를 선택한다. 권한 정책 연결에서 policy_for_publising_SNS를 선택한다. 태그는 없으므로 넘어간다. 역할 이름에 role_for_sns_sending를 입력하고 역할 만들기를 선택한다. AWS console에서 Lambda를 클릭한다. 람다 함수 대시보드에서 함수 생성을 선택한다. 함수 이름은 lambda_for_sns로 입력한다. 권한은 기존 역할 사용을 선택하며, role_for_sns_sending을 선택한다. 함수 행성을 선택한다. 성공적으로 함수가 만들어진 후 이벤트 선택에서 테스트 이벤트 구성을 선택한다. 이벤트 이름은 eventForSendingsSns로 입력한 후, 코드는 다음과 같이 입력한다. 1234{ &quot;text&quot;: &quot;hello world&quot;, &quot;number&quot;: &quot;+821012345678&quot;} 함수 코드에는 다음과 같이 입력한다. 12345678910111213141516171819202122232425262728293031//AWS를 실행시키기위한 라이브러리를 가져옵니다.const AWS = require('aws-sdk');//이전과 다른부분이 있다면 context와 callback을 파라미터로 받습니다.//context에서는 현재 실행중인 람다의 메타정보를 받고//callback은 람다가 끝나는 시점 호출합니다.exports.handler = (event, context, callback) =&gt; { //위에 입력했던 json값이 event 즉 input으로 들어옵니다. //params에 Message와 PhonNumber 변수를 선언합니다. const params = { Message: event.text, PhoneNumber: event.number, }; // SNS SDK를 가져옵니다. // SNS서비스에서 메세지를 보내는것은 한정된 리전에서만 사용할 수 있기때문에 // region을 도쿄리전으로 설정해주어야합니다. 이를 위해 인자값으로 // region에 도쿄리전의 식별자인 'ap-northeast-1'을 입력합니다. const publishTextPromise = new AWS.SNS({ apiVersion: '2010-03-31', region: 'ap-northeast-1' }).publish(params).promise(); // SDK를 실행합니다. publishTextPromise .then(function (data) { //메세지가 있다면 첫번째에 null, 두번째에 메세지를 리턴합니다. callback(null, 'MessageID is ' + data.MessageId); }) .catch(function (err) { //에러가 있다면 err를 리턴합니다. callback(err); });}; 오른쪽 상단의 테스트 버튼을 클릭하면 함수가 실행된다. 입력한 텍스트가 문자로 온 것을 확인할 수 있다","link":"/2020/10/27/AWS-Lambda-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/"},{"title":"AWS Lightsail 시작하기","text":"lightsail은 플랫폼과 시작 이미지를 선택하는 것만으로 인스턴스를 바로 시작할 수 있다. 웹 사이트 블로그 단순 앱 개발 및 테스트 환경 소수의 서버로 구성된 비즈니스 소프트웨어 구축 과정 AWS Lightsail 접속 Lightsail 인스턴스 생성 Lightsail 인스턴스 확인 wordpress 사용자 설정 wordpress 관리자 설정A. 사용자명, 패스워드 설정을 위한 원격 서버 접속B. Bitnami(SSH) 접속을 통한 아이디 패스워드 생성/확인C. wordpress 관리자 페이지 접속/확인 AWS console에서 lightsail 접속 인스턴스 생성을 누른다. 첫번째는 인스턴스 이미지를 선택하는 과정이다. 플랫폼과 블루푸린트 메뉴가 존재한다. 플랫폼은 Linux/Unix를 선택하며, 블루프린트는 Wordpress를 선택한다. 시작 스크립트는 맨 처음 서버가 구성될 때 실행되는 스크립트이며, 사용자에 따라 필수적으로 설치해야 하는 소프트웨어가 있을 경우 선택한다. SSH 키 페어는 원격 서버 접속을 위해 사용한다. 인스턴스 플랜은 프리티어 가입 후 첫 달 무료 서비스를 이용하기 위해 가장 저렴한 플랜을 선택한다. 인스턴스 확인에서 고유한 이름을 선택해야하며, 인스턴스 수를 늘릴경우 추가 요금이 발생할 수 있다. 처음 인스턴스를 생성하면 실행 중 메시지가 뜨며, IP 주소가 할당된다. 해당 IP 주소를 웹 브라우저에 입력하면 기본으로 생성되는 포스트와 블로그 레이아웃을 볼 수 있다. 관리자 페이지는 퍼블릭IP/wp-damin 이다. 관리자 대시보드를 이용하기 위해서는 유저명과 비밀번호를 입력해야 한다. lightsail 대시보드에 돌아가 이름 옆의 콘솔 창을 클릭한다. CLI console창이 뜬다. 1$ cat bitnami_credentials 명령어를 입력하면 default userName과 password를 출력한다. bitnami 관리자 정보는 잘 보관되어야 한다. 관리자 정보를 통하여 관리자 대시보드로 접속 가능하다. Setting의 General에서 Site Language를 한국어로 바꾸고 저장한다. wordpress와 polly wordpress 플러그인 설정 lightsail 기반 wordpress 사용을 위한 IAM 설정A. 정책 설정B. 정책 샐성 및 검토C. 사용자 설정D. 사용자 생성E. 기존 정책과 사용자 연결F. 사용자 키 보관 wordpress 플러그인 설정 및 사용 플러그인을 보면 AWS for WordPress가 보인다. 활성화를 클릭한다. 활성화를 하면 AWS라는 매뉴가 나타난다. 클릭하면 AWS access key와 AWS secret key를 입력하라는 메시지가 출력된다. 이를 이용하기 위해서는 IAM이 필요하다. IAM의 대시보드를 들어가면 액세스 관리에 사용자와 정책이 있다. 정책 생성을 클릭한 후 시각적 편집기가 아닌 JSON을 클릭한다. 1234567891011121314151617{ &quot;Version&quot;: &quot;2012-10-17&quot;, &quot;Statement&quot;: [ { &quot;Sid&quot;: &quot;Permissions1&quot;, &quot;Effect&quot;: &quot;Allow&quot;, &quot;Action&quot;: [&quot;s3:HeadBucket&quot;, &quot;polly:SynthesizeSpeech&quot;, &quot;polly:DescribeVoices&quot;, &quot;translate:TranslateText&quot;], &quot;Resource&quot;: &quot;*&quot; }, { &quot;Sid&quot;: &quot;Permissions2&quot;, &quot;Effect&quot;: &quot;Allow&quot;, &quot;Action&quot;: [&quot;s3:ListBucket&quot;, &quot;s3:GetBucketAcl&quot;, &quot;s3:GetBucketPolicy&quot;, &quot;s3:PutObject&quot;, &quot;s3:DeleteObject&quot;, &quot;s3:CreateBucket&quot;, &quot;s3:PutObjectAcl&quot;], &quot;Resource&quot;: [&quot;arn:aws:s3:::audio_for_wordpress*&quot;, &quot;arn:aws:s3:::audio-for-wordpress*&quot;] } ]} 해당 json 파일을 복사 &amp; 붙여넣기 한다. 정책 검토를 하면 다음과 같은 화면이 나온다. 정책 명을 policy_for_wordpress_polly으로 입력한 후 정책 생성을 클릭한다. 정책이 생성되었으면, 사용자에서 사용자 추가를 클릭한다. 사용자 이름은 userForWordpress로 하며, 액세스 유형은 일반 사용자가 아닌 워드프레스라는 애플리케이션을 통해 AWS에 서비스 접근하기 때문에 ‘프로그래밍 방식 액세스’를 선택한다. 기존 정책 직접 연결을 통하여 방금 생성한 정책을 선택한다. 태그 화면은 별도의 설정을 하지 않고 넘어간다. 이상이 없다면 사용자 만들기를 클릭한다. 프로그래밍 액세스 방식은 액세스 키와 비밀 액세스 키가 발급된다. 키는 .csv 파일로 보관할 수 있다. 앞서 생성한 키를 입력한다. 변경 사항 저장을 클릭한다. Text to Speech에서 source language를 한국어로 선택하며, Enable text-to-speech support를 체크한다. 글을 클릭한 후 새로 추가를 선택한다. 제목과 내용을 입력한 후 밑에 있는 enable Text-to-speech에 체크 박스를 선택한다. 우측 상단의 공개 버튼을 클릭한다. 다음과 같이 포스트된 글을 확인할 수 있으며, 재생 버튼을 통하여 polly 서비스를 확인할 수 있다. 다운로드도 가능하다. 첫 한달 간은 무료로 사용이 가능하지만, 그 이후로는 매달 $3.5의 금액이 나가므로, 실습 후 인스턴스를 삭제한다.","link":"/2020/09/29/AWS-Lightsail-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/"},{"title":"AWS S3 시작하기","text":"S3은 어디서나 원하는 양의 데이터를 저장하고 검색할 수 있도록 구축된 객체 스토리지이다. S3은 스토리지 형식으로 객체 스토리지를 사용한다. 계층 구조가 없고, 고유식별 번호와 데이터 그리고 메타 데이터 등 최소한의 정보만을 가지고 있기 때문에 파일 개수가 많아져도 파일 스토리지에 비해 훨씬 많은 수의 파일들을 처리할 수 있다. 높은 내구성 손쉬운 혹장성 보안성과 편리성 관리 유연성 &lt;부트 스토립을 이용한 반응형 페이지 생성 실습&gt; 부트스트랩 홈페이지 접속 부트스트랩 템플릿 다운로드 S3버킷 생성 부트스트랩 템플릿 파일 업로드 정적 웹 사이트 설정 엔드포인트 URL을 통한 부트스트랩 index.html 확인 AWS 콘솔에서 스토리지 서비스인 S3을 검색한다. 다음과 같은 화면이 나오면 버킷 만들기를 클릭한다. 버킷 이름과 리전을 선택한다. 이 때, 버킷 이름은 저세계에서 유일해야 하며, 리전은 Educate 버전 사용 시 버지니아 북부로 해야 한다. 옵션은 기본으로 설정하고 넘어간다. 모든 퍼블릭 엑세스 차단을 해제한다. 차단을 해제 하여야 외부 사람이 접근 가능하다. 검토 후 문제가 없다면 버킷 만들기를 선택한다. 버킷이 새로 만들어 졌다. 새로 새성한 버킷을 선택하면 다음과 같은 화면이 출력된다. https://startbootstrap.com/ 부트스트랩을 이용한 반응형 웹 페이지를 만드려고 한다. 부트스트랩 사이트에서 마음에 드는 템플릿을 다운 받는다 다운받은 템플릿의 압축을 풀면 다음과 같은 파일들이 생겨난다. 해당 파일 전부를 업로드를 한다. 퍼블릭 권한 관리에서 “이 객체를 퍼블릭 읽기 엑세스 권한을 부여함”을 선택한다. 스토리지 클래스는 기본인 스탠다드를 선택한다. 완료 후 속성의 정적 웹 사이트 호스팅을 선택한다. 이 버킷을 사용하여 웹 사이트를 호스팅합니다를 선탣한다. 인덱스 문서는 엔드 포인트로 index.html을 입력한다. 엔드포인트는 다음과 같다. 해당 엔드 포인트를 웹 브라우저에 입력하면 해당하는 웹 페이지가 정상적으로 뜨는 것을 볼 수 있다.","link":"/2020/10/06/AWS-S3-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/"},{"title":"Blockchain 기술 학습 정리 자료2","text":"합의 모델 (합의 알고리즘) 블록체인 네트워크 기술의 핵심은 다음 블록을 게시할 사용자를 결정하는 것이다. 이는 합의 모델 중 하나를 구현하여 해결한다. 예를 들어, 무허가 블록체인 네트워크의 경우에는 일반적으로 다음 블록을 게시하기 위해 동시에 경쟁하는 많은 게시 노드가 있다. (수수료를 얻기 위해) 이러한 상황에서 사용자가 다른 사용자가 게시하려는 블록을 전파하는 이유와 여러 노드가 거의 동시에 블록을 게시할 때 충돌을 해결해야 한다. 기본적인 해결 방법 사용자가 블록체인 네트워크에 가입한다는 것은 시스템의 초기 상태에 동의하는 것이다. 이것은 사전에 구성된 유일한 블록에 기록된다. 제네시스 블록(가장 처음의 블록)이 있으며, 합의된 합의 모델에 따라 모든 블록이 그 이후에 블록에 추가(연결)된다. 그러나 모델과 관계 없이 각 블록은 유효해야 하므로, 각 블록체인 네트워크의 사용자가 독립적으로 이를 검증할 수 있다. 초기 상태와 이후 모든 블록을 검증하는 기능을 결합하여 사용자는 블록체인의 현재 상태에 대해 독립적으로 동의할 수 있다. 기본적으로 매커니즘은 더 긴 블록체인을 올바른 것으로 간주하여 채택한다. 이는 가장 많은 작업을 투입했기 때문에 신뢰성이 있다고 판단한다. 블록체인에 새 블록을 추가하려면 모든 노드가 시간이 지남에 따라 공통된 합의에 도달하여야 한다. 그러나 일시적인 의견 차이는 허용한다. (악의적인 공격자가 있는 경우에도 작동하여야 한다.) 작업 증명(PoW) 합의 모델 퍼즐을 푸는 것은 매우 어렵지만, 정답이 맞는지 확인하는 과정을 매우 쉽도록 설계되어 있다. 이를 통해 다른 모든 전체 노드는 제안된 다음 블록을 쉽게 검증할 수 있으며, 충족하지 않은 블록은 거부한다. 일반적으로 퍼즐 방법은 블록 헤더의 해시 다이제스트가 목표 값보다 작도록 요구하는 것이다. 이를 위해 nonce 값을 변경하며 해시를 계산한다. 각각의 블록은 독립적이기 때문에 유효한 블록을 수신한다면, 그 즉시 현재 작업을 버리고 새로 수신된 블록을 검증 및 구축한다. 1SHA256(“blockchain” + Nonce) = Hash Digest starting with “000000” 퍼블리싱 노드가 이 작업을 수행하고, 유효한 nonce가 포함된 블록을 네트워크의 전체 노드로 보낸다. 수신자인 전체 노드는 새 블록이 퍼즐 요구사항을 충족하였는지 확인한 다음, 블록을 자신의 블록체인 사본에 추가하고, 피어 노드로 보낸다. 이를 통해 새 블록은 네트워크 전체에 배포된다. 지분 증명(PoS) 합의 모델 사용자가 시스템에 더 많은 지분을 투자하고 있을수록 시스템이 성공하기를 원할 가능성이 높고, 시스템을 전복시키고 싶어할 가능성이 적다는 아이디어를 기반으로 한다. Stake는 블록체인 네트워크의 사용자가 시스템에 투자한 암호화폐의 양이다. 일단 스테이킹되면 암호화폐는 일반적으로 더 이상 사용할 수 없다. 블록체인 네트워크의 사용자가 새 블록을 게시할 가능성은 전체 블록체인 네트워크 스테이킹된 암호화폐의 양에 대한 지분의 비율과 관련이 있다. 작업 증명에서 볼 수 있는 리소스 집약적인 계산이 필요없다. 그러므로 채굴마다 새로운 암호화폐가 생성되는 것이 아니라, 모든 화폐는 이미 사용자에게 배포되어 있으며, 블록 발행에 대한 보상은 일반적으로 사용자가 제공한 거래 수수료를 얻는 것이다. 라운드 로빈 합의 모델 일부 허가된 블록체인 네트워크에서 사용하는 방식이다. 노드는 교대로 블록을 생성하며, 개시 노드가 블록을 게시할 수 없는 상황을 처리하기 위해 사용 가능한 노드가 블록 게시를 중단하지 않도록하는 시간 제한 기법이 포함될 수 있다. 노드 간의 신뢰가 필요하기 때문에 대부분의 암호화폐에서 사용하는 무허가 블록체인 네트워크에서는 적합하지 않다. 악성 노드가 지속적으로 노드를 추가하여 새 블록을 게시할 확률을 높일 수 있기 때문이다. 권한 증명 / 신원 증명 합의 모델 실제 ID에 대해 알려진 링크를 통해 게시 노드의 부분적인 신뢰에 의존한다. 게시 노드는 네트워크 내에서 신원이 입증되고 검증 가능해야 한다. 게시 노드가 새 블록을 게시하기 위해 ID/평판을 걸고 있다. 블록체인 네트워크 사용자는 게시 노드의 동작에 따라 게시 노드의 평판에 직접적인 영향을 준다. 게시 노드는 사용자가 동의하는 방식으로 행동하여 명성을 얻을 수 있는 것처럼, 블록체인 네트워크 사용자가 동의하지 않은 방식으로 행동하여 명성을 잃을 수도 있다. 평판이 낮을 수록 블록을 게시할 수 있는 가능성이 줄어든다. 높은 수준의 신뢰를 가진 허가된 블록채인 네트워크에만 적용할 수 있다. 경과 시간(PoET) 합의 모델 각 게시 노드는 컴퓨터 시스템 내의 보안 HW 시간 소스에서 대기 시간을 요청한다. 임의의 대기 시간을 생성하고 게시 노드는 임의의 시간을 갖고 해당 네트워크에서 유휴 상태가 된다. 게시 노드가 깨어나면 블록을 생성하고 블록체인 네트워크에 게시한다. 유휴 상태인 모든 게시 노드는 대기를 중지하고 전체 프로세스가 다시 시작한다. 이 모델은 대기 시간이 무작위로 선택되지 않은 경우 악의적인 게시 노드가 기본적으로 시스템을 지배하기 위해 최소한의 시간만 기다리므로 임의 시간이 사용되었는지 확인해야 한다. 검증되고 신뢰할 수 있는 SW는 이러한 보안 실행 환경에서 실행할 수 있으며, 외부 프로그램에 의해 변경될 수 있다. 게시 노드는 할당된 시간을 기다린 후 게시 노드가 무작위로 할당된 시간을 기다린 서명된 인증서를 요청할 수 있다. 그 다음 게시 노드는 블록과 함께 인증서를 게시한다. 원장 충돌 및 해결 방법 블록체인 네트워크에서 여러 블록이 거의 동시에 게시될 수 있다. 이로 인해 특정 시점에 서로 다른 버전의 블록체인이 존재할 수 있다. 블록체인 네트워크의 일관성을 유지하려면 이러한 문제를 신속하게 해결해야 한다. 123456• node_A creates block_n(A)with transactions #1, 2 and 3. node_A distributes it to some nodes.• node_B creates block_n(B)with transactions #1, 2 and 4. node_B distributes it to some nodes.• There is a conflict. o block_n will not be the same across the network. - block_n(A) contains transaction #3, but not transaction #4. - block_n(B) contains transaction #4, but not transaction #3. 일반적으로 대부분의 블록체인 네트워크는 다음 블록이 게시될 때까지 기다렸다가 해당 블록체인을 공식 블록체인으로 사용하여 장기 블록체인을 채택한다. 고아 블록(채택되지 못한 블록체인의 블록)에 있었던 모든 트랜잭션은 트랜잭션 풀(아직 블록에 포함되지 않은 트랜잭션이 있는 곳)으로 반환된다. 보류 중인 트랜잭션 집합은 아키텍쳐에 중앙 서버가 없기 때문에 각 노드에서 로컬로 유지 관리 된다. 블록을 덮어 쓸 가능성이 있기 때문에 관련 트랜잭션이 포함된 블록 위에 여러 개의 추가 블록이 생성될때까지 트랜잭션은 일반적으로 신뢰성 있는 것으로 수락되지 않는다. 개시된 블록 위에 빌드된 블록이 많을 수록 초기 블록을 덮어쓰지 않을 가능성이 높아진다. 매우 방대한 컴퓨팅 파워로 제네시스 블록에서부터 더 긴 체인을 만들어 기존의 체인을 지워버릴 수도 있지만, 사실상 불가능하며 이를 방지하기 위해 체크포인트를 생성하여 특정 블록 이전을 잠근다. 분기(포크, Forking) 블록체인 네트워크의 프로토콜 및 데이터 구조에 대한 변경이다. 일종의 블록체인 네트워크의 업데이트이다. 소프트 포크의 경우 업데이트되지 않은 노드와 호환되지만, 하드 포크의 경우 업데이트되지 않은 노드가 변경 후 블록을 거부하기 때문에 이전 버전과 호환되지 않는다. 소프트 포크 이전 버전과 호환되는 블록체인 구현에 대한 변경 사항이다. 소프트 포크의 예시 중 하나는 블록체인이 블록 크기를 줄이기로 결정한 경우이다. 업데이트 된 노드는 블록 크기를 조정하고 정상적으로 거래하며, 업데이트되지 않은 노드는 이러한 블록을 유효한 것으로 간주한다. 하드 포크 이전 버전과 호환되지 않는 블록체인 구현에 대한 변경이다. 모든 게시 노드는 업데이트 된 프로토콜을 사용하도록 전환해야 한다. 또한, 모든 노드는 새로 포맷된 블록을 거부하지 않도록 새 프로토콜로 업그레이드 해야 한다. 모든 활동이 새 체인으로 이동하면 두 체인이 호환되지 않기 때문에 이전 체인이 결국 사용되지 않을 수 있다. 암호화 변경 및 포크 블록체인 네트워크 내의 암호화 기술에서 결함이 발생한다면 결함의 중요성에 따라 하드 포크를 만드는 것이 유일한 해결책일 수 있다. 스마트 계약 계약 조건을 실행하는 컴퓨터화 된 거래 프로토콜이다. 스마트 계약의 일반적인 목표는 일반적인 계약 조건을 충족하고, 악의적이거나 우발적인 예외를 최소화하여 신뢰할 수 있는 중개자의 필요성을 최소화 하는 것이다. 스마트 계약은 블록체인 네트워크 내의 노드에 의해 실행된다. 블록체인 네트워크의 사용자는 스마트 계약이 제공하는 공공 기능에 데이터를 보내는 트랜잭션을 생성한다. 스마트 계약은 사용자가 제공한 데이터로 적절한 방법을 실행해서 서비스를 수행한다. 블록체인에 있는 코드는 변조 방지가 가능하므로 신뢰할 수 있는 제 3자로 사용할 수 있다. 스마트 계약은 계산을 수행하고, 정보를 저장하고, 공개적으로 노출된 상태를 반영하기 위해 속성을 노출하고, 적절한 경우 자동으로 다른 계정으로 자금을 보낸다. (반드시 재정적인 기능을 수행해야 하는 것은 아니다.) 스마트 계약은 입력이 주어지면 항상 해당 입력을 기반으로 동일한 출력을 생성한다는 점에서 결정적이여야 한다. 또한, 스마트 계약을 실행하는 모든 노드는 실행 후 얻은 새로운 상태에 동의해야 한다. 이를 달성하기 위해 스마트 계약은 직접 전달된 데이터 외의 데이터를 사용할 수 없다. (스마트 계약은 스마트 계약 내에서 웹 서비스 데이터를 가져올 수 없으며, 매개변수로 전달되어야 한다. 만약, 자체 시스템 컨텍스트 외부의 데이터를 사용하는 모든 스마트 계약은 ‘오라클’을 사용한다고 한다.) 블록체인 네트워크의 구현에서 게시 노드는 새 블록을 게시할 때 스마트 계약 코드를 동시에 실행한다. 스마트 계약이 활성화된 무허가 블록체인 네트워크의 경우에 스마트 계약에 트랜잭션을 발생하는 사용자는 코드 실행 비용을 지불해야 한다. 이 매커니즘은 스마트 계약 코드를 실행한 게시자에게 보상을 줄 뿐만이 아니라 악의적인 사용자가 배포한 다음 모든 리소스를 소비하여(무한 루프 등) 게시 노드에서 서비스 거부를 수행하는 스마트 계약에 엑세스하는 것을 방지한다. 블록체인 기술 기초 공부 참고문헌 https://arxiv.org/abs/1906.11078 https://www.youtube.com/watch?v=bBC-nXj3Ng4","link":"/2022/02/12/Blockchain-%EA%B8%B0%EC%88%A0-%ED%95%99%EC%8A%B5-%EC%A0%95%EB%A6%AC-%EC%9E%90%EB%A3%8C2/"},{"title":"Blockchain 기술 학습 정리 자료3","text":"블록체인의 한계와 오해불변성 두 개의 블록체인이 경쟁하고 있지만, 각각 고유한 꼬리 블록 시퀀스가 포함된 경우 둘 중 더 긴 쪽을 채택한다. 그러나 이것이 교체되어 사라진 블록 내의 트랜잭션이 손실된다는 의미는 아니다. 다른 블록에 포함되었거나, 보류중인 트랜잭션 풀로 반환되었을 수 있다. 무허가 블록체인의 경우 51% 공격의 결과일 수 있다. 허가된 블록체인의 경우 이를 완화할 수 있다. 비협조 게시 노드는 단순히 권한이 제거될 수 있으므로 게시 노드가 공정하게 협업하도록 강제할 수 있다. 블록체인 거버넌스(Governance)에 관련된 사용자 블록체인 네트워크의 거버넌스는 블록체인 네트워크가 지시되고 제어되는 규칙, 관행 및 프로세스를 다룬다. 블록체인 네트워크가 통제와 소유권이 없는 시스템이란 것은 사실이 아니다. 허가된 블록체인 네트워크는 일반적으로 블록체인 네트워크를 관리하는 소유자나 컨소시엄(네트워크에 가입할 수 있는 사람, 구성원이 네트워크에서 제거되는 시기, 스마트 계약에 대한 코딩 지침 등을 관리)에 의해 설정되고 운영된다. 무허가 블록체인은 종종 블록체인 네트워크의 사용자, 게시 노드 및 SW 개발자에 의해 관리한다. 디지털 너머 (Beyond the Digital) 현실 세계와 상호 작용해야 하는 경우 몇가지 문제가 있다. 예를 들어, 실제 세계의 인간이 입력한 데이터와 센서 입력 데이터를 모두 기록하는 장소가 될 수 있지만, 이 입력 데이터가 실제 세계의 이벤트를 반영하는지 여부를 결정할 방법이 없을 수 있다. 센서가 오작동하고 부정확한 데이터를 기록할 수도 있다. 인간은 잘못된 정보를 기록할 수도 있다. 예를 들어, 실제 품목을 구매하기 위해 암호화폐 거래가 발생한 경우 외부 센서나 사람의 입력에 의존하지 않고는 실제 수행 여부는 블록체인 네트워크 내에서 확인할 방법이 없다. 블록체인의 죽음 많은 게시 노드가 없으면, 악의적인 사용자가 남아 있는 소수의 게시 노드를 쉽게 제압하고 블록 수에 관계없이 다시 실행하고, 교체할 수 있으므로 신뢰성을 보장할 수 없다. 사이버 및 네트워크 기반 공격 블록체인 네트워크 내의 아직 블록에 포함되지 않은 트랜잭션은 취약하다. 트랜잭션 타임스탬프(timestamp)가 있는 블록체인 네트워크의 경우, 시간을 스푸핑하거나 주문 서비스 구성원의 시계를 조작하면, 트랜잭션에 긍정적, 부정적 영향을 미칠 수 있어, 시간과 시간 커뮤니케이션이 공격 벡터가 된다. 악의적인 사용자 충분한 지분, 처리 능력을 갖는 악성 공모자들은 악성 마이닝 작업에 여러가지를 포함할 수 있다. 특정 사용자, 노드, 국가의 거래 무시, 변경된 대체 체인을 비밀리에 생성한다음 대체 체인이 실제 체인보다 길면 제출한다. 블록을 다른 노드로 전송하는 것을 거부하여 정보 배포를 방해한다. 이를 해결하기 위해 블록체인 네트워크는 하드 포크 등을 수행할 수 있다. 리소스 사용 비트코인 블록 데이터는 175GB 이상이며, 덴마크 전체의 소비 전력 이상을 소비한다. 부적절한 블록 퍼블리싱 보상 게시를 위해 필요한 계산 리소스 증가, 암호화폐 시장의 변동 등에 대한 예상 수익이 실행에 필요한 전력 비용보다 적다면 트랜잭션 처리 지연의 위험이 있다. 그러면 노드를 게시에 기여하는 것이 점점 덜 매력적이 될 수 있다. 이러한 약화된 암호화폐는 공격에 쉽게 노출될 수 있다. 블록체인 고려 사항데이터 가시성 허가된 블록체인 네트워크는 블록체인 데이터를 공개적으로 공개하거나 공개하지 않을 수 있다. 데이터는 네트워크 내에서만 사용할 수 있다. 무허가 블록체인 네트워크는 누구나 블록체인을 검사하고 기여할 수 있다. 전체 거래 내역 일부 블록체인 네트워크는 생성에서 포함된 모든 거래에 이르기까지 디지털 자산의 전체 공개 이력을 제공한다. 가짜 데이터 입력 일부 사용자가 잘못된 데이터를 제출하여 유효한 소스의 데이터를 모방할 수 있다. 블록체인 네트워크에 들어오는 데이터를 검증하는 것은 어렵다. 변조 방지 및 변조 방지 데이터 삭제한 데이터가 삭제됨으로 표시하더라도, 데이터는 블록체인 네트워크에 계속 존재한다. 초당 트랜잭션 트랜잭션 처리 속도는 합의 모델에 크게 의존한다. 무허가 블록체인의 트랜잭션은 블록 게시 시간이 느리므로 약간의 속도 저하가 발생할 수 있다 (초, 분 단위, 비트코인의 경우 10분마다 블록을 생성한다.) 노드 다양성 블록체인 네트워크는 네트워크 참여하는 기존 노드의 집합체만큼만 강력하다. 발견되지 않은 보안 취약점의 가능성과 관련된 어느 정도의 위험은 존재한다. 이 위험은 이기종 장치 네트워크의 탈중앙화를 통해 완화되며, 이는 ‘하나의 노드와 일반화된 집합 간의 비공유 특성’으로 정의될 수 있다. 블록체인 기술 기초 공부 참고문헌 https://arxiv.org/abs/1906.11078 https://www.youtube.com/watch?v=bBC-nXj3Ng4","link":"/2022/02/12/Blockchain-%EA%B8%B0%EC%88%A0-%ED%95%99%EC%8A%B5-%EC%A0%95%EB%A6%AC-%EC%9E%90%EB%A3%8C3/"},{"title":"Chocolatey 사용하기","text":"Chocolatey Chocolatey는 Windows 소프트웨어용 명령줄 패키지 관리자 및 설치 프로그램이다. Windows powerSHell을 이용하여 소프트웨어를 다운로드 및 설치 프로세스를 단순화한다. https://chocolatey.org/ 설치 후 바로 콘솔에서 테스트가 가능하다. 만약에 choco를 사용하지 않는다면 path 설정과 같은 복잡한 과정이 필요하다. 다음과 같은 명령어로 설치한다. 1Set-ExecutionPolicy Bypass -Scope Process -Force; [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString('https://community.chocolatey.org/install.ps1')) 설치를 확인한다. 주의 사항 powershell을 관리자 버전으로 실행하여야 한다. windows terminal 설치 choco를 이용하여 Windows Terminal을 설치한다. 1choco install microsoft-windows-terminal a를 선택하여 모두 설치한다. 주의 사항 powershell을 관리자 버전으로 실행하여야 한다.","link":"/2022/01/27/Chocolatey-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0/"},{"title":"AWS DynamoDB 시작하기","text":"관계형 DB vs NO SQL 비교 관계형 DB 정형 데이터 대용량 처리 시 성능 하향 미리 정해진 스키마 존재 트랜잭션을 통해 일관성 유지 보장 조인 등의 복잡한 검색 기능 클러스터 환경에 적합하지 않음 고가의 라이센스 비용 Oracle, MySql, MSSql 등 NO SQL 정형, 반정형, 비정형 데이터 대용량 데이터 처리 지원 스키마가 없거나 변경이 자유로움 트랜잭션 지원하지 않음, 일관성이 보장 어려움(사실, 보장 하지만 관계형 DB보다는 여유롭게 보장) 단순히 데이터 검색 기능 클러스터 환경에 적합 오픈 소스 카산드라, 몽고DB 등 DynamoDB는 크게 쿼리와 스캔이라는 데이터 탐색 방법을 제공 - 쿼리 : 삽입된 기본키를 기준으로 데이터를 찾는 방법 - 스캔 : 조건 값과 맞는 데이터를 찾을 때까지 모든 데이터를 검색 구축 과정 다이나모DB 테이블 만들기A. 테이블 이름 : univStudentB. 기본키 : univ_name + univ_id 테이블 데이터 추가 데이터 수정 및 삭제 데이터 스캔과 쿼리 테이블 삭제 AWS console에서 DynamoDB를 선택 죄측 대시보드 밑의 테이블을 선택 테이블 만들기를 선택 테이블 이름은 univStudent, 기본키는 univ_name과 univ_id를 선택 후 생성 버튼을 클릭 항목 만들기 선택 내용을 입력 이 때, + 키를 누른 후 append를 클릭하여 데이터를 추가할 수 있음 저장을 클릭 데이터를 여러개 넣을 수 있으며, 형식이 전부 통일되지 않아도 됨 해당 데이터를 선택한 후 작업의 삭제를 통하여 데이터를 삭제할 수 있음 스캔은 조건값이 맞는 데이터를 찾을 때까지 모든 데이터를 탐색해서 어떤 조건 값에 맞는 데이터를 몇 개 찾아와라라는 명령어가 없다고, 모든 데이터를 찾음 필터를 통해서 조건을 줄 수 있음 쿼리는 아무런 값도 없이 검색을 누르면 에러가 발생 쿼리는 기본키를 입력하여 데이터를 검색하는 방법 글로벌 보조 인덱스는 동일한 데이터를 갖지만, 다른 키 값과 정렬키를 갖는 클론 테이블을 만들어서 테이블을 만들때와 같은 처리 용량이 필요함 인덱스를 만드는 시간은 오래 걸리지만 상태가 활성이 되면 완료된 것 스캔을 인덱스로 변경한 후 검색 시작을 선택하면 major가 포함된 데이터만 표시 됨 인덱스를 만든 테이블에서는 major을 기본키로 하기 때문에 원 테이블에서 major가 포함되지 않은 데이터는 가져올 수 가 없음 쿼리는 키 값을 찾아 데이터를 검색하는 방법 원 테이블에서 스캔으로 major을 찾는 것보다 인덱스에서 쿼리로 찾는 것이 처리용량이 더 작음 좌측 상단의 테이블 삭제를 클릭하여 안전하게 테이블을 삭제할 수 있음","link":"/2020/10/13/AWS-DynamoDB-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/"},{"title":"Blockchain 기술 학습 정리 자료1","text":"블록체인이란? 블록체인은 일반적으로 중앙의 기관 없이 구현되는 분산 방식의 변조 방지 디지털 원장이다. 기본적으로 사용자가 블록체인 네트워크에 트랜잭션을 기록할 수 있으며, 이는 네트워크의 정상적인 작동 하에서 트랜잭션이 게시되면 이는 변경할 수 없다. 블록체인은 블록으로 그룹화되어 암호화, 서명화 된 트랜잭션의 분산 디지털 원장이다. 각 블록은 유효성 검사, 합의에 따라 이전 블록과 암호화된 방식으로 연결되며, 새로운 블록은 네트워크 내의 원장 사본에 복사되고, 충돌이 발생한다면 미리 설정한 규칙에 따라 자동적으로 문제를 해결한다. 블록체인의 분류 (Permissionless VS Permissioned)Permissionless 어떠한 기관의 허가 없이 블록을 게시하는 모든 사람에게 개방된 탈중앙화 원장 플랫폼이다. 대부분이 오픈 소스 소프트웨어이며, 다운로드하려는 모든 사람이 무료로 사용할 수 있다. 누구나 블록을 게시할 수 있는 권리가 있으므로 일부 악의적인 사용자는 시스템을 전복시키기 위한 목적으로 블록을 게시하려고 시도할 수 있다. 이를 방지하기 위해 합의 시스템(예를 들어, Pos, Pow 등)을 활용한다. 합의 시스템은 일반적으로 프로토콜을 준수하는 블록 게시자(Miner, 채굴자)에게 암호화폐를 보상하여 악의적이지 않는 행동을 하도록 한다. Permissioned 사용자, 또는 노드가 일부 권한을 승인 받아야 하는 블록체인 네트워크이다. (권한의 승인을 중앙 집중형에서 받든, 분산형에서 받든) 승인된 개인만이 트랜잭션을 제출할 수 있다. 따라서 무허가 블록체인 네트워크와 같은 리소스를 과하게 소비하는 합의 방식은 필요로 하지 않는다. (이미 승인되어 신뢰할 수 있는 사용자로 보기 때문에) 참여하기 위해 본인의 신원 확인이 필요하며, 사로간의 신뢰로 네트워크가 유지된다. 블록체인의 구성 요소암호화를 위한 해시 함수 블록체인 네트워크에서 해시 함수(SHA-256 등)는 다양한 작업에 사용된다. 사용 예시 Address derivation. Creating unique identifiers. Securing the block data: a publishing node will hash the block data, creating a digest that will be stored within the block header. Securing the block header: a publishing node will hash the block header. If the blockchain network utilizes a proof of work consensus model, the publishing node will need to hash the block header with different nonce values until the puzzle requirements have been fulfilled. The current block header’s hash digest will be included within the next block’s header, where it will secure the current block header data. 암호화 nonce nonce는 한번만 사용되는 임의의 숫자이다. 데이터와 결합하여 nonce마다 다른 해시를 생성한다. 1hash(data + nonce) = digest 즉, nonce 값만 변경하면 동일한 데이터에 대해 다른 다이제스트(digest) 값을 얻을 수 있으며, 이는 작업 증명 합의 모델에서 사용한다. 거래 블록체인 네트워크의 각 블록에는 0개 이상의 트랜잭션이 포함될 수 있다. 블록체인 네트워크의 보안을 유지하기 위해 새로운 블록의 지속적인 공급은 매우 중요하다. 이를 위해 트랜잭션이 발생하지 않더라도 지속해서 블록을 생성하여야 한다. 새로운 블록을 지속적으로 공급함으로써 악의적인 사용자가 더 길고 위조된 블록체인을 제조하는 것을 방지한다. 또한, 거래의 유효성과 신뢰성을 결정하는 것은 매우 중요하다. 트랜잭션의 유효성은 프로토콜 요구 사항 및 블록체인 네트워크의 구현과 관련된 모든 형식화된 데이터 형식, 또는 스마트 계약 요구 사항을 충족하는 지 확인한다. 거래의 진위 여부는 디지털 자산의 발신자가 해당 디지털 자산에 엑세스할 수 있는지 여부를 결정하므로, 매우 중요하다. 트랜잭션은 일반적으로 발신자의 개인 키로 디지털 서명되며, 매칭되는 공개 키를 이용하여 언제든지 확인할 수 있다. 비대칭키 암호화 (공개키 암호화) 블록체인 네트워크의 사용자가 보유한 개인키로 암호화하고 공개키로 복호화하는 방식을 취할 수 있으며, 반대로 공개키로 암호화하고 개인키로 복호화하는 방식을 취할 수도 있다. 키 암호화는 트랜잭션을 공개 상태로 유지하는 동시에 트랜잭션의 무결성과 신뢰성을 확인하는 매커니즘을 제공하여 서로를 모르거나 신뢰하지 않는 사용자 간의 신뢰 관계를 가능하도록 한다. 디지털 서명 개인키를 사용하여 트랜잭션을 암호화하면 공개키를 가진 사람들은 누구나 암호를 해독할 수 있다. 공개키는 자유롭게 사용할 수 있으므로, 개인키로 트랜잭션을 암호화하면, 트랜잭션 디지털 서명자가 개인키에 엑세스할 수 있음이 증명된다. 또는, 개인키에 액세스할 수 있는 사용자만 암호를 해독할 수 있도록 공개키로 데이터를 암호화할 수도 있다. 디지털 서명 사용 예시 블록체인 네트워크에서 사용한다. 개인키는 거래를 디지털 서명하는 데에 사용한다. 공개키는 주소를 파생하는 데에 사용한다. 공개키는 개인키로 생성된 서명을 확인하는 데에 사용한다. 비대칭 키 암호화는 다른 사용자에게 화폐 등을 이전하는 사용자가 트랜잭션에 서명할 수 있는 개인키를 소유하고 있음을 증명 및 확인하는 기능을 제공한다. 주소 및 주소 파생 대부분의 블록체인 구현은 트랜잭션에서 “to” 및 “from”의 엔드포인트를 주소로 사용한다. 주소는 공개키보다 짧으며, 비밀이 아니다. 주소를 생성하는 한가지 방법은 공개키를 만들어 해시를 적용하고, 해시를 텍스트로 변환하는 방법이다. 1public key -&gt; cryptographic hash function -&gt; address 주소는 사용자가 블록체인 네트워크에서 공개 식별자 역할을 할 수 있으며, 종종 주소는 모바일에서도 쉽게 사용할수 있도록 QR코드로 변환된다. 개인키 저장 블록체인 네트워크의 사용자는 자신의 개인키를 관리하고 안전하게 저장해야 한다. 사용자가 개인키를 분실한다면 동일한 개인키를 재생성하는 것은 불가능하기 때문에 해당 키와 관련된 모든 디지털 자산이 손실된다. 반대로 개인키를 도난당한다면 공격자는 해당 개인키가 제어하는 모든 디지털 자산에 대해 전체 액세스 권한을 갖는다. 암호화폐가 도난 당했다는 것은 일부 개인키가 발견되어 새 계정으로 돈을 보내는 거래에 사용되었음을 의미한다. 블록체인 데이터는 변경할 수 없으므로, 개인키를 훔치고 자산을 이체한다면 해당 거래를 취소하는 것은 불가능하다. 원장 트랜잭션의 모음이다. 블록체인 네트워크는 설계에 따라 분산되어 각 피어 간에 동일한 원장 데이터를 업데이트하고 동기화하는 많은 복사본을 생성한다. 새로운 노드가 블록체인 네트워크에 합류할 때마다 다른 노드를 찾아 블록체인 네트워크 원장의 전체 사본을 요청하여 원장의 손실이나 파괴를 어렵게 한다. 블록체인 네트워크는 SW, HW, 그리고 네트워크 인프라가 모두 다른 이기종 네트워크이다. 블록체인 네트워크 노드 사이에는 많은 차이점이 있기 때문에 하나의 노드에 대한 공격이 다른 노드에서도 작동한다는 보장이 없다. 블록체인 네트워크는 전 세계에서 지리적으로 다양한 노드로 구성된다. P2P 방식으로 작동하는 블록체인 네트워크는 손실에 대해 탄력적이다. 블록체인 네트워크는 모든 거래(트랜잭션)이 유효한지 확인해야 한다. 악의적인 노드가 트랜잭션을 전송하면 다른 사람들이 이를 감지하고 무시하여 잘못된 트랜잭션이 전파되는 것을 방지한다. 블록체인 네트워크는 분산 원장 내에서 수락된 모든 트랜잭션을 보유한다. 새 블록을 구축하기 위해 이전 블록을 참조해야 하므로 게시 노드에 최신 블록에 대한 참조가 포함되어 있지 않으면, 다른 노드는 이를 거부한다. 블록체인 네트워크는 디지털 서명 및 암호화 해시 가능을 사용하여 변조 방지를 제공한다. 일반적으로 블록체인 네트워크의 정보는 공개적으로 볼 수 있으며, 훔칠 것이 없다. 블록체인 네트워크의 사용자를 공격하려면 개별적으로 대상을 지정해야 한다. 또한, 블록체인 자체를 공격에 대한 목표로 하는 것은 신뢰성 있는 노드의 저항에 부딪힌다. 블록 블록체인 네트워크의 사용자는 블록체인 네트워크에 후보 트랜잭션을 제출한다. 제출된 트랜잭션을 다른 노드로 전파하지만, 블록화 하지는 않는다. 게시 노드가 블록을 게시할 때 트랜잭션이 블록체인에 추가된다. 블록 헤더에는 이 블록에 대한 메타데이터가 포함된다. 블록 데이터에는 블록체인 네트워크에 제출된 검증되고 인증된 트랜잭션 목록이 포함된다. 트랜잭션의 형식이 올바르고 각 트랜잭션의 디지털 자산 제공자가 각각 암호화된 트랜잭션에 서명하였는지 확인하여 유효성과 신뢰성을 보장한다. 이를 통해 거래에 대한 디지털 자산 제공자가 사용 가능한 디지털 자산에 서명할 수 있는 개인키를 보유하는 지 확인한다. 다른 전체 노드는 게시된 블록에 있는 모든 트랜잭션의 유효성과 신뢰성을 확인하고, 유효하지 않은 트랜잭션이 포함된 블록은 수락하지 않는다. 블록의 구조블록 헤더 The block number, also known as block height in some blockchain networks. The previous block header’s hash value. A hash representation of the block data (different methods can be used to accomplish this, such as a generating a Merkle tree, and storing the root hash, or by utilizing a hash of all the combined block data). A timestamp. The size of the block. The nonce value. For blockchain networks which utilize mining, this is a number which is manipulated by the publishing node to solve the hash puzzle. Other blockchain networks may or may not include it or use it for another purpose other than solving a hash puzzle. 블록 데이터 A list of transactions and ledger events included within the block. Other data may be present. 블록체인 기술 기초 공부 참고문헌 https://arxiv.org/abs/1906.11078 https://www.youtube.com/watch?v=bBC-nXj3Ng4","link":"/2022/02/12/Blockchain-%EA%B8%B0%EC%88%A0-%ED%95%99%EC%8A%B5-%EC%A0%95%EB%A6%AC-%EC%9E%90%EB%A3%8C1/"},{"title":"CommonJS와 ESModules 정리 자료1","text":"CommonJS and ESModules study Node.js에는 크게 두 종류의 스크립트가 있으며, CommonJS와 ESModules이다. 각각의 스크립트는 기본적으로 전혀 다르므로, npm에서 어떠한 package를 지원하는지에 따라 import, export 방법이 다르다. 구체적인 설명은 제외하고 node v16.13.1 LTS 기준으로 서로 간의 import 방법을 정리한다. CommonJS와 ESModules 기초 설명CommonJS 모듈을 내보내기 위해 module.exports를 이용하며, 모듈을 받기 위해 require를 이용한다. Top-Level Await를 지원하지 않아, 비동기적인 메소드를 실행하기 위해 async로 감싸주어야 하며, 이는 await로 동기적으로 수행할 수 있다. npm init의 기본 값이다. 12345module.exports = 변수명; // default exportmodule.exports.변수명 = 변수명; // named exportconst 변수명 = require('파일경로'); // default importconst { 변수명 } = require('파일경로'); // named import ESModules 모듈을 내보내기 위해 export를 이용하며, 모듈을 받기 위해 import를 이용한다. Top-Level Await를 지원한다. npm init의 기본 값이 아니므로, ESModules를 위해 package.json의 “type”을 추가하여야 한다. 1234{ ... &quot;type&quot;: &quot;module&quot;} 12345export default 변수명; //default exportexport 변수명; // named exportimport 변수명 from '파일경로'; // default importimport {변수명} from '파일경로'; // named import CommonJSCommonJS에서 CommonJS 불러오기 주의할 점 CommonJS 모듈에서 named export와 default export를 하나의 파일에 작성하면, named export를 불러올 수 없다. named export를 import 시도하면 TypeError가 발생한다. 12345678910111213141516171819/* * total/index.js */module.exports.namedSyncFunc = () =&gt; { return 'This is sync...';};module.exports = () =&gt; { return 'This is default...';};/* * index.js */const defaultFunc = require('./cjs/total/index.js');const { namedSyncFunc } = require('./cjs/total/index.js');console.log(defaultFunc());console.log(namedSyncFunc()); // TypeError: namedSyncFunc is not a function 12This is default...TypeError: namedSyncFunc is not a function CommonJS에서 CommonJS 불러오기 CommonJS에서 named export를 불러오기 위해 객체 구조 분해 연산 “{}” 을 이용한다. 변수명을 지정할 수도 있으며, 이러할 경우 변수명.메소드명()으로 named export를 불러온다. CommonJS에서 default export를 불러올 경우에는 변수 명을 지정할 수 있다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/* * /default/index.js */module.exports = () =&gt; { return 'This is default...';};/* * /named/index.js */const promise = () =&gt; { return new Promise((resolve) =&gt; { setTimeout(() =&gt; { resolve('This is async...'); }, 3000); });};module.exports.namedAsyncFunc = async () =&gt; { return promise();};module.exports.namedSyncFunc = () =&gt; { return 'This is sync...';};/* * index.js */const { namedAsyncFunc, namedSyncFunc } = require('./cjs/named/index.js');const defaultFunc = require('./cjs/default/index.js');console.log(namedSyncFunc());(async () =&gt; { console.log(await namedAsyncFunc());})();console.log(defaultFunc());// const namedFunc = require('./cjs/named/index.js');// console.log(namedFunc.namedSyncFunc());// (async () =&gt; {// console.log(await namedFunc.namedAsyncFunc());// })(); 123This is sync...This is default...This is async... 출력 결과를 보면, promise를 반환하는 namedAsyncFunc() 메소드의 출력이 가장 늦는 것을 볼 수 있다. 이는 CommonJS가 Top-Level Await를 지원하지 않기 때문이다. CommonJS에서 동기적으로 비동기 메소드 실행 CommonJS에서 비동기 메소드가 실행된 후에 동기적인 메소드를 실행하기 위해서는, 다음과 같이 async안에 동기적인 메소드를 작성하여야 한다. 12345678const { namedAsyncFunc, namedSyncFunc } = require('./cjs/named/index.js');const defaultFunc = require('./cjs/default/index.js');(async () =&gt; { console.log(namedSyncFunc()); console.log(await namedAsyncFunc()); console.log(defaultFunc());})(); 123This is sync...This is async...This is default... CommonJS에서 ESModules 불러오기 ESModules 모듈은 export할 때, promise로 감싸져서 반환되므로, Top-Level Await를 지원하지 않는 CommonJS에서 불러올 때, async 메소드 안에 넣어줘야 한다. ESModules는 하나의 파일 안에 named export와 default export를 동시에 사용 가능하다. 123456789101112131415161718192021222324252627282930313233/* * /index.js */const promise = () =&gt; { return new Promise((resolve) =&gt; { setTimeout(() =&gt; { resolve('This is async...'); }, 3000); });};export async function namedAsyncFunc() { return promise();}export function namedSyncFunc() { return 'This is sync...';}export default function defaultFunc() { return 'This is default...';}/* * index.js */(async () =&gt; { const defaultFunc = await import('./esm/index.js'); console.log(defaultFunc.namedSyncFunc()); console.log(await defaultFunc.namedAsyncFunc()); console.log(defaultFunc.default());})(); 123This is sync...This is async...This is default... CommonJS에서 ESModules 불러오기 주의할 점 만약, CommonJS에서 ESModules를 불러오기 위해 await를 Top-level에 사용한다면, 이는 에러가 발생한다. 1234/* * index.js */const defaultFunc = await import('./esm/index.js'); 123const defaultFunc = await import('./esm/index.js'); ^^^^^SyntaxError: await is only valid in async functions and the top level bodies of modules CommonJS에서 불러온 ESModules 타입 await를 사용하지 않은 ESModules를 출력해보면, promise로 감싸져서 반환되는 것을 알 수 있다. 12const defaultFunc = import('./esm/index.js');console.log(defaultFunc); 1Promise { &lt;pending&gt; } CommonJS에서 불러온 ESModules 타입 await를 사용한 ESModules를 출력해보면, default에는 default export, 각각의 이름으로 named export가 반환된 것을 확인할 수 있다. 1234(async () =&gt; { const defaultFunc = import('./esm/index.js'); console.log(await defaultFunc);})(); 12345[Module: null prototype] { default: [Function: defaultFunc], namedAsyncFunc: [AsyncFunction: namedAsyncFunc], namedSyncFunc: [Function: namedSyncFunc]} CommonJS에서 ESModules 다른 방식으로 불러오기 import문에서 await를 사용하지 않는다면, 출력하는 과정에서 await를 작성해야 한다. 이러할 경우, 비동기적으로 반환되는 메소드를 다시 기다려야 하므로, await를 두 번 작성하기 때문에 가독성이 떨어진다. 1234567const defaultFunc = import('./esm/index.js');(async () =&gt; { console.log((await defaultFunc).namedSyncFunc()); console.log(await (await defaultFunc).namedAsyncFunc()); console.log((await defaultFunc).default());})(); 123This is sync...This is async...This is default... 참고자료 https://roseline.oopy.io/dev/translation-why-cjs-and-esm-cannot-get-along","link":"/2022/02/16/CommonJS%EC%99%80-ESModules-%EC%A0%95%EB%A6%AC-%EC%9E%90%EB%A3%8C1/"},{"title":"AWS API Gateway기반의 번역 웹 서비스","text":"실습 요약 번역 API 게이트웨이용 람다 함수 생성A. 람다 함수 생성(람다 함수 이름 : lambda_for_translate_Service)B. 람다 함수 실행 역할 생성(람다 역할 이름 : role_for_translate_Service) 람다 함수 소스코드 작성 람다 함수 역할 수정A. 정책 생성 및 검토(정책 이름 : role_for_translate_Service)B. 기존 관리형 정책 선택(TranslateFullAccess) 람다 API 게이트웨이 설정 index.html 파일 수정 및 S3버킷 생성 S3 버킷에 수정 파일 업로드 번역 서비스 정적 웹 사이트 설정 및 테스트 API 게이트웨이용 람다 함수를 생성한다 함수 이름에 lambda_for_translate_Service를 입력한다 AWS 정책 템플릿에서 새 역할 생성 선택 role_for_translate_Service 입력 정책 템플릿은 ‘기본 Lambda@Edge’ 입력 람다 함수 코드는 다음과 같이 작성 1234567891011121314151617181920212223242526272829303132333435363738/* AWS SDK 를 가져옵니다.*/var AWS = require('aws-sdk');AWS.config.update({ region: 'us-east-1' });var translate = new AWS.Translate();exports.handler = function (event, context, callback) { console.log(JSON.stringify(event.body)); const response = JSON.parse(event.body); //event.body로 POST로 받은 데이터를 받습니다. try { const translateParams = { SourceLanguageCode: 'ko', TargetLanguageCode: 'en', Text: response.text, }; //translate SDK를 불러옵니다. translate.translateText(translateParams, function (err, data) { if (err) callback(err); callback(null, { statusCode: 200, headers: { 'Access-Control-Allow-Origin': '*', //S3에서 요청을 할 수 있도록 허용해줍니다. 'Access-Control-Allow-Credentials': true, }, body: data.TranslatedText, }); }); } catch (e) { callback(null, { statusCode: 200, body: JSON.stringify(e), }); }}; 람다 함수 역할을 수정 권한의 실행 역할에서 role_for_translate_Service 선택 기존에 있는 권한인 TranslateFullAccess를 선택 새롭게 translate로의 접근 권한이 생김 추가 트리거를 통하여 API 게이트웨이를 연간함 API 생성을 선택 보안은 열기로 설정 API 엔드포인트를 보면 주소가 생김 해당 주소가 홈페이지를 통해 서비스르 만들어 요청할 주소 웹 페이지를 다음과 같이 생성 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;번역웹사이트&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://stackpath.bootstrapcdn.com/bootstrap/4.2.1/css/bootstrap.min.css&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col align-self-center&quot;&gt; &lt;h5 id=&quot;resultText&quot;&gt;&lt;/h5&gt; &lt;form action=&quot;javascript:void(0)&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label&gt;텍스트를 입력해주세요.&lt;/label&gt; &lt;textarea class=&quot;form-control&quot; id=&quot;textInput&quot; rows=&quot;3&quot;&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;button onclick=&quot;sendReqeust()&quot; class=&quot;btn btn-primary&quot;&gt;Submit&lt;/button&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;script type=&quot;text/javascript&quot;&gt; var inputSelector = document.querySelector('#textInput'); var resultText = document.querySelector('#resultText'); function sendReqeust() { resultText.innerHTML = '로딩중...'; fetch('https://0pmjclpe95.execute-api.ap-northeast-2.amazonaws.com/default/lambda_for_translate_service', { method: 'POST', body: JSON.stringify({ text: inputSelector.value, }), }).then(function (response) { return response.text().then(function (text) { resultText.innerHTML = text; }); }); } &lt;/script&gt;&lt;/html&gt; 이때, fetch 안에 아까 람다 함수의 API 게이트웨이 엔드포인트를 복사한다. S3 버킷을 생성 버킷 이름은 전세계에서 유일한 이름으로 설정해야 함 이때, 퍼블릭 액세스 차단을 위한 버킷 설정에서 모든 퍼블릭 액세스 차단을 해제하고, 경고문을 체크 해당 버킷에 방금 생성한 index.html 파일을 업로드 한다. 이때 중요한점은 해당 index.html 파일을 퍼블릭으로 설정해야 함 정적 웹 사이트 호스팅 편집에서 활성화를 선택 인덱스 문서로 index.html, 파일은 없지만 오류 문서로 error.html을 입력 버킷 웹 사이트 엔드포인트가 뜨는데, 이것이 바로 번역 사이트의 엔드 포인트 사이트 접속 시 해당 화면이 나오는 것을 볼 수 있음 텍스트 입력 후 submit 선택 시 번역이 작동되는 것을 확인","link":"/2020/11/10/AWS-API-Gateway%EA%B8%B0%EB%B0%98%EC%9D%98-%EB%B2%88%EC%97%AD-%EC%9B%B9-%EC%84%9C%EB%B9%84%EC%8A%A4/"},{"title":"CommonJS와 ESModules 정리 자료2","text":"CommonJS and ESModules study Node.js에는 크게 두 종류의 스크립트가 있으며, CommonJS와 ESModules이다. 각각의 스크립트는 기본적으로 전혀 다르므로, npm에서 어떠한 package를 지원하는지에 따라 import, export 방법이 다르다. 구체적인 설명은 제외하고 node v16.13.1 LTS 기준으로 서로 간의 import 방법을 정리한다. ESModulesESModules에서 ESModules 불러오기 ESModules은 하나의 파일안에 named export와 default export를 사용할 수 있다. named export를 불러오기 위해, 객체 구조 분해 연산을 이용하며, default export를 불러오기 위해 변수를 지정한다. 지정된 변수명으로 default export의 메소드를 호출할 수 있다. 1234567891011121314151617181920212223242526272829303132/* * /index.js */const promise = () =&gt; { return new Promise((resolve) =&gt; { setTimeout(() =&gt; { resolve('This is async...'); }, 3000); });};export async function namedAsyncFunc() { return promise();}export function namedSyncFunc() { return 'This is sync...';}export default function defaultFunc() { return 'This is default...';}/* * index.js */import { namedAsyncFunc, namedSyncFunc } from './esm/index.js';import defaultFunc from './esm/index.js';console.log(namedSyncFunc());console.log(await namedAsyncFunc());console.log(defaultFunc()); 123This is sync...This is async...This is default... ESModules에서 CommonJS 불러오기 ESModules에서 CommonJS를 불러오는 것은 import로도 가능하다. (require 사용 불가능) 이는 ESModules를 호출할 때와 같으며, ESModules는 Top-Level Await를 지원하기 때문에 async 메소드 없이 await를 사용할 수 있다. 추가적으로 객체 구조 분해 연산 뿐만이 아니라, 변수명을 지정하여 named export를 이용할 수 있으며, 이 경우에는 변수명.메소드명()으로 named export를 이용한다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344/* * /default/index.js */module.exports = () =&gt; { return 'This is default...';};/* * /named/index.js */const promise = () =&gt; { return new Promise((resolve) =&gt; { setTimeout(() =&gt; { resolve('This is async...'); }, 3000); });};module.exports.namedAsyncFunc = async () =&gt; { return promise();};module.exports.namedSyncFunc = () =&gt; { return 'This is sync...';};/* * index.js */import defaultFunc from './cjs/default/index.js';import { namedSyncFunc, namedAsyncFunc } from './cjs/named/index.js';console.log(namedSyncFunc());console.log(await namedAsyncFunc());console.log(defaultFunc());console.log();console.log('==============================');console.log();import namedFunc from './cjs/named/index.js';console.log(namedFunc.namedSyncFunc());console.log(await namedFunc.namedAsyncFunc()); 12345678This is sync...This is async...This is default...==============================This is sync...This is async... ESModules에서 불러온 ESModules 타입 ESModules의 타입은 [형식 : 이름] 형태로 반환된다. promise와 같은 비동기적으로 반환되는 메소드는 AsyncFunction이며, 동기적으로 반환되는 메소드는 Function이다. 1234567891011121314151617181920212223242526272829303132/* * /index.js */const promise = () =&gt; { return new Promise((resolve) =&gt; { setTimeout(() =&gt; { resolve('This is async...'); }, 3000); });};export async function namedAsyncFunc() { return promise();}export function namedSyncFunc() { return 'This is sync...';}export default function defaultFunc() { return 'This is default...';}/* * index.js */import { namedAsyncFunc, namedSyncFunc } from './esm/index.js';import defaultFunc from './esm/index.js';console.log(namedSyncFunc); // [Function: namedSyncFunc]console.log(namedAsyncFunc); // [AsyncFunction: namedAsyncFunc]console.log(defaultFunc); // [Function: defaultFunc] 123[Function: namedSyncFunc][AsyncFunction: namedAsyncFunc][Function: defaultFunc] 다양한 방법으로 ESModules 불러오기import 줄여쓰기 default export와 named export는 하나의 import 문으로 불러올 수 있다. 12345import defaultFunc, { namedSyncFunc, namedAsyncFunc } from './esm/index.js';console.log(namedSyncFunc());console.log(await namedAsyncFunc());console.log(defaultFunc()); 123This is sync...This is async...This is default... 별명 붙이기 구조 분해 할당 연산을 이용할 경우 불러오는 named export에 별명을 붙일 수 있으며, default export에 별명을 붙이기 위해서는 구조 분해 할당 연산 안에서 default로 불러올 수 있다. 12345import { namedSyncFunc as sf, namedAsyncFunc as af, default as df } from './esm/index.js';console.log(sf());console.log(await af());console.log(df()); 123This is sync...This is async...This is default... 모두 불러오기 ‘*‘을 이용하여 모든 named export와 default export를 불러올 수 있으며, 이 경우에는 default export를 불러오기 위해 default()를 이용하여야 한다. 불러온 모듈의 타입은 CommonJS에서 EXModules를 불러왔을 경우와 동일하다. 1234567import * as f from './esm/index.js';console.log(f);console.log(f.namedSyncFunc());console.log(await f.namedAsyncFunc());console.log(f.default()); 12345678[Module: null prototype] { default: [Function: defaultFunc], namedAsyncFunc: [AsyncFunction: namedAsyncFunc], namedSyncFunc: [Function: namedSyncFunc]}This is sync...This is async...This is default... 참고자료 https://roseline.oopy.io/dev/translation-why-cjs-and-esm-cannot-get-along","link":"/2022/02/16/CommonJS%EC%99%80-ESModules-%EC%A0%95%EB%A6%AC-%EC%9E%90%EB%A3%8C2/"},{"title":"Docker 시작하기","text":"docker 설치 도커 설치 : https://www.docker.com/get-started docker desktop을 설치 powershell에서 도커 버전 확인 명령어 : docker –version docker 설치 시 주의사항 windows에서 설치할 경우 WSL 2와 관련된 설정이 나올 텐데 이를 허용해야 한다. 실습 환경 설정 git clone https://gitlab.com/yalco/practice-docker.git DokerStudy Node.js : 브라우저가 아닌 컴퓨터 환경에서 자바스크립트를 돌리게 해줌 실습 코드 수행 npm install –global http-server : global로 설치를 해야 http-server 명령어 이용 가능합니다. cd frontend로 들어간 후 http-server -p 8080 ./public 명령으로 서버 실행 그러나 이러한 Node.js와 http-server 없이 실행하기 위해 도커를 사용한다. docker 실행 docker run -it node : 만약 permission 관련 오류 발생 시 sudo를 붙이면 됨 Node.js 깔린 것처럼 입력 콘솔이 출력된다. 이 Node.js 환경은 이미지 형태인데, docker의 이미지란 것은 캡쳐해서 박제한 것이다. docker 설명 run은 다운 후 이미지를 해동해서 컨테이너로 만든다. -it는 컨테이너를 연 다음 cli를 사용하겠다는 의미이다. 그 후 node 명령어가 실행되므로 입력 화면이 나오는 것이다. docker 조작하기 docker images : 설치 된 것 확인, 설치 되었으니 docker run -it node 명령어 사용하면 설치없이 바로 실행 docker ps : 컨테이너 확인 가능 docker exec -it (docker ps 명령어로 확인한 컨테이너 명) bash root@f44956de125d:/# 가 뜨면서 컨테이너 내부를 통해 가상의 리눅스 환경으로 들어간 것이다 ls를 입력하면 리눅스 기본 디렉터리들이 보인다 -&gt; 컨테이너마다 각각 이 파일 시스템과 네트워크가 존재, 도커 데스크탑 프로그램으로 구현된 것!!! 도커의 컨테이너들은 리눅스 가상 환경의 형태로 돌아감! docker 종료하기 node cli에서 ctrl+c를 하면 컨테이너 안의 Node와 회의를 끝마친 것이다. 이 후 docker ps를 입력하더라도 컨테이너가 나타나지 않는다. docker ps -a : 모든 컨테이너를 보여줌, 현재 중지된 컨테이너도 보임 이 디렉터리에서만 확인할 수 있는 것이 아니라 docker에 의해 다른 곳에서 관리 되므로 어떠한 디렉터리에서도 확인이 가능 docker container 삭제 한번에 도커 컨테이너 삭제 docker stop $(docker ps -aq) docker system pune -a Dockerfile 이미지를 만들기 위한 설계서 Dockerfile 내용 FROM node:12.18.4 : node version RUN npm install -g http-server : 이미지를 생성할 과정에서 실행할 명령어 WORKDIR /home/node/app : 이 안에서 명령어를 수행할 위치 CMD [“http-server”, “-p”, “8080”, “./public”] : 이미지로부터 컨테이너가 만들어져 가동될 때 기본적으로 바로 실행되는 명령어 Dockerfile 실행 cli에서 이 폴더로 들어온 다음 -t 뒤에 원하는 이미지명을 적은 뒤 Docker file로의 상대 경로를 적는다. 파일이 Dockerfile이면 따로 명시할 필요가 없음 docker build -t frontend-img . docker images 명령어를 통하여 node 이미지가 다운 받아지고 이를 기반으로 frontend-img 이미지가 만들어진다. image run 시키기 docker run –name frontend-con -v $(pwd):/home/node/app -p 8080:8080 frontend-img docker run –name frontend-con -v “%cd%”:/home/node/app -p 8080:8080 frontend-img 아까는 도커가 임의의 컨테이너명을 지어줬지만 이번에는 frontend-con이라는 이름을 지어준다. -v는 볼륨의 약자인데 컨테이너의 특정 폴더를 공유 코드를 짠 후 그 파일을 거실 탁자에 두면 그 거실 탁자는 Node.js가 일하는 컨테이너의 /home/node/app 서랍과 연결된 것 pwd는 현재 디렉터리 컨테이너가 언제 몇개가 만들어지든 각 컨테이너의 app 서랍에서는 거실에 둔 파일들로 얼마든지 서비스를 실행 이를 통하여 CMD [“http-server”, “-p”, “8080”, “./public”]로 파일 실행이 가능한 것이다. Port 설명 -p는 포트 컨테이너는 CMD [“http-server”, “-p”, “8080”, “./public”]를 통하여 8080 포트로 송출할 거니까 집에서도 같은 곳으로 송출한다는 의미이다. Dockerfile database file FROM mysql:5.7 : mySql 사용하겠다 환경변수 : 어떤 사용자? 비번? 디비명? 등등 설정 ENV MYSQL_USER mysql_user ENV MYSQL_PASSWORD mysql_password ENV MYSQL_ROOT_PASSWORD mysql_root_password ENV MYSQL_DATABASE visitlog COPY ./scripts/ /docker-entrypoint-initdb.d/ : script 안의 파일들을 이미지 내부의 /docker-entrypoint-initdb.d/로 저장 mysql이 실행이 될 때 /docker-entrypoint-initdb.d/안의 명령어들을 실행 script 파일들은 컨테이너 초기화 과정에서 필요한 것들이니까 copy로 이미지 안에 미리 넣어두는 것이 좋을 것이다. copy와 run의 차이점 copy는 run처럼 이미지를 생성하는 과정에서 해당 이미지 안에 특정 파일을 미리 넣어두는 것이고 volume은 CMD 처럼 컨테이너가 생성되어 실행될 때 그 내부의 폴더를 외부의 것과 연결하는 것이다. Dokcerfile 실행 docker build -t database-img . docker run –name database-con -p 3306:3306 database-img 컨테이너명과 포트만 지정하면 됨 -&gt; 실전에서는 데이터를 유지해야 하니까 데이터 폴더를 -v 옵션으로 집의 데이터 창고와 볼륨 창고를 연동할 것이다. docker run –name database-con -p 3306:3306 -d database-img : daemon의 줄임말, 뒤의 안보이는 곳에 가서 알아서 컨테이너 설치 및 실행… 현재 어떻게 실행되는지 보고 싶다면 : docker logs -f database-con Dockerfile backend file FROM python:3.8.5 RUN pip3 install flask flask-cors flask-mysql : flask로 api를 돌림 WORKDIR /usr/src/app CMD [“python3”, “backend.py”] : 백엔드 서버를 실행 docker-compose 이처럼 서비스를 구성하는 3개의 요소가 각각의 폴더에 Dockerfile를 통해 도커에서 어떻게 실행될지 설정이 되어 있는 것이다. 각각의 네트워크로 분리되어 있기 때문에 백엔드와 데이터베이스는 데이터를 주고 받지 못한다. 요소 연결 및 서비스 간편하게 실행? 이를 위해 사용되는 것이 거시적인 설계도인 docker-compose version: ‘3’ : 버전이며 지금의 최신 버전이 3이다. 각각의 docker의 내용들이 services란 항목의 내부 항목들로 들어간다. docker-compose 내용 설명 항목명은 각 서비스들의 이름 (database:) 이며 이들간의 네트워크에서 각각의 호스트명이 된다. build: 는 도커 파일의 위치이다 compose 파일로부터.. ports: 는 외부에 개방할 포트이다. run 실행마다 작성해야되었던 명령어를 문서로 미리 작성한 것이다. backend에서는 volume을 사용하기 때문에 volumes:를 작성한다. 환경 변수도 compose에서 environment:로 미리 설정할 수 있다. docker-compose 실행 docker-compose/yml이 있는 위치에서 docker-compose up을 실행 docker-compose up -d를 하면 뒤에서 알아서 컨테이너 생성 및 실행 마무리 이를 통하여 어느 서버에서든 도커 환경만 설치되어 있으면 git 등으로 이 프로젝트를 다운 받고 도커를 실행해서 이 컴퓨터와 똑같은 환경을 조성하고 문제없이 서비스를 돌릴 수 있을 것이다. 추가 라이브러리들을 일일히 하지 않아도 된다. 구름 IDE는 도커 기반의 서비스이다 -&gt; 도커 안의 도커 설치는 현재에서는 안된다. 윈도우에서는 WSL로 실습할 수 있지만 오류가 많을 수도 있음 우분투에서는 ubuntu onstall docker를 검색한 후에 도커 설치할 수 있고 docker-compose도 따로 설치해야 함 docker-compose up","link":"/2021/12/07/Docker-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/"},{"title":"CommonJS와 ESModules 정리 자료3","text":"CommonJS and ESModules study Node.js에는 크게 두 종류의 스크립트가 있으며, CommonJS와 ESModules이다. 각각의 스크립트는 기본적으로 전혀 다르므로, npm에서 어떠한 package를 지원하는지에 따라 import, export 방법이 다르다. 구체적인 설명은 제외하고 node v16.13.1 LTS 기준으로 서로 간의 import 방법을 정리한다. Dual package CommonJS와 ESModules를 동시에 사용하는 패키지이다. 만약 라이브러리가 오직 default export만을 제공한다면, import를 사용하기만 하면 된다. CommonJS의 named export를 ESModules로 감싸기 CommonJS를 ESModules로 감싸기 위한 디렉터리 구조는 다음과 같다. ESModules wrapper를 esm의 하위 디렉터리에 넣고, package.json에 “type”을 추가한다. 12345// /esm/wrapper.jsimport namedFunc from '../index.js';export const namedSyncFunc = namedFunc.namedSyncFunc;export const namedAsyncFunc = namedFunc.namedAsyncFunc; 12345678910111213// /esm/package.json{ &quot;name&quot;: &quot;esm&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;wrapper.js&quot;, &quot;scripts&quot;: { &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot; }, &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;type&quot;: &quot;module&quot;} exports map을 추가한다. 12345// package.json&quot;exports&quot;: { &quot;require&quot;: &quot;./index.js&quot;, &quot;import&quot;: &quot;./esm/wrapper.js&quot;} 사용 방법CommonJS123456const { namedAsyncFunc, namedSyncFunc } = require('./dual/index.js');console.log(namedSyncFunc());(async () =&gt; { console.log(await namedAsyncFunc());})(); ESModules1234import { namedAsyncFunc, namedSyncFunc } from './dual/esm/wrapper.js';console.log(namedSyncFunc());console.log(await namedAsyncFunc()); 참고자료 https://roseline.oopy.io/dev/translation-why-cjs-and-esm-cannot-get-along","link":"/2022/02/16/CommonJS%EC%99%80-ESModules-%EC%A0%95%EB%A6%AC-%EC%9E%90%EB%A3%8C3/"},{"title":"Express.js 파일 전송 및 확인하기 예제1","text":"필요 모듈 설치하기123npm i expressnpm i body-parsernpm i multer 소스코드 작성하기123456789101112131415161718192021222324252627282930313233const bodyParser = require('body-parser');const multer = require('multer');const express = require('express');const app = express();app.use(express.json());app.use(bodyParser.urlencoded({ extended: false }));app.use('/myimages', express.static('images'));var storage = multer.diskStorage({ destination: function (req, file, cb) { // cb 콜백함수를 통해 전송된 파일 저장 디렉토리 설정 cb(null, './images'); }, filename: function (req, file, cb) { // cb 콜백함수를 통해 전송된 파일 이름 설정 cb(null, file.originalname); // cb(null, 'test.jpg'); },});// const upload = multer({dest: './images/'});const upload = multer({ storage: storage });app.post('/upload', upload.single('img'), (req, res) =&gt; { console.log(req.file); res.json(req.file);});app.listen(65001, () =&gt; { console.log('server running start');}); 1node index.js 파일 전송 예제 Postman을 이용하여 서버로 이미지를 전송한다. 전송 시, 파일에 대한 정보가 반환되는 것을 볼 수 있다. 전송 파일 확인하기 서버에 저장된 이미지 파일을 확인하기 위해, 웹 브라우저에 다음과 같이 입력한다. 이때, test.png는 서버로 전송한 이미지 파일 이름이다. 1http://localhost:65001/myImages/test.png","link":"/2022/03/27/Express-js-%ED%8C%8C%EC%9D%BC-%EC%A0%84%EC%86%A1-%EB%B0%8F-%ED%99%95%EC%9D%B8%ED%95%98%EA%B8%B0-%EC%98%88%EC%A0%9C1/"},{"title":"Express.js 파일 전송 및 확인하기 예제2","text":"개요 https://kihyeon-hong.github.io/2022/03/27/Express-js-파일-전송-및-확인하기-예제1/ 기존의 예제를 응용하여, 서버로 파일을 전송하고, 목록을 확인하여 전송한 파일을 볼 수 있는 간단한 문서 뷰어를 구현한다. 필요 모듈 설치1234npm i expressnpm i body-parsernpm i multernpm i ejs 문서 뷰어 웹페이지 소스 코드 구현index.js123456789101112131415161718192021222324252627282930313233343536373839404142const express = require('express');const bodyParser = require('body-parser');const multer = require('multer');const fs = require('fs');const app = express();app.use(express.json());app.use(bodyParser.urlencoded({ extended: false }));app.use('/files', express.static('files'));app.set('view engine', 'ejs');var storage = multer.diskStorage({ destination: function (req, file, cb) { cb(null, './files'); }, filename: function (req, file, cb) { cb(null, file.originalname); },});const upload = multer({ storage: storage });app.get('/', (req, res, next) =&gt; { res.render('index', { files: fs.readdirSync('files'), });});app.get('/files', (req, res, next) =&gt; { res.send(fs.readFileSync(`files/${req.query.name}`, 'utf8'));});app.post('/upload', upload.single('mydata'), (req, res) =&gt; { console.log(req.file); res.redirect(['/']);});app.listen(65001, () =&gt; { console.log(`Server running 65001...`);}); views/index.ejs123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=&quot;upload&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;input type=&quot;file&quot; name=&quot;mydata&quot; /&gt; &lt;input type=&quot;submit&quot; value=&quot;저장&quot; /&gt; &lt;/form&gt; &lt;br /&gt; &lt;% for(let i = 0; i &lt; files.length; i++) { %&gt; &lt;form action=&quot;files&quot; method=&quot;get&quot;&gt; &lt;input type=&quot;text&quot; value=&quot;&lt;%= files[i] %&gt;&quot; name=&quot;name&quot; readonly /&gt; &lt;input type=&quot;submit&quot; value=&quot;보기&quot; /&gt; &lt;/form&gt; &lt;% } %&gt; &lt;/body&gt;&lt;/html&gt; files/test.html1234567&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;/head&gt; &lt;body&gt; &lt;h3&gt;Test!!!&lt;/h3&gt; &lt;/body&gt;&lt;/html&gt; 1node index.js 테스트 처음 웹 페이지를 접속하면, 기본적으로 작성해둔 test.html을 확인할 수 있다. 해당 파일을 열어보면 다음과 같이 나타난다. 새로운 파일을 첨부하고 저장을 누른다. 추가한 파일이 나타난다. 추가한 파일을 열어보면 다음과 같이 해당 파일의 내용을 확인할 수 있다.","link":"/2022/03/27/Express-js-%ED%8C%8C%EC%9D%BC-%EC%A0%84%EC%86%A1-%EB%B0%8F-%ED%99%95%EC%9D%B8%ED%95%98%EA%B8%B0-%EC%98%88%EC%A0%9C2/"},{"title":"Express와 localtunnel을 이용하여 외부 접속하기","text":"Express와 localtunnel을 이용하여 외부 접속하기 Node.js의 express.js로 구축한 서버는 사설 IP로 접속 가능하며, 외부로 공개하기 위해서는 포트포워딩과 같은 추가적인 설정이 필요하다. localtunnel https://www.npmjs.com/package/localtunnel localtunnel은 로컬 환경에서 동작중인 서버의 포트를 외부로 공개하기 쉽도록 한 npm 모듈이다. forever https://www.npmjs.com/package/forever forever는 주어진 스크립트가 백그라운드에서 실행되도록 하는 간단한 cli 도구이다. 설치하기 localtunnel과 forever를 -g로 설치한다. 이때, 권한 거부를 방지하기 위해 sudo 명령어로 실행한다. 12sudo npm install -g localtunnelsudo npm install -g forever 예제 소스 코드 받기 express 실행과 동시에 localtunnel로부터 실시간으로 외부로 공개하는 url를 제공받는 예제 코드이다. https://github.com/KiHyeon-Hong/Localtunnel_and_forever_test_code 123git clone https://github.com/KiHyeon-Hong/Localtunnel_and_forever_test_code.gitcd Localtunnel_and_forever_test_codenpm i sudo 명령어를 통해 서버를 실행하며, 실행 후 localtunnel로부터 받은 url을 파일로 저장하여 확인하는 명령어를 실행한다. 1sudo forever start mainController.js &amp;&amp; lt --port 65001 &gt; ./files/url.txt 실행 결과 1sudo forever start mainController.js &amp;&amp; lt --port 65001 &gt; ./files/url.txt 위 명령어를 통해 실행한 화면이다. 기본적으로 이미 알고 있는 사설 IP를 이용해 접속하면, 다음과 같이 외부로 공개하기 위한 url을 확인할 수 있다. 해당 url을 복사하여 접속하면, 최초 1회 허용 메시지가 출력된다. Click to Cintinue를 클릭한다. 제공된 url을 통해 접속이 된 것을 확인할 수 있으며, 이는 외부에서도 접속할 수 있다. files/url.txt는 localtunnel로 제공받은 url이 기록된다. 주의사항 해당 예제 소스코드는 윈도우 환경에서 동작하지 않는다. 추가적으로 서버 종료 후 다시 실행 시 새로운 url이 발급되며, 전에 사용한 url은 동작하지 않는다.","link":"/2022/02/12/Express%EC%99%80-localtunnel%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%98%EC%97%AC-%EC%99%B8%EB%B6%80-%EC%A0%91%EC%86%8D%ED%95%98%EA%B8%B0/"},{"title":"Git Blog 시작","text":"","link":"/2020/09/18/Git-Blog-%EC%8B%9C%EC%9E%91/"},{"title":"Git Tag","text":"Tag 태그는 언제나 똑같은 것을 가리켜야 한다 현재 버전의 상태를 다운로드 하고 싶다 git tag 1.0.0 현재 master 브랜치에서 태그가 만들어진다 git tag master git tag (커밋번호) 브랜치와는 달리 태그는 항상 일정한 것을 가리킨다 git checkout 1.0.0(태그명) : 테그명을 입력하면 해당 커밋으로 넘어갈 수 있다. Annotated Tag 태그에 대해 좀 더 자세한 설명을 추가하고 싶을 때 git tag -a 1.1.0 -m “bug fix” master : 어노테이션 태그 git tag -v 1.1.0 : 상세한 태그 설명을 볼 수 있음 태그를 올리고 싶으면 git push –tags origin master : –tags가 없으면 태그는 원격 저장소로 가지 않음 올라갈 태그는 releases로 올라감 git tag -d 1.1.0 : 태그 삭제 Tag의 원리 git tag 1.1.2 refs/tags/1.1.2 : 텍스트 파일이고 내용은 objets id 가리키며, commit을 가리킨다. git tag -a 1.1.3 -m “bug fix” objects/3e/… 특정한 오비젝트 가리키며 커밋을 가리킴 태그 이름과 태그 내용 또한 저장됨 refs/tags/1.1.3 : 3e…인 objects밑의 태그를 가리킴","link":"/2021/02/21/Git-Tag/"},{"title":"Git merge","text":"merge &amp; conflict 충돌이 발생했을 때의 처리 방법 123CONFLICT (add/add): Merge conflict in common.txtAuto-merging common.txtAutomatic merge failed; fix conflicts and then commit the result. index 파일에는 보통 490c7285a63e6531ea7d4b3eb3f95d0784c6066d 0 f1.txt이지만 0이 늘어난다. 1 -&gt; 원본 2 -&gt; 현재 브랜치의 바뀐내용 3 -&gt; 병합하고 싶은 브랜치의 바뀐내용 자동으로 깃은 병합작업을 실시 MERGE_HEAD_ MERGE_MSG : 충돌 해결 했을 때 커밋시 메시지 3way merge vs 2 way merge12345ME Base Other 2way 3way A A x ? x B B B B B 1 C 2 ? ? x D D ? x 2way는 base를 보지 않고 2개의 차이점만을 본다 3way는 base를 참조해서 2개의 대상을 병합한다(훨씬 good)","link":"/2021/02/21/Git-merge/"},{"title":"Git Branch","text":"git branch git branch : 치면 *master라고 뜨는데 기본 브랜치를 의미한다. git branch exp(생성할 브랜치명) : branch를 생성한다 -&gt; 현재 브랜치 상태를 그대로 복사한다. 현재 사용되는 브랜치에 *가 뜬다 git checkout git checkout exp : 브랜치를 exp 브랜치로 이동 f1.txt라는 파일이 어떤 브랜치에 있냐에 따라 내용이 완전히 달라짐 (exp branch에서 f2.txt를 만들고 add, commit하고 master branch로 넘어가면 f2.txt파일이 보이지 않음, 그러나 f2.txt파일을 만들고 add, commit을 하지 않으면 master branch로 넘어가도 사라지지 않음) git log –branches –decorate –graph 자신이 체크아웃된 브랜치 말고 모든 브랜치를 보여줌 HEAD -&gt; exp 되면 현재의 브랜치 –graph 하면 흐름을 알 수 있음 git log –branches –decorate –graph –oneline 1줄로 현재의 상태를 보여줌 git log master..exp : 2개의 브랜치 사이의 차이를 보여줌 git log exp..master : exp에는 없고 master에는 있는 것들 git log -p exp..master : 소스코드의 차이까지 보여줌 git diff master..exp : master와 exp의 현재 상태를 비교 함 Branch 병합exp에서 작업했던 내용을 master로 병합을 하고 싶다 (그 반대와는 다름) exp =&gt; master로 병합을 원할 경우 master에 checkout을 한 후 master에서 merge 명령어를 작성 git merge exp : master에서 실행하면 exp를 master로 병합 merge된 commit은 2개의 부모를 갖는다 (exp와 master였던 것) git checkout exp -&gt; git merge master git branch -d exp : exp branch를 삭제한다 병합 순서 git checkout -b test = git branch test -&gt; git checkout test merge를 했을 때 Fast-forward가 뜰 경우 branch 후 아무 일도 하지 않고 merge를 할 경우 이동만 시키면 병합 작업이 끝남 fast-forword하면 별도의 commit을 생성하지 않음, 바꾸기만 함 merge made by the ‘recursive’ strategy가 뜰 경우 fast-forward를 할 수 없는 경우이다 두 commit의 공통의 조상을 찾고, 두 commit을 합치고 합친 것을 알려주고, 합친 새로운 commit을 자동으로 생성한다. fast-forard가 아닌 방식은 merge commit을 생성한다. Stash branch에서 작업하다가 다른 branch로 checkout해야 하는 경우, commit하기도 애매하고 commit하지 않으면 checkout을 할수 없을 경우에 사용 작업한 내용을 숨겨놓고 그 브랜치의 최신 commit(head)의 버전으로 이동해서 깔끔하게 하고 다른 브랜치로 checkout 할 수 있음 exp 브랜치에서 작업하였지만, add, commit을 하지 않으면 master로 checkout을 했을때 add되지 않았다고 뜸 -&gt; exp에서 한 작업이 master에게 까지 영향을 미침 git stash Saved working directory and index state WIP on exp: b416d47 Merge branch ‘exp’, 워킹 디렉터리의 내용이 저장되었고 인덱스 내용도 세이브되었음 exp에 exp, master에서 git status하면 작업했던 내용들이 숨겨져서 사라짐 git stash apply : 숨겨진 파일을 다시 불러옴 git stash list : list를 볼 수 있음 git reset –hard HEAD 가장 최신 커밋 상태로 우리의 워킹 카피를 보냄, stash의 내용은 사라지지 않음! -&gt; 명시적으로 삭제를 하지 않는한 살아있음 git stash apply를 통하여 다시 숨겨놓은 것을 받아올 수 있음 (가장 최근의 stash를 적용함) git stash drop : 가장 최근의 stash를 삭제 stash를 전부 적용하기 위해 apply -&gt; drop -&gt; apply -&gt; drop을 반복한다 git stash pop : apply drop까지 됨 stash는 워킹 디렉터리의 변경사항을 감추는 것이다 add 하지 않은 것은 stash를 하더라도 숨겨지지 않는다 (untracked) -&gt; stash는 최소한 버전관리중인 파일에 대해서만 적용이 된다. Branch 상세 .git의 HEAD 파일 -&gt; refs/heads/master : objects의 id, 즉 commit의 object id를 가리키고 있음 새로운 commit 시 방금 commit으로 바뀜(가장 최신의 commits), 그리고 해당 commit의 parent를 통해서 탐색해 갈 수 있음 새로운 branch 생성 refs/heads/exp가 생성되며 최신 commits을 가리킨다 rm .git/refs/heads/exp를 하면 삭제 가능 git에서 브랜치는 매우 중요하지만 단순한 파일일 뿐이다 HEAD는 head를 가리킴 git checkout 시 HEAD 내용이 바뀜 Branch 병합 과정의 충돌 merge 과정에서 파일의 내용이 다를 경우 같은 파일임에도 서로 수정하는 위치가 다르다면 자동으로 합쳐준다 ex} master -&gt; function a(기존), function b(추가) exp -&gt; function c(추가), function a(기존) merge -&gt; function c, finction a, function b but, 수정하는 위치가 같다면 ex) function a(master){}, function a(exp){} 123CONFLICT (add/add): Merge conflict in common.txtAuto-merging common.txtAutomatic merge failed; fix conflicts and then commit the result. git status 시123Unmerged paths: (use &quot;git add &lt;file&gt;...&quot; to mark resolution) both added: common.txt vi common.txt 시123- ======= 구분자 중심으로- &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD : 현재 checkout branch- &gt;&gt;&gt;&gt;&gt;&gt;&gt; exp : exp branch의 내용 자기가 자동 merge 실패하였기 때문에 충돌을 해결하라 충돌이 난 부분 표시이다 -&gt; 문제를 수정하자 그 후 git add common.txt git commit (보면 충돌난 것 해결했다고 메시지가 뜸) git add 없이 merge를 또 시도할 경우 뜨는 에러1234error: Merging is not possible because you have unmerged files.hint: Fix them up in the work tree, and then use 'git add/rm &lt;file&gt;'hint: as appropriate to mark resolution and make a commit.fatal: Exiting because of an unresolved conflict.","link":"/2021/02/21/Git-Branch/"},{"title":"Git blog 개발 환경 이동하기","text":"Git blog 개발 환경 이동하기npm install","link":"/2022/05/29/Git-blog-%EA%B0%9C%EB%B0%9C-%ED%99%98%EA%B2%BD-%EC%9D%B4%EB%8F%99%ED%95%98%EA%B8%B0/"},{"title":"Git rebase vs merge","text":"rebase vs merge 병합을 하지만 결과가 좀 다르다 merge master내용을 feature로 가져오고 싶다 git checkout feature git merge master -&gt; 공통 조상과 3way merge 실시, master는 하나 전을 가리키고 있음 rebase 공통 조장 : base git checkout feature git rebase master -&gt; 임시 저장소 어딘가에 feature의 커밋들이 저장되고, feature는 master의 최신 커밋으로 checkout된다. -&gt; 임시 저장소의 commit들과 f,m인 브랜치와 병합 -&gt; 임시에 2개 커밋 있었으면 1개하고 임시에서 1개 지우고 1개 하고 임시에서 1개 지워서 새 브랜치 만듬 merge의 경우 history가 병렬 rebase는 history가 1개로 나아감 역사 파악이 더 편함 rebase는 어렵고 위험하다 merge는 충돌 발생해도 해결이 쉬움","link":"/2021/02/21/Git-rebase-vs-merge/"},{"title":"Git 시작하기","text":"Git에 대한 기초 학습 내용Git version control system Backup, Recovery, Collaboration version control system : CVS, SVN, Git등 다양하다. Dropbox, Google Drive도 버전관리 시스템의 일종이다. 1git git 입력 시 사용할 수 있는 명령어 목록이 뜬다. git init Initialized empty Git repository in ~ git 저장소를 초기화 한다. .git Directory가 생성되며 version에 관련된 정보가 저장되므로 삭제하면 안됨 vim vim f1.txt 입력시 f1.txt 파일이 생성된다. 입력모드와 명령모드로 구분되어 있다.(i, a, o를 통하여 입력모드로, esc를 통하여 명령모드로 전환) :wq를 통하여 저장 후 나가기 git add Untracked files : 디렉터리 안에는 존재하지만, 버전관리를 하기 전까지는 git이 무시한다. git이 관리를 시작하기 위한 명령어가 add이다. git add f1.txt 후 Changes to be committed로 변경됨 프로젝트를 하다보면 프로젝트 핵심 파일과 임시 파일이 있는데 임시 파일은 버전 관리를 하면 안됨, 따라서 이를 배제하기 위해 관리해야 할 파일을 명확히 알려줌 초기 환경 설정 git config –global user.name KiHyeon-Hong git config –global user.email ghdrlgus96@gmail.com git commit version : 모든 변화는 버전이 아니라 의미 있는 변화이다. 새로운 버전으로 만들기, 일정한 작업이 완결된 상태 git commit 후 commit message를 적어야 하는데 vim이므로 vim 입력방식대로 입력을 해야 한다. 123[master (root-commit) 4347df6] first commit 1 file changed, 1 insertion(+) create mode 100644 f1.txt 수정한 후 add 명령어를 항상 적어야지 버전 관리를 시작한다. 새로운 파일을 버전 관리 뿐만이 아니라 버전 관리가 되고 있는 파일을 수정하더라도 add를 해야 함 Changes not staged for commit : 수정 시 뜨는 메시지 (git status) git log 버전 생성된 것 확인(commit history 확인) git은 왜 add를 해야 하는가? commit 하나는 하나의 작업을 담는게 이상적이다. add를 통해서 commit 하고자 하는 것만 commit 할 수 있다. git add f1.txt를 하면 f1.txt는 stage에 올라감, commit 대기중인 파일들 stage - repository commit 결과는 repository commit에는 각각의 고유한 id가 있음 (commit 4347df685c78fe904d0363550936367d17851481) git log의 옵션들1git log -p 각 commit 사이의 소스 코드 차이를 보여준다. 1git log 4347df685c78fe904d0363550936367d17851481 이 commit 이전의 commit만 보인다. 1git diff 4347df685c78fe904d0363550936367d17851481..8d49b7cfa3e2c42d2be75e33169b640bbb48d8e9 두 commit 사이의 소스 차이를 보여준다. 파일 수정 후 git diff 시 : 현재 어떠한 작업이 진행되었는지 알 수 있음 -&gt; 자기가 작업한 내용이 마지막으로 리뷰할 수 있는 기회 (git add 시 git diff로 보이지 않음, 이전 commit과의 차이를 보여줌) 과거로 돌아가기 commit을 취소하는 명령어 현재의 log를 취소해서 과거로 돌아가기 reset vs revert reset 시 1git reset 8d49b7cfa3e2c42d2be75e33169b640bbb48d8e9 --hard 8d49b7cfa3e2c42d2be75e33169b640bbb48d8e9가 head로 바뀌며 이 이후의 commit이 사라짐 (–hard, –soft등 다양한 요소가 있음) git reset을 하더라도 실제로 삭제되지는 않고 복구가 가능 협업을 하게되면 원격저장소에 올라가는데 공유한 후에는 reset을 절대로 하면 안됨, 로컬에서만 reset을 써야함 git revert : 버전을 새로 만들면서 이전 commit으로 돌아간다 git commit –help git commit -a : 수정 및 삭제 파일은 자동으로 add 후 commit git commit -m “commit message” git commit -am “2” : 한번도 버전 관리, 즉 add를 하지 않은 파일을 제외하고 전부 add 후 메시지도 입력받지 않음","link":"/2021/02/18/Git-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/"},{"title":"Git 과거로 돌아가기","text":"Reset checkout 과거로 돌아가고 그 뒤에 있는 commit을 삭제하고 싶다. git reset –hard 490c7285a63e6531ea7d4b3eb3f95d0784c6066d HEAD인 refs/heads/master가 490c7285a63e6531ea7d4b3eb3f95d0784c6066d을 가리키게 된다. 그러나 정보는 최대한 지우지 않는다 reest 취소 방법 ORIG_HEAD 파일은 reset 전 head가 있다(현재 branch의 최신 commit, 즉 head가 가리키는 것을 저장) logs/refs/heads/master는 head 기록이 남는다 - 기록 역사(head 변경의 역사) git log –hard ORIG_HEAD : 기존의 head로 다시 돌아옴 git reflog : 각각의 commit들이 기록됨 checkout으로 돌아가는 법 checkout 뒤에다가 commit id를 직접 적을 수 있다 git checkout 490c7285a63e6531ea7d4b3eb3f95d0784c6066d 123You are in 'detached HEAD' state. You can look around, make experimentalchanges and commit them, and you can discard any commits you make in thisstate without impacting any branches by switching back to a branch. $ git branch (HEAD detached at 490c728) HEAD 파일을 보면 직접 commit id를 가리킴 다시 git checkout master를 통하여 돌아오면 됨","link":"/2021/02/21/Git-%EA%B3%BC%EA%B1%B0%EB%A1%9C-%EB%8F%8C%EC%95%84%EA%B0%80%EA%B8%B0/"},{"title":"Docker에서 Host IP 이용하기","text":"Docker에서 Host IP 이용하기 Docker에서 IP를 확인하면, Host IP가 아닌 Docker 컨테이너의 IP가 확인된다. 이를 해결하기 위해, Docker를 run 하는 과정에서 Docker의 IP를 Docker가 동작하고 있는 호스트의 IP로 매핑한다. 1docker run -p &lt;호스트포트&gt;:&lt;컨테이너포트&gt; -d &lt;이미지명&gt; 위와 같이 run을 사용하면, Docker의 IP는 매핑이 되지 않는다. 1docker run -p &lt;호스트포트&gt;:&lt;컨테이너포트&gt; -d --network=&quot;host&quot; &lt;이미지명&gt; Docker의 IP를 호스트의 IP로 매핑하기 위해 –network 플래그를 사용한다. 사용 예시 이를 테스트하기 위해, 간단한 코드를 작성한다. 해당 소스 코드는 Docker가 동작하고 있는 환경의 공인 IP와 사설 IP를 반환하는 웹 페이지를 작성한다. npm 모듈 환경 설정123npm i expressnpm i ipnpm i public-ip 소스 코드./index.js12345678910111213const express = require('express');const app = express();app.get('/', async (req, res, next) =&gt; { const ip = require('ip'); const publicIp = await import('public-ip'); res.send(`공인 IP: ${await publicIp.default.v4()}, 사설 IP: ${ip.address()}`);});app.listen(65011, () =&gt; { console.log(`Server running...`);}); ./Dockerfile1234567891011FROM node:16WORKDIR /usr/srcCOPY package*.json ./RUN npm installCOPY . .EXPOSE 65011CMD [ &quot;node&quot;, &quot;index.js&quot; ] ./.dockerignore12node_modulesnpm-debug.log 소스 코드 실행 Docker 이미지를 생성한다. 1docker build . -t testimage 실행 비교–network 플래그 미사용1docker run -p 65006:65006 -d testimage 플래그를 사용하지 않으면, 172.xx로 시작하는 Docker의 IP가 뜨는 것을 볼 수 있다. –network 플래그 사용1docker run -p 65006:65006 -d --network=&quot;host&quot; testimage 플래그를 사용한다면, 192.xx로 시작하는 호스트의 IP가 뜨는 것을 볼 수 있다.","link":"/2022/04/07/Docker%EC%97%90%EC%84%9C-Host-IP-%EC%9D%B4%EC%9A%A9%ED%95%98%EA%B8%B0/"},{"title":"Git 저장소 원리","text":"working copy &amp; index &amp; repository working directory(working tree, working copy), index(git add 시, staging area, chche), repository(commit이 저장, history, tree) git reset –hard하면 저장소, add, working까지 삭제됨 git reset –soft하면 repository만 삭제됨 git reset –mixed하면 레포지토리랑 add 삭제됨 git reset –soft 490c7285a63e6531ea7d4b3eb3f95d0784c6066d git diff : working copy와 index 비교 git reset –hard : 최신 커밋 상태로 바꿔버림 working copy까지","link":"/2021/02/21/Git-%EC%A0%80%EC%9E%A5%EC%86%8C-%EC%9B%90%EB%A6%AC/"},{"title":"HTTPS 시작하기","text":"HTTPS(HTTP Secure)는 HTTP 프로토콜의 암호화된 버전이다. 클라이언트와 서버 간의 모든 커뮤니케이션을 암호화하기 위해 SSL이나 TLS를 이용한다. 본 포스팅에서는 HTTPS 통신을 위해 SSL을 이용한다. OpenSSL 설치 http://slproweb.com/products/Win32OpenSSL.html 개발 및 테스트를 위해 OpenSSL을 다운로드하고 설치한다. 자신의 환경에 맞는 설치 파일을 다운로드하고 설치한다. Win64 OpenSSL v1.1.1L OpenSSL 환경 변수 설정 Path에 OpenSSL의 bin 폴더를 추가한다. 터미널에 openssl을 입력하여 다음과 같은 화면이 뜨면 설정 완료 1openssl 개인키와 공유키 생성 SSL 통신을 위해 개인키와 쌍을 이루는 공유키를 생성한다. 12openssl genrsa 1024 &gt; private.pemopenssl req -x509 -new -key private.pem &gt; public.pem HTTPS 프로토콜 사용 예시 Node.js를 이용한 HTTP 서버에서 HTTPS 서버로 변경한 예시 포트는 8080에서 3000으로 변경하였다. 개인키와 공유키를 받아온다. 123456789var http = require('http');var socketIO = require('socket.io');var fileServer = new nodeStatic.Server();var app = http .createServer(function (req, res) { fileServer.serve(req, res); }) .listen(8080); 12345678910111213// var http = require('http');const https = require('https');var socketIO = require('socket.io');const fs = require('fs');const options = { key: fs.readFileSync('./private.pem'), cert: fs.readFileSync('./public.pem') };var fileServer = new nodeStatic.Server();let app = https .createServer(options, (req, res) =&gt; { fileServer.serve(req, res); }) .listen(3000); HTTPS 서버 접속 예시 다음과 같이 https://localhost:3000을 이용하여 접속하는 것을 볼 수 있다.","link":"/2021/11/27/HTTPS-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/"},{"title":"Git 원리","text":".git directory git add 시 : index, objects directory가 변경됨 objects directory 내부에는 git add한 기록이 있으며, 이에 대한 자세한 내용은 index에 존재함index : 100644 8d49b7cfa3e2c42d2be75e33169b640bbb48d8e9 0 f1.txt cp 명령어로 파일을 복사할 경우 cp 명령어를 쓰면 같은 8d49b7cfa3e2c42d2be75e33169b640bbb48d8e9를 갖는다 -&gt; 같은 object를 갖는다 파일의 이름이 달라도 내용이 같으면 같은 object를 갖는다 내용이 a라면 같은 8d49b7cfa3e2c42d2be75e33169b640bbb48d8e9를 가질 것이다 (이 세상 누가 작성하더라도) objects 파일명과 원리SHA1 online -&gt; hash, 일정한 길이, git은 SHA1을 통과시켜서 hash값에서 2글자 빼고 objects 디렉터리를 만들고 그 나머지를 파일을 만들어서 정보를 저장한다. git add를 하면 git은 add한 파일의 내용과 부가적인 정보로 hash를 통과시키고 디렉터리와 파일을 만들고 그 정보를 저장한다음 index파일에서 이를 표시해준다. commit의 원리 git commit -m “1” 시 objects 디렉터리 안에 commit 정보가 저장, commit도 내부적으로는 객체 tree 8d49b7cfa3e2c42d2be75e33169b640bbb48d8e9 -&gt; 트리는 해당 버전의 파일의 이름과 그 내용 해쉬가 있음 parent에는 이전 commit을 볼 수 있음 각각의 버전은 그 버전이 만들었을 때의 스냅샷을 찍는다 objects 파일의 3가지 : 파일의 내용blob, 디렉터리 파일명과 파일명의 blob에 대한 정보tree, commit git status의 원리 index 파일은 무엇일까index와 최신 objects에 있는 commit을 비교 -&gt; 일치한다면 commit할 내용이 없음 index의 hash와 실제 디렉터리 hash가 다르면 수정되었음을 알림 add 하면 objects에 새로운 것이 생성되었고 index에 반영됨, 실제 파일과 hash는 같음, 그러나 가장 최신 커밋이 가리키는 f2.txt의 hash와는 다르므로 현재 f2.txt는 add되고 commit 대기 상태임을 알 수 있음 프로젝트 폴더(working directory, work tree), index, objects, 최신 commit이 전부 일치하면 commit할 것이 없다고 알려줌 working directory, work tree - index, staging area, cache - repository","link":"/2021/02/19/Git-%EC%9B%90%EB%A6%AC/"},{"title":"Googletrans 모듈을 이용한 번역 사이트","text":"Googletrans 설치하기 pip install googletrans는 오류가 발생하므로, 기존 버전을 설치하여야 한다. 1pip install googletrans==4.0.0-rc1 googletrans 테스트 한글을 영어로 바꾸는 예시와 영어를 한글로 바꾸는 예시를 테스트한다. 12345import googletranstranslator = googletrans.Translator()print(translator.translate(&quot;이것은 테스트 메시지 입니다.&quot;, src='ko', dest='en').text)print(translator.translate(&quot;This is a test message.&quot;, src='en', dest='ko').text) 12This is a test message.이것은 테스트 메시지입니다. flask 설치하기1pip install flask 간단한 번역 웹 페이지 소스 코드123456789101112131415161718from flask import Flask, requestimport googletransapp = Flask(__name__)translator = googletrans.Translator()@app.route('/ko2en')def ko2en(): str = request.args.get('str') return translator.translate(str, src='ko', dest='en').text@app.route('/en2ko')def en2ko(): str = request.args.get('str') return translator.translate(str, src='en', dest='ko').textif __name__ == '__main__': app.run(host='0.0.0.0', port=65001) 테스트 웹 페이지를 실행 후, 다음과 같이 접속을 테스트한다. http://localhost:65001/ko2en?str=사람입니다 1I am a person","link":"/2022/05/29/Googletrans-%EB%AA%A8%EB%93%88%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EB%B2%88%EC%97%AD-%EC%82%AC%EC%9D%B4%ED%8A%B8/"},{"title":"Git 원격 저장소","text":"GIT 원격 저장소 - Remote repository 원격 저장소에 올리기(backup. 협업) -&gt; 1대의 컴퓨터 안에서 원격 저장소 만드는 법, 이런 방법은 거의 활용하지도 않음 git init –bare remote –bare(작업을 할 수 없고 저장소로만 사용하겠다는 옵션으로 remote라는 디렉터리 생성), working 디렉터리가 없고 .git 내용만 있음, 수정같은 작업이 불가능 함, 원격 저장소 만들때는 bare 넣는다 git remote add origin /home/git/git/remote : origin이라는 별명으로 리모트 원격 저장소 연결함 git remote remove origin : origin 저장소를 지운다. git config –global push.default matching : git이 암시적으로 git config –global push.default simple : 새 버전부터 simple 방식으로 push 하는 것이 좋음 -&gt; 이에 대한 설정, 어디로 업로드 하겠다. git push origin master : origin 저장소에 master 브랜치를 저장한다 git push –set-upstream origin master : 앞으로 push는 origin에 master를 하겠다 Github 원격저장소는 구축하기 어렵기 때문에 제공해주는 서비스를 이용 그 중 대표적인 예가 Github -&gt; 오픈소스 프로젝트들의 작업장 이미 존재하는 오픈소스 가져오기 git/git : git에 대한 오픈소스 코드 commits : 지금까지 commit 횟수 branches : branch의 개수 contributes : 이 소스코드에 접근할 수 있는 사람들 watch : 지켜보는 사람들 star : 좋아요 수 fork : 해당 소스 코드를 내것으로 해서 수정이 가능(ghdrlgus96/git 이 된다) -&gt; fork의 수가 그 소스코드의 수준을 보여준다. git clone https://github.com/git/git.git gitsrc : gitsrc 이름으로 clone git log –reverse : log를 거꾸로 봄 -&gt; 첫번째 로그를 볼 수 있음 git checkout (해당 commit) : 해당 commit일때 상태로 이동 원격 저장소 만들기 new repository git init git add . git commit -m “1” git remote add origin https://github.com/ghdrlgus96/git.git : 원격 저장소(remote repository)를 연결 시키고 origin 이라는 별명을 부여하겠다. git remote : 원격저장소 확인 git remote -v : 상세 보기 작업한 내용을 여러 저장소를 remote로 해서 보낼 수 있다. git remote remove friend : friend remote 삭제 git push origin master : 현재 checkout 되어있는 브랜치를 origin의 master 브랜치를 서로 연결시킨다. git clone https://github.com/ghdrlgus96/git.git . git commit –amend : 최근 커밋의 메시지 변경 push 이후의 내용은 수정하지 말자 git push origin master //다른 로컬 저장소 git pull origin master : 가져오기(공재 저장소에서 가져오므로 비밀번호를 묻지 않음) git add . git commit -m “2” git push //다른 로컬 저장소 git pull … 지역 저장소에서 원격 저장소를 만들어 올리기 git init local cd local git commit -am “1” 원격 저장소 git init –bare remote cd remote 로컬 저장소 git remote add origin ssh://git@13.124.42.13/home/7. git/git/remote/ : ssh로 접속하는데 사용자 이름은 8. git git remote -v git push –set-upstream origin master 원격 저장소 git log 백업 및 동기화의 의미를 갖는다. git clone ssh://git@13.124.42.13/home/git/git/remote/ office push pull push 전에 로컬과 원격 저장소의 내용이 다르면 pull을 하고 push를 하라 분산관리 시스템 특징 : 로컬에서 버전관리 하다가 필요시 원격과 동기화 자주 pull, push를 하여 다른 사람의 push 기록을 자주 가져오도록 하자 pull - 작업 - push pull, push는 자주해야 충돌 가능성을 낮춘다. 원격 저장소 원리 git remote add origin git@github.com:ghdrlgus96/repo.git .git/config123[remote &quot;origin&quot;] url=git@github.com:ghdrlgus96/repo.git fetch =+refs/heads/*:refs/remotes/origin/* git push 1current branch master has no upstream breanch - 연결되어 있는 원격저장소 브랜치가 없다 git push –set-upstream origin master : origin의 master 브랜치에 연결 .git/config 123456[remote &quot;origin&quot;] url=git@github.com:ghdrlgus96/repo.git fetch =+refs/heads/*:refs/remotes/origin/*[branch &quot;master&quot;] remote=origin merge=refs/heads/master refs/remotes/origin/master 파일 origin으로 push한 commit이 무엇인가가 적혀있음 (원격 저장소의 master) refs/heads/master 지역 저장소의 master내용 둘이 같음 -&gt; 인터넷에서 가져온것이 아니라, 지역에서 마지막으로 원격으로 push 했던 기록일 뿐이다. git log –decorate –graph git pull, git fetchgit log –decorate –all –onelinepull 지역 저장소 master 브랜치와 원격저장소(origin)의 master의 브랜치가 같아짐 ORIG_HEAD는 이전 commit을 가리키고 있음 git fetch 지역저장소의 master 브랜치는 6, 원격저장소 origin의 master 브랜치는 7을 가리키고 있음 -&gt; merge되지 않음 ORIG_HEAD가 변하지 않음 원격 저장소로부터 받고 병합을 안하지 때문에 원격과 지역의 차이를 비교해 볼 수 있음 git diff HEAD origin/master : 최신 커밋과 원격의 최신을 비교 가능 git merge origin/master : git fetch 후 병합을 해야 함 git fetch -&gt; git merge origin/master","link":"/2021/02/21/Git-%EC%9B%90%EA%B2%A9-%EC%A0%80%EC%9E%A5%EC%86%8C/"},{"title":"Javascript Async, Await 공부","text":"http://junil-hwang.com/blog/javascript-promise-async-await/ Async, Await 간단 설명 async, await는 비동기로 실행되는 것을 끝날 때까지 기다리는 방법 (동기처럼 사용) async, await를 사용하기 위해 Promise를 사용한다. 간단한 Promise 코드 작성 promise는 Promise 객체를 반환하며, 1초 후 입력받은 값에 1을 더한 값을 반환한다. 12345678const cnt0 = 0;const promise = (v) =&gt; { return new Promise((resolve) =&gt; { setTimeout(() =&gt; { resolve(v + 1); }, 1000); });}; Async, Await를 사용하지 않은 Promise 기존의 비동기를 사용하듯이 promise를 사용하는 방법 무한 callback에 빠진다. 123456789promise(cnt0).then((cnt1) =&gt; { console.log(cnt1); promise(cnt1).then((cnt2) =&gt; { console.log(cnt2); promise(cnt2).then((cnt3) =&gt; { console.log(cnt3); }); });}); 적절한 체이닝을 이용하여 promise를 조작하는 방법 비동기라는 특성에서 완전히 벗어나지는 못한다. 123456789101112promise(cnt0) .then((cnt1) =&gt; { console.log(cnt1); return promise(cnt1); }) .then((cnt2) =&gt; { console.log(cnt2); return promise(cnt2); }) .then((cnt3) =&gt; { console.log(cnt3); }); Async, Await를 사용한 Promise Promise를 반환하는 함수의 앞에 await를 사용한다. await를 사용하는 함수 앞에는 async라는 키워드를 사용한다. resolve의 인자가 await 구문으로 반환된다. 12345678(async () =&gt; { const cnt1 = await promise(cnt0); console.log(cnt1); const cnt2 = await promise(cnt1); console.log(cnt2); const cnt3 = await promise(cnt2); console.log(cnt3);})();","link":"/2021/11/26/Javascript-Async-Await-%EA%B3%B5%EB%B6%80/"},{"title":"Javascript Promise 공부","text":"출처: https://github.com/azu 한빛출판네트워크, JavaScript Promise에서 중요 부분만 발췌 Promise.prototype.then promise.then(onFulfilled, onRejected); 1234567891011var promise = new Promise(function (resolve, reject) { resolve('이 값은 then()에 전달된다.');});promise.then( function (value) { console.log(value); }, function (error) { console.error(error); }); promise 객체에 대한 onFulfilled와 onRejected 콜백 함수를 정의하고 새로운 promise 객체를 반환한다. 이 함수는 promise 객체가 완료resolve 또는 실패reject될 때 각각 호출된다. 처리 로직에서 반환한 값은 새로운 promise 객체의 onFulfilled 콜백 함수에 전달한다. 처리 로직에서 오류가 발생하면 error 객체를 새로운 promise 객체의 onRejected 콜백 함수에 전달한다. Promise.prototype.catch promise.catch(onRejected); 12345678910var promise = new Promise(function (resolve, reject) { reject(new Error('error 객체는 catch()에 전달된다.'));});promise .then(function (value) { console.log(value); }) .catch(function (error) { console.error(error); }); Promise.resolve Promise.resolve(promise); Promise.resolve(thenable); Promise.resolve(object); 12345678910111213var taskName = 'task 1';asyncTask(taskName) .then(function (value) { console.log(value); }) .catch(function (error) { console.error(error); });function asyncTask(name) { return Promise.resolve(name).then(function (value) { return 'Done! ' + value; });} Fulfilled 상태의 promise 객체를 반환한다. 전달받은 값은 then()으로 등록한 콜백 함수에 전달된다. 어떤 경우에도 promise 객체를 반환하지만 크게 세 가지 케이스로 나눌 수 있다.● promise 객체를 전달받은 경우엔 전달받은 객체를 반환한다.● thenable 객체를 전달받은 경우엔 promise 객체로 변환해서 반환한다.● 다른 값(객체나 null 포함)을 전달받은 경우엔 새로운 promise 객체를 생성해 반환한다. Promise.reject Promise.reject(object) 12var r = Promise.reject(new Error('error'));console.log(r === Promise.reject(r)); // false Rejected 상태의 promise 객체를 생성해 반환한다. reject()에는 error 객체를 전달해야 한다. 전달받은 값은 catch()로 등록한 콜백 함수에 전달된다. resolve()와는 달리 항상 새로운 객체를 생성한다. Promise.all Promise.all(promiseArray); 123456var p1 = Promise.resolve(1), p2 = Promise.resolve(2), p3 = Promise.resolve(3);Promise.all([p1, p2, p3]).then(function (results) { console.log(results); // [1, 2, 3]}); 새로운 promise 객체를 생성해 반환한다. 배열로 전달한 promise 객체의 처리가 모두 완료됐을 때 새로운 promise 객체도 완료된다. 객체 중 하나라도 실패하면 새로운 객체도 실패한다. 배열의 값은 Promise.resolve()로 다뤄지기 때문에 promise 객체 이외의 값이 존재해도 정상적으로 동작한다. Promise.race Promise.race(promiseArray); 123456var p1 = Promise.resolve(1), p2 = Promise.resolve(2), p3 = Promise.resolve(3);Promise.race([p1, p2, p3]).then(function (value) { console.log(value); // 1}); 새로운 promise 객체를 생성해 반환한다. 배열로 전달한 promise 객체 중 하나만 완료되면 새로운 promise 객체도 완료된다.","link":"/2021/11/26/Javascript-Promise-%EA%B3%B5%EB%B6%80/"},{"title":"Javascript call, apply, 그리고 bind 공부","text":"https://www.youtube.com/watch?v=KfuyXQLFNW4&amp;list=PLZKTXPmaJk8JZ2NAC538UzhY_UNqMdZB4&amp;index=13 Call 모든 함수에서 사용할 수 있으며, this를 특정한 값으로 지정한다. 12345678910111213const mike = { name: 'Mike',};const tom = { name: 'Tom',};function showThisName() { console.log(this.name);}showThisName(); // errorshowThisName.call(mike); // Mike 첫 번째 매개 변수는 this로 사용할 값이며, 나머지 뒤의 매개 변수는 함수의 파라매터 123456function update(birthYear, occupation) { this.birthYear = birthYear; this.occupation = occupation;}update.call(mike, 1999, 'singer'); Apply 함수의 매개변수를 처리하는 방법을 제외하면 call과 완전히 동일하다. call은 일반적인 함수와 마찬가지로 매개 변수를 직접 받지만, apply는 매개변수를 배열로 받는다. 12345678update.apply(mike, [1999, 'singer']);const num = [3, 2, 1, 5, 4];// 동일한 결과를 갖는다.const min = Math.min(...num);const min = Math.min.apply(null, num);const min = Math.min.call(null, ...num); Bind 함수의 this 값을 영구히 바꾼다. 12const updateMike = update.bind(mike);updateMike(mike);","link":"/2021/11/26/Javascript-call-apply-%EA%B7%B8%EB%A6%AC%EA%B3%A0-bind-%EA%B3%B5%EB%B6%80/"},{"title":"Javascript promise, async, 그리고 await 공부1","text":"Javascript promise, async, and await studyState Pending -&gt; Fulfilled or Rejected Pending: 이행하지도, 거부하지도 않은 상태 Fulfilled: 연산이 성공적으로 완료됨 Rejected: 연산이 실패함 Producer and Consumers Promise를 생성할 때, 2개의 callback을 받는데, Resolve와 Reject이다. Promise는 생성되는 순간에 executer라는 callback 함수가 실행된다. 1234// 호출을 하지 않았지만, Promise가 생성됨과 동시에 실행되어 console.log가 출력된다.const promise = new Promise((resolve, reject) =&gt; { console.log('doing something');}); Promise는 Resolve나 Reject를 호출하지 안으면, 언제까지나 Pending 상태로 남아있다. Promise는 Promise를 리턴하기 때문에 then, catch, finally 등을 사용하여 값을 출력한다. 1234567891011// 1. Producerconst promise = new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { resolve('good!'); }, 1000);});// 2. Consumers: then, catch, finallypromise.then((value) =&gt; { console.log(value);}); Chaining Then은 Promise를 반환하기 때문에 다시 catch를 호출할 수 있다. 이때, then은 값(data)를 전달할 수 있으며, promise를 전달할 수도 있다. 추가적으로 finally는 성공과 실패 여부와 상관없이 실행된다. 12345678910111213141516const promise = new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { reject(new Error('network Error!')); }, 2000);});promise .then((value) =&gt; { console.log(value); }) .catch((error) =&gt; { console.log(error); }) .finally(() =&gt; { console.log('finally'); }); 12345Error: network Error! at Timeout._onTimeout (C:\\Users\\ghdrl\\Desktop\\Temp\\Code\\Study\\JavaScript\\AsyncAwaitStudy\\test.js:3:12) at listOnTimeout (node:internal/timers:557:17) at processTimers (node:internal/timers:500:7)finally Promise or data 전달 예제123456789101112131415161718const feachNumber = new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { resolve(1); }, 1000);});feachNumber // Promise 전달 .then((num) =&gt; num * 2) // 값 전달 .then((num) =&gt; num * 3) // 값 전달 .then((num) =&gt; { return new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { resolve(num - 1); }, 1000); }); }) // Promise 전달 .then((num) =&gt; console.log(num));// 2000ms 뒤 5 출력 Parameter 생략 만약, parameter를 함수에 그대로 넣어준다면, 식의 생략이 가능하다. 12345678910111213141516171819202122232425262728293031323334353637const add1 = (num) =&gt; { return new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { resolve(num + 1); }, 1000); });};const add2 = (num) =&gt; { return new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { resolve(num + 2); }, 1000); });};const add3 = (num) =&gt; { return new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { resolve(num + 3); }, 1000); });};add1(10) .then((sum) =&gt; add2(sum)) .then((sum) =&gt; add3(sum)) .then((sum) =&gt; { console.log(sum); });// Parameter 생략add1(10) // .then(add2) .then(add3) .then(console.log) .catch(console.log);","link":"/2022/02/08/Javascript-promise-async-%EA%B7%B8%EB%A6%AC%EA%B3%A0-await-%EA%B3%B5%EB%B6%801/"},{"title":"Javascript async, await와 반복문","text":"Async, Await와 반복문주의사항 Promise는 생성과 동시에 동작하고, pending 상태에서 fulfilled나 rejected 상태를 기다린다. fulfilled나 rejected 상태가 된다면, await나 then, catch 등을 이용하여 promise의 반환값을 즉시 받아올 수 있다. 따라서 다음과 같이 코드를 작성하면, 첫 반복문에서 promise가 1,000ms 기다린 후 로그가 출력되지만, 다음 반복문 부터, 이미 완료된 promise에서 값을 받아오기 때문에 1,000ms의 기다림 없이 즉시 실행된다.(network1은 1000ms후 fulfilled 상태가 되기 때문에, 처음 반복문 1회를 제외하고 기다릴 필요가 없다.) 1234567891011const network1 = new Promise((resolve) =&gt; { setTimeout(() =&gt; resolve('Success!'), 1000);});async function main() { for (let i = 0; i &lt; 10; i++) { console.log(await network1); }}main(); 이를 해결하기 위해 1,000ms마다 딜레이를 주고 싶다면, promise를 함수로 리턴한 후, 매 반복문 마다 새로운 promise를 생성하고 동작시켜야 한다. 12345678910111213const network2 = () =&gt; { return new Promise((resolve) =&gt; { setTimeout(() =&gt; resolve('Success!'), 1000); });};async function main() { for (let i = 0; i &lt; 10; i++) { console.log(await network2()); }}main();","link":"/2022/02/08/Javascript-async-await%EC%99%80-%EB%B0%98%EB%B3%B5%EB%AC%B8/"},{"title":"Javascript promise, async, 그리고 await 공부2","text":"Javascript promise, async, and await studyAsync 함수 앞에 async를 붙여주면 코드 블록이 Promise로 변화한다. 123456async function fetchUser() { return 'Good?';}console.log(fetchUser());// Promise { 'Good?' } Await await는 async가 붙은 함수 내에서만 사용할 수 있다. 1234567891011121314151617181920212223function sleep(ms) { return new Promise((resolve) =&gt; setTimeout(resolve, ms));}async function getNum100() { await sleep(3000); return 100;}async function getNum200() { await sleep(3000); return 200;}async function getNum300() { const num300 = (await getNum100()) + (await getNum200()); return num300;}// 6000ms 뒤 300 출력(async () =&gt; { console.log(await getNum300());})(); Await 병렬 연결하기 위 예졔는 하나의 await가 종료된 후에야 다음 await를 기다리기 때문에 6,000ms의 시간이 소요된다. 이를 해결하는 방법은 두 promise문을 동시에 실행할 수 있다. all(): 모든 promise가 끝나면 결과를 배열로 반환한다. race(): 가장 먼저 끝난 promise 결과 하나를 받아온다. 1234567891011121314151617181920212223242526function sleep(ms) { return new Promise((resolve) =&gt; setTimeout(resolve, ms));}async function getNum100() { await sleep(3000); return 100;}async function getNum200() { await sleep(3000); return 200;}async function getNum300() { return Promise.all([getNum100(), getNum200()]).then((datas) =&gt; { return datas.reduce((p, v) =&gt; { return p + v; }, 0); });}// 3000ms 뒤 300 출력(async () =&gt; { console.log(await getNum300());})();","link":"/2022/02/08/Javascript-promise-async-%EA%B7%B8%EB%A6%AC%EA%B3%A0-await-%EA%B3%B5%EB%B6%802/"},{"title":"Javascript 정규표현식 정리","text":"정규표현식이란? pattern과 flag를 이용한다. 1/regex?/i 사용법1/Hi/gm Hi와 정확히 일치하는 것을 찾는다. 1/Hi|Hello/gm Hi 또는 Hello와 정확히 일치하는 것을 찾는다. 1/(Hi|Hello)/gm 소괄호를 통해 묶어주면, match도 되고, group1에 Hi가 지정된다. 1/(Hi|Hello)|(to)/gm group1에는 Hi or Hello, group2에는 to와 일치하는 것을 찾으며, 없을 경우 undefined 1/((Hi|Hello)|(to))/gm group1은 Hi, Hello, to를 찾으며, group2에는 Hi or Hello, group3에는 to와 일치하는 것을 찾으며, 없을 경우 undefined 1/gr(e|a)y/ grey, gray를 찾는다. 이러할 경우 e, a가 그룹으로 묶이는데, 만약 그룹으로 묶고 싶지 않다면 그룹 앞에 ?:을 붙인다. 1/gr(?:e|a)y/ 1/gr[ae]y/ /gr(e|a)y/와 동일하며, 찾고싶은 문자열 집합체를 작성한다. 하나라도 만족하는 것을 찾는다. 1/gr[abcdef]y/ /gr[a-f]y/와 동일하다 1/gr[^a-f]y/ a부터 f까지를 제외한 문자열을 찾는다. Quantifiers1/gra?y/ ?는 없거나 있거나 이다. (gray, gry) 1/gra*y/ 없거나 있거나 많거나 이다. (gry, gray, graay, graaay) 1/gra+y/ 하나 있거나 많거나 이다. (gray, graay, graaay) 1/gra{2}y/ a가 2번 나오는 단어를 찾는다. (graay) 1/gra{2,3}y/ a가 2~3번 나오는 단어를 찾는다. (graay, graaay) 1/gra{2,}y/ a가 2번 이상 나오는 단어를 찾는다. (graay, graaay, graaaay) Boundary-type1/\\bYa/ \\b를 앞에 사용하면 단어의 맨 앞에서 나오는 Ya만 매칭한다. 1/Ya\\b/ \\b를 뒤에 사용하면 단어의 맨 뒤에서 나오는 Ya만 매칭한다. 1/\\BYa/ \\b를 앞에 사용하면 단어의 맨 앞에서 나오는 Ya만 빼고 전부 매칭한다. 1/Ya\\B/ \\b를 뒤에 사용하면 단어의 맨 뒤에서 나오는 Ya만 빼고 전부 매칭한다. 1/^Ya/ ^는 문장에서 시작하는 Ya를 찾는다. 1/Ya$/ $는 문장에서 끝나는 Ya를 찾는다. 이때 플래그의 멀티라인을 작성하지 않으면, 문장 전체에서 시작하는 Ya와 문장 전체에서 끝나는 Ya를 찾기 때문에 아무 것도 선택되지 않을 수도 있다. Character classes1/./ 줄바꿈 문자를 제외한 모든 문자열을 선택한다. 만약에 .를 진짜로 찾고 싶은것이라면, \\를 이용해야 한다. 1/\\./ 특수 문자인 경우에는 \\ 다음에 작성을 해야된다. 1/\\d/ 숫자를 전부 찾는다. 1/\\D/ 숫자를 제외하고 전부 찾는다. 1/\\w/ 문자를 전부 찾는다. 1/\\W/ 문자를 제외하고 전부 찾는다. 1/\\s/ 공백을 전부 찾는다. 1/\\S/ 공백을 제외하고 전부 찾는다. 자바스크립트에서 사용 방법1234const regex = /\\d/;const s = 'abcdefg';s.match(regex);","link":"/2022/01/27/Javascript-%EC%A0%95%EA%B7%9C%ED%91%9C%ED%98%84%EC%8B%9D-%EC%A0%95%EB%A6%AC/"},{"title":"Javascript 정규식 문법","text":"정규 표현식은 대 소문자를 구분함 정규 표현식은 띄어쓰기 개수를 구분함 ^who -&gt; who가 시작 위치에 있을 때 ^를 사용 who$ -&gt; who가 끝에 위치할 때 $를 사용 $12$ -\\ $25$ ^$ -&gt; $로 시작하는 것을 의미했더라도 $가 문자 끝을 의미해서 안됨 $ -&gt; \\는 그 기호 뒤에 따라오는 문자를 정규 표현식의 의미가 있는 문자가 아니라 단순한 문자로 바꿔줌 ^ -&gt; 단순한 문자열 ^$ -&gt; $가 처음 들어가는 문장을 의미함 $$ -&gt; $가 뒤에 들어가는 문장을 의미함 \\ -&gt; \\ 문자를 의미함 \\는 escape 문자라고 함 . -&gt; 모든 캐릭터를 매칭, 어떠한 문자 모든 것을 뜻함 …… -&gt; 어떠한 문자건 상관없이 6개의 문자를 의미 (6 덩어리씩 쪼개고 뒤에 남은 문자는 포함 안됨) . -&gt; . any character를 의미하는 의미가 아니라 .을 의미 ... -&gt; 문자. any character 문자.을 의미 (.K.) [] [oyu] -&gt; o나 y나 u를 찾는다 (first, all matches)에 따라 몇개인지 달라짐 [] 안에는 문자 하나하를 의미함 [dH]. -&gt; Ho 와 같이 d나 H 후 아무 문자 선택됨 [oyu][yow] -&gt; ow, yo 등이 추출됨 [-] -&gt; range [c-k] -&gt; c부터 k까지 범위의 문자 ([cdefghijk]와 같음) [2-6] -&gt; [23456] [c-k1-8] [^cdgh45] -&gt; [] 안의 ^는 not을 의미함, ABEF 등등이 추출됨 [^w-z] (on|ues|rida) -&gt; on, ues, rida 각각 1덩어리, 문자를 선택함 (Mon|Tues|Fri)day -&gt; (Monday|Tuesday|Friday) ..(id|esd|nd)ay -&gt; 앞의 아무 문자 2개까지 포함 Quantifiers -&gt; 수량자 *, +, ? a*b -&gt; a가 0 ~ 여러개, (ab, aab, b) a+b -&gt; a가 1 ~ 여러개, (aab, ab) a?b -&gt; a가 0 ~ 1개, (ab, b) .* -&gt; !@#$%^^&amp;&amp;등등 모든 텍스트 등등이 전부 선택 -A*- -&gt; - 앞에 A가 0 ~ 여러개, (–, -A-) [-@]* -&gt; (-@-, – 등등) *+ =&gt; (, \\*), *가 1개 이상이여야 함 -@+- -&gt; (-@@@-) @가 1개 이상있어야 함 [^ ]+ -&gt; 공백에 대한 부분이 아닌것이 전부 선택됨 -X?XX?X -&gt; (-XX) 등 -@?@?@?- -&gt; (–, -@-, -@@-, -@@@-) 원하는 수량 정하기 -&gt; {} .{5} -&gt; 모든 문자건 5글자여야 함, 만약에 12글자라면 5글자씩 2번 묶이고 2글자가 선택되지 않음 [els]{1,3} -&gt; 3개 이하 [a-z]{3,} -&gt; 3이상이란 의미 AB*A -&gt; AB{0,}A AB+A -&gt; AB{1,}A AB?A -&gt; AB{0,1}A r.* -&gt; *은 any character, r부터 모든 문자가 선택이 되어버림 r._? -&gt; 수량자 뒤에 ? 오면은 _?는 *는 최소인 0의 의미 (r) r.+? -&gt; +는 최소인 1의 의미가 됨, (ri, rk) r.?? -&gt; ?는 최소인 0을 의미 (r) .+ -> 비어있지 않은 div 태그 선택, 탐욕적인 수량자(Greedy) .+? -> lazy 선택자, 게으른 선택자 \\w -&gt; word = [A-z0-9_] \\w* [a-z]\\w* -&gt; (c3, d_4 등등) \\w{5} -&gt; 문자 5개 충족하면 추출 \\W -&gt; word가 아니다, 공백이랑 :, . @#$% 등이 선택됨 \\d -&gt; digit, (1, 123 등) \\D -&gt; 숫자가 아닌 것들 \\b. -&gt; 바운더리 \\B. \\A… -&gt; A는 시작점을 의미 시작에서 3문자 …\\Z -&gt; 맨끝에서 3문자 선택됨 ^과 \\A의 차이점 -&gt; multi line 시 \\A 하면 멅타라인이 있더라도 맨 앞 1개만 선택됨 \\w+(?=X) -&gt; ?=는 X를 문자를 검색하는 데에는 X를 쓰지만 선택은 하지 않음, (AAAX에서 AAA만 선택됨) \\w+(?=\\w) -&gt;","link":"/2021/02/11/Javascript-%EC%A0%95%EA%B7%9C%EC%8B%9D-%EB%AC%B8%EB%B2%95/"},{"title":"Javascript 정규표현식","text":"Javascript 정규표현식패턴 생성12let pattern = /a/;let pattern - new RegExp('a'); RegExp 객체의 정규 표현식RegExp.exec() 실행 결과는 문자열 a를 값으로 하는 배열을 리턴한다. a가 없다면 null을 리턴한다. 필요 정보 추출 12console.log(pattern.exec('abcdef')); // ['a']console.log(pattern.exec('bcdef')); // null RegExp.test() 정보가 존재하는지 확인 12console.log(pattern.test('abcdef')); // trueconsole.log(pattern.test('bcdef')); // false String 객체의 정규 표현식String.match()12345let str = 'abcdef';str.match(pattern); // ['a']let str = 'bcdef';str.match(pattern); // null String.replace()12let str = 'abcdef';str.match(pattern, 'A'); // 'Abcdef' 옵션i 대소문자를 구분하지 않는다. 12345let pattern = /a/;console.log('Abcdef'.match(pattern)); // nulllet pattern = /a/i;console.log('Abcdef'.match(pattern)); // ['A'] g 모든 결과를 반환한다. 12345let pattern = /a/;console.log('abcdefa'.match(pattern)); // ['a']let pattern = /a/g;console.log('abcdefa'.match(pattern)); // ['a', 'a']","link":"/2021/11/17/Javascript-%EC%A0%95%EA%B7%9C%ED%91%9C%ED%98%84%EC%8B%9D/"},{"title":"Javascript 정규표현식 정리2","text":"자바스크립트 정규표현식 메소드 exec: 대응되는 문자열을 찾는 RegExp 메소드, 정보를 가지고 있는 배열을 반환하며, 대응되는 문자열이 없을 경우 null을 반환 test: 대응되는 문자열이 있는지 검사하는 RegExp 메소드, true or false match: 대응되는 문자열을 찾는 string 메소드, 정보를 가지고 있는 배열을 반환하며, 대응되는 문자열이 없을 경우 null을 반환 search: 대응되는 문자열이 있는지 검사하는 string 메소드, 대응되는 부분의 인덱스를 반환, 없다면 -1 replace: 대응되는 문자열을 찾아 다른 문자열로 치환하는 string 메소드 split: 정규식 혹은 문자열로 대상 문자열을 나누어 배열로 반환하는 string 메소드 1234567var myRe = /d(b+)d/g;console.log(myRe.exec('cdbbdbsbz'));console.log(/d(b+)d/g.exec('cdbbdbsbz'));// 문자열 형태myRe = new RegExp('d(b+)d', 'g');console.log(myRe.exec('cdbbdbsbz')); index: 입력된 문자열에서 대응된 부분에 해당하는 인덱스 input: 입력된 원본 문자열 [0]: 마지막으로 대응된 문자열 lastIndex: 다음 검색 시 시작할 인덱스(g 옵션을 설정한 정규식에서만 가능) source: 패턴 문자열 123var myRe = /d(b+)d/g;var myArray = myRe.exec('cdbbdbsbz');console.log('The value of lastIndex is ' + myRe.lastIndex); 괄호로 둘러 싼 패턴 사용하기123456var re = /(\\w+)\\s(\\w+)/;var str = 'John Smith';var newstr = str.replace(re, '$2, $1');console.log(re.exec(str));console.log(newstr); 플래그 g: 전역 검색 i: 대소문자 구분 없는 검색 m: 다중행 검색 s: .에 개행 문자도 매칭 u: 유니코드, 패턴을 유니코드 코드 포인트의 나열로 취급 y: “sticky”검색을 수행. 문자열의 현재 위치부터 검색을 수행 12345var re = /\\w+\\s/g;var str = 'fee fi fo fum';var myArray = str.match(re);console.log(myArray); var re = /\\w+\\s/g; var re = new RegExp(“\\w+\\s”, “g”); 이 둘은 동일하다. str.match(re) re.exec(str) match와 exec는 사용방법이 다르다 12345678910111213var xArray;while ((xArray = re.exec(str))) console.log(xArray);console.log();console.log(re.exec(str));console.log(re.exec(str));console.log(re.exec(str));console.log(re.exec(str));console.log(re.exec(str));console.log(re.exec(str));console.log(re.exec(str));console.log(re.exec(str));console.log(); m 플래그는 여러 줄의 입력 문자열이 실제로 여러 줄로 다뤄져야 하는 경우에 사용함 만약 m 플래그가 사용되면 ^, $ 문자는 전체 문자열의 시작과 끝에 대응되지 않고, 각 라인의 시작과 끝에 대응됨","link":"/2022/01/28/Javascript-%EC%A0%95%EA%B7%9C%ED%91%9C%ED%98%84%EC%8B%9D-%EC%A0%95%EB%A6%AC2/"},{"title":"Node.js readline으로 입력 및 반환받기","text":"readline readline 모듈은 한 번에 한 줄씩 Readable 스트임에서 데이터를 읽기 위한 인터페이스를 제공한다. readline.createInterface()를 통해 생성 가능하며, close()를 통해 입력받는 것을 종료한다. 사용 예시한줄 씩 입력받기 한줄씩 입력 받으며, ‘quit’, ‘exit’, 그리고 ctrl + c 입력 때까지 반복한다. 123456789101112131415161718192021222324252627282930const readline = require('readline');const rl = readline.createInterface({ input: process.stdin, output: process.stdout,});function main() { rl.setPrompt(`Input data: `); rl.prompt();}rl.on('line', function (data) { switch (data) { case 'quit': case 'exit': rl.close(); } console.log(`Output data: ${data}\\n`); main();});rl.on('close', () =&gt; { console.log(); console.log('exit...'); process.exit();});main(); 일정 횟수 입력받기 5번 입력 받으며, 입력 종료 후 입력된 정보를 출력한다. 123456789101112131415161718192021222324252627282930313233343536373839404142const readline = require('readline');const rl = readline.createInterface({ input: process.stdin, output: process.stdout,});let question = ['첫 번째 질문', '두 번째 질문', '세 번째 질문', '네 번째 질문', '다섯 번째 질문'];let answer = [];let cnt = 0;function questionFunc() { rl.setPrompt(`${question[cnt]}: `); rl.prompt();}rl.on('line', function (data) { switch (data) { case 'quit': case 'exit': rl.close(); } answer.push(data); cnt++; if (cnt &lt; question.length) questionFunc(); else rl.close();});rl.on('close', function () { console.log(); question.map((v, i) =&gt; { console.log(`${v}에 대한 답: ${answer[i] === undefined ? '질문에 대답하지 않음' : answer[i]}`); }); process.exit();});questionFunc(); 입력 후 비동기 처리하기 입력된 정보를 일정 시간(5,000ms) 후 출력한다. 출력 후 다시 입력을 받도록 한다. 1234567891011121314151617181920212223242526272829303132333435363738const readline = require('readline');const rl = readline.createInterface({ input: process.stdin, output: process.stdout,});function main() { rl.setPrompt(`Input data: `); rl.prompt();}function asynchronous(data) { return new Promise((resolve) =&gt; { setTimeout(() =&gt; { return resolve(data); }, 5000); });}rl.on('line', async function (data) { switch (data) { case 'quit': case 'exit': rl.close(); } console.log(`Output data(5,000ms...): ${await asynchronous(data)}\\n`); main();});rl.on('close', () =&gt; { console.log(); console.log('exit...'); process.exit();});main();","link":"/2022/01/27/Node-js-readline%EC%9C%BC%EB%A1%9C-%EC%9E%85%EB%A0%A5-%EB%B0%8F-%EB%B0%98%ED%99%98%EB%B0%9B%EA%B8%B0/"},{"title":"Node.js 비대칭키 암호화 사용하기","text":"비대칭키 암호화 알고리즘 예시 crypto 내장 모듈을 이용한 비대칭키 암호화 알고리즘을 사용한다. 12345678910111213141516171819202122232425262728293031323334353637383940const crypto = require('crypto');const fs = require('fs');const { publicKey, privateKey } = crypto.generateKeyPairSync('rsa', { modulusLength: 2048, publicKeyEncoding: { type: 'pkcs1', format: 'pem', }, privateKeyEncoding: { type: 'pkcs1', format: 'pem', },});const data = 'My secret data';const encryptedData = crypto.publicEncrypt( { key: publicKey, padding: crypto.constants.RSA_PKCS1_OAEP_PADDING, oaepHash: 'sha256', }, data);const decryptedData = crypto.privateDecrypt( { key: privateKey, padding: crypto.constants.RSA_PKCS1_OAEP_PADDING, oaepHash: 'sha256', }, encryptedData);console.log('encypted data: ', encryptedData.toString('base64'));console.log('decrypted data: ', decryptedData.toString());fs.writeFileSync('./public.pem', publicKey);fs.writeFileSync('./private.pem', privateKey); 출력 결과는 다음과 같다. 12encypted data: eae/p7QrC2SePZMbHGPb1SYjkK3CIbdeoFwTXQ/bozinpyJONGPVAT4333unFb80mp2grZ7ZdySnXvcH7vIAkRsc5jBPoHqszoWFLAitWv6djDiZrmD/azI0U7d0bFcoKDpa2jjCt19V4leDG58ROwxSDvAIJ1KB6zvyhIf+1GghG0FKjXS64hwIN+noAW6cBZqKREhPULP/ayG8H0lFpK5WHFNWmgbxIwFvEK3tKqhj+N+cCy2dCxRV/jDbeOrjVdt4UHv3lC5F6LVX4q0hDGQHWmD2AFpduBhYa7sZ9S59haMZ7/4PGUq01TyCTA/bH1PZuJgUWLqRyeaoujXXRQ==decrypted data: My secret data 공개키, 개인키 파일 저장된 공개키 파일은 다음과 같다 12345678-----BEGIN RSA PUBLIC KEY-----MIIBCgKCAQEAuXFoJvFMZ98kRrYXYjA0B/giRYis5qrbYmlHaZ1n3mXdtZzclsqMQwiPLwZAYgICNNHwqaehTEUTVuMyk4Zo8IuL+hY2UJBXYjodTFoVruJlWr+mio+rjUXi6VZLpEBdyIjq3WKrxzIhCK10juAUqTOh7NS+JGFZA+Npo0k8rf3TQXtaebsnwvovmcZvGJOgUkflfY03B2QBjvYTc8DI67y69n6a5LeoH8hbBcbM4STkv2k+wIuNuEURb8DTaLdbp45wgKWrE4Wk4eEaKvueXCDGMF2tVkZEsZqgQceosJcp2Uvs5NFj6xF6Co+f/fTJcen03cggzMjpjMCXzYpArQIDAQAB-----END RSA PUBLIC KEY----- 저장된 개인키 파일은 다음과 같다. 123456789101112131415161718192021222324252627-----BEGIN RSA PRIVATE KEY-----MIIEogIBAAKCAQEAuXFoJvFMZ98kRrYXYjA0B/giRYis5qrbYmlHaZ1n3mXdtZzclsqMQwiPLwZAYgICNNHwqaehTEUTVuMyk4Zo8IuL+hY2UJBXYjodTFoVruJlWr+mio+rjUXi6VZLpEBdyIjq3WKrxzIhCK10juAUqTOh7NS+JGFZA+Npo0k8rf3TQXtaebsnwvovmcZvGJOgUkflfY03B2QBjvYTc8DI67y69n6a5LeoH8hbBcbM4STkv2k+wIuNuEURb8DTaLdbp45wgKWrE4Wk4eEaKvueXCDGMF2tVkZEsZqgQceosJcp2Uvs5NFj6xF6Co+f/fTJcen03cggzMjpjMCXzYpArQIDAQABAoIBAG3si5CJ+ICaBSblSXcqm60dqTMOkW8qWGE9htdUNv3d5E6DbT71Ua9qo3V8fy2ZgzVMPRxUAYj0aUJX6uMICayNC6xy/j9DUIkpabSYscG48duZP19jSo2zn44xWSVEAlOc1ZvloW2yiWJbb3xB1/10XcfFU/C8w8dKRpREFXQMv5qYFqZchq2WU3iVSDpivIXW2Ee/Kxs/eWh3BCnb/J6tpFBa9oqt/eS1SohKQuJ9Zcea6qukTwv3RsSrnNOGCyCeJWoqddaL0hCHsRrtvn+02/J8t6FOrfXEytM/Vobdq+NivrpGXSfXmJksG6PKBFZted/7joSiMj73sCRLCAECgYEA2/O0qG7JuFppnOQc8BJxomGKt6gWzJiy1XaK/ufiCwVOIXA22PTLOBKJrSZ8n8a2y4odzO+vlq408nMgP63nWB+zu99PdIi6g6FRAHLsVPX0p12UBsZn0DYnte1hxPJ1kZgejTpxtxjTENXY7+MWpYnZEx+5CBZ+XD4VgYhug3UCgYEA19XYFZXIOp+fU8Vrfn+7/UBSR1vYWPd6oX/ZSKBS4+R3b8jrxXwf1ZHB8+XmkgcHI0wQfZTfX7xrhDuOpJrzqQWvOdjnFTey0p7dRO5C/nNUbQJIUZfXL0lZL1ZwlGncGAlpCXAjofkeWveHhqtHT/nfbhhh38ZrFigDV+DDuVkCgYBHo+851Sv60egIY/xQ7ZD5lM+71hHm/e1xvbS0Jg7oDAhQt94FeGYgk1kofpqk5/JuBUSDlaYZbBBuz7S3SQtLFrhR/wBAMrCdYxOhE82KNrpDMSWft0vk816n0PPBVD+a9nMtCNY1Du7gUubf65VawbVklzaLPdhWbxpOIIPuaQKBgEvZS5myTG5FoCE5VKBc1TyXeRK4tRv2xHKy0jISnW6W4F45VpnNGAbetTE4DsIslBaUaYsoYSNsvL/4ihVQmuZAKCcFEZhEPaSEza+mp4ZyEy5HyhBacvWcKipXjzKozP7pd68oaG1IdaF0MX1i/ameXyV6jhKs0P81So98XmvpAoGAajtrMPz48KnlAk+vFtA6i1E85k25rHf9WMTItv/N4iRvkYYBlEkXwgg6nKlDX71llcYFCm9s509KbjeKWLt68XE+lDvuAPL0ippvndpfhUAiJgD5NM2YI1/eiWqq3/B8k4FIGqh9h44cJX2eoxFxYrHc2tEJcBU1Ma5D8AuHBKs=-----END RSA PRIVATE KEY-----","link":"/2022/03/13/Node-js-%EB%B9%84%EB%8C%80%EC%B9%AD%ED%82%A4-%EC%95%94%ED%98%B8%ED%99%94-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0/"},{"title":"Node.js 비대칭키 암호화를 이용한 데이터 전송하기","text":"비대칭키 암호화를 이용한 데이터 안전하게 전송하기 /createKey에 요청하여, 서버에서 개인키와 공개키를 생성하며, 공개키를 받아온다. 전송할 데이터를 공개키로 암호화하며, /useKey에 전송한다. 서버에서는 요청된 데이터를 개인키로 복호화한다. Server code123456789101112131415161718192021222324252627282930313233343536373839404142434445const express = require('express');const bodyParser = require('body-parser');const crypto = require('crypto');const fs = require('fs');const app = express();app.use(express.json());app.use(bodyParser.urlencoded({ extended: true }));app.get('/createKey', (req, res, next) =&gt; { const { publicKey, privateKey } = crypto.generateKeyPairSync('rsa', { modulusLength: 2048, publicKeyEncoding: { type: 'pkcs1', format: 'pem', }, privateKeyEncoding: { type: 'pkcs1', format: 'pem', }, }); fs.writeFileSync(__dirname + '/public.pem', publicKey); fs.writeFileSync(__dirname + '/private.pem', privateKey); res.json({ publicKey: publicKey });});app.post('/useKey', (req, res, next) =&gt; { const privateKey = fs.readFileSync(__dirname + '/private.pem', 'utf8'); const decryptedData = crypto.privateDecrypt( { key: privateKey, padding: crypto.constants.RSA_PKCS1_OAEP_PADDING, oaepHash: 'sha256', }, Buffer.from(req.body.encryData, 'base64') ); console.log(decryptedData.toString()); res.send(decryptedData.toString());});app.listen(65001, () =&gt; { console.log(`Server running at 65001...`);}); Client code123456789101112131415161718192021222324252627282930const request = require('request');const fs = require('fs');const crypto = require('crypto');request.get('http://localhost:65001/createKey', function (error, response, body) { const publicKey = JSON.parse(body).publicKey; fs.writeFileSync(__dirname + '/public.pem', publicKey); const myData = 'This is secret data!'; const encryptedData = crypto.publicEncrypt( { key: publicKey, padding: crypto.constants.RSA_PKCS1_OAEP_PADDING, oaepHash: 'sha256', }, myData ); const options = { uri: 'http://localhost:65001/useKey', method: 'POST', form: { encryData: encryptedData.toString('base64'), }, }; request.post(options, function (error, response, body) { console.log(body); });});","link":"/2022/03/13/Node-js-%EB%B9%84%EB%8C%80%EC%B9%AD%ED%82%A4-%EC%95%94%ED%98%B8%ED%99%94%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%A0%84%EC%86%A1%ED%95%98%EA%B8%B0/"},{"title":"NodeJS 기반의 공인 아이피, 사설 아이피 사용하기","text":"Node.js를 이용한 공인 아이피와 사설 아이피 확인12npm i ipnpm i request 1234567const request = require('request');const ip = require('ip');request.get({ url: 'https://api.ipify.org' }, function (_1, _2, body) { console.log('Public IP address &gt; ' + body); console.log('Virtual IP address &gt; ' + ip.address());}); API를 이용하지 않는 방법 특정 사이트에서 가져오는 데이터는 의존성을 갖는다. 따라서, request 대신 npm 모듈을 이용한다. 1npm i public-ip SyntaxError: Cannot use import statement outside a module 에러 Node.js의 모듈은 크게 commonjs와 module로 구분할 수 있다. 이는 임포트 방식이 다르며, 이를 위해 package.json에서 module로 인식할 수 있게 변경하여야 한다. 123456789{ ... &quot;dependencies&quot;: { &quot;ip&quot;: &quot;^1.1.5&quot;, &quot;public-ip&quot;: &quot;^5.0.0&quot;, &quot;request&quot;: &quot;^2.88.2&quot; }, &quot;type&quot;: &quot;module&quot;} 다음과 같이 package.json에 “type”: “module”를 추가한다. 임포트 방식 변경 이 방식으로 변경한 기존의 코드는 다음과 같다. 1234567import request from 'request';import ip from 'ip';request.get({ url: 'https://api.ipify.org' }, function (_1, _2, body) { console.log('Public IP address &gt; ' + body); console.log('Virtual IP address &gt; ' + ip.address());}); request 모듈을 사용하지 않는 방식은 다음과 같다. 12345import publicIp from 'public-ip';import ip from 'ip';console.log('Public IP address &gt; ' + (await publicIp.v4()));console.log('Virtual IP address &gt; ' + ip.address());","link":"/2021/11/14/NodeJS-%EA%B8%B0%EB%B0%98%EC%9D%98-%EA%B3%B5%EC%9D%B8-%EC%95%84%EC%9D%B4%ED%94%BC-%EC%82%AC%EC%84%A4-%EC%95%84%EC%9D%B4%ED%94%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0/"},{"title":"Node.js 해시 알고리즘 사용하기","text":"crypto Node.js 내장 모듈이다. sha256 외부 설치가 필요한 모듈이다. 1npm install sha256 사용 예시 동일한 문자열을 해시화하였을 경우, crypto와 sha256의 결과가 동일한 것을 확인할 수 있다. 123456const crypto = require('crypto');const sha256 = require('sha256');// console.log(crypto.createHash('sha256').update('My secret data').digest('base64'));console.log(crypto.createHash('sha256').update('My secret data').digest('hex'));console.log(sha256('My secret data')); 123// vYkFldR7nnRtfG5x/2UMk73C/oHtvcumeyCDSZNHFNk=bd890595d47b9e746d7c6e71ff650c93bdc2fe81edbdcba67b208349934714d9bd890595d47b9e746d7c6e71ff650c93bdc2fe81edbdcba67b208349934714d9","link":"/2022/03/13/Node-js-%ED%95%B4%EC%8B%9C-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0/"},{"title":"PyScript를 이용하여 HTML에서 python 실행하기","text":"참고 자료 https://www.youtube.com/watch?v=3DuyJf_XPtM PyScript PyScript는 프레임워크로 HTML에서 python을 이용하여 다이나믹 어플리케이션을 빌드할 수 있게 하는 도구이다. 이벤트를 이용한 기본 예제 코드 index.html에서 숫자를 선택하고 버튼을 클릭하면, 이벤트가 발생하여 main.py의 메소드가 실행된다. main.py에서는 동작을 수행하고, 결과는 index.html 태그에 결과 메시지를 저장한다. index.html12345678910111213141516&lt;!DOCTYPE html&gt; &lt;head&gt; &lt;script defer src=&quot;https://pyscript.net/alpha/pyscript.js&quot;&gt;&lt;/script&gt; &lt;link rel=&quot;stypesheet&quot; href=&quot;'https://unpkg.com/@picocss/pico@latest/css/pico.min.css&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;py-script src=&quot;./main.py&quot;&gt;&lt;/py-script&gt; &lt;main class=&quot;container&quot;&gt; &lt;div&gt; &lt;input type=&quot;number&quot; id=&quot;number_input&quot; min=&quot;1&quot; max=&quot;50&quot; placeholder=&quot;Guess a number 1 and 50&quot; /&gt; &lt;button id=&quot;add_todo&quot; pys-onClick=&quot;play_game&quot; &gt;Guess&lt;/button&gt; &lt;/div&gt; &lt;h1 id=&quot;result&quot;&gt;&lt;/h1&gt; &lt;/main&gt; &lt;/body&gt;&lt;/html&gt; main.py123456789101112131415import randomnumber_input = Element(&quot;number_input&quot;)result = Element(&quot;result&quot;)def play_game(*args): user_guess = number_input.value machine_guess = random.randint(1, 50) if int(user_guess) == machine_guess: result.element.innerText = &quot;You Win!&quot; else: result.element.innerText = f&quot;You Lost! The machine chose {machine_guess}!&quot; number_input.clear() 실행 결과 처음 실행 화면은 다음과 같다. 1 ~ 50까지 선택한 숫자와 컴퓨터가 선택한 숫자가 일치하지 않는 경우 다음과 같은 메시지가 출력된다. 1 ~ 50까지 선택한 숫자와 컴퓨터가 선택한 숫자가 일치할 경우 다음과 같은 메시지가 출력된다. Python의 외부 모듈 이용하기 numpy와 같은 외부 모듈을 import하여 사용할 수 있다. 1234567891011121314&lt;html&gt; &lt;head&gt; &lt;title&gt;Matplotlib&lt;/title&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://pyscript.net/alpha/pyscript.css&quot; /&gt; &lt;script defer src=&quot;https://pyscript.net/alpha/pyscript.js&quot;&gt;&lt;/script&gt; &lt;py-env&gt; - matplotlib &lt;/py-env&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;mpl&quot;&gt;&lt;/div&gt; &lt;py-script output=&quot;mpl&quot;&gt; import matplotlib.pyplot as plt plt.plot([1, 2, 3, 4], [10, 20, 40, 30]) plt &lt;/py-script&gt; &lt;/body&gt;&lt;/html&gt; 실행 결과 실행 결과는 다음과 같다.","link":"/2022/05/29/PyScript%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%98%EC%97%AC-HTML%EC%97%90%EC%84%9C-python-%EC%8B%A4%ED%96%89%ED%95%98%EA%B8%B0/"},{"title":"Python 가상환경 설정하기","text":"파이썬 가상환경 파이썬의 venv 모듈은 자체 사이트 디렉터리를 갖는 경량 가상 환경을 만들고, 선택적으로 시스템 사이트 디렉터리에서 격리할 수 있도록 지원한다. 명령프롬프트에서 다음을 입력한다. 12345# 기본 명령어python -m venv venv# 현재의 파이썬 전역 패키지들을 설치python -m venv 가상환경이름 --system-site-packages 가상환경 접속Windows1venv\\Scripts\\activate.bat 1(venv) C:\\Users\\user&gt; MacOS1source venv/bin/activate 1(venv) kihyeon-hong@KiHyeon-Hong-MacBookPro Python_virtual % 가상환경이 활성화되었다. 주피터 노트북을 사용하기 위한 환경설정 주피터 노트북을 이용하기 위해 jupyter 모듈을 설치한다. 추가적으로 사용할 다양한 라이브러리를 설치한다. 1234pip3 install jupyterpip3 install matplotlib... 주피터 노트북 실행 명령어1python -m notebook 추후 접속하기 가상환경에 설치된 주피터 노트북을 실행하기 위해서는 다음 두 명령어를 입력한다. 12venv\\Scripts\\activate.batpython -m notebook 12source venv/bin/activatepython -m notebook 가상환경 삭제 가상환경의 삭제는 설치된 ‘venv’ (가상환경 디렉터리 이름) 디렉터리 자체를 그냥 삭제해주면 된다.","link":"/2022/01/27/Python-%EA%B0%80%EC%83%81%ED%99%98%EA%B2%BD-%EC%84%A4%EC%A0%95%ED%95%98%EA%B8%B0/"},{"title":"Raspberry Pi 4 gpio 시작하기","text":"Node.js 설치12345678910111213141516$ mkdir download$ cd download$ wget https://nodejs.org/dist/v8.11.4/node-v8.11.4-linux-armv7l.tar.xz$ tar -xvf node-v8.11.4-linux-armv7l.tar.xz$ cd node-v8.11.4-linux-armv7l$ sudo cp -R * /usr$ cd ../..$ node -vV8.11.4$ npm -v5.6.0$ gpio -vgpio version: 2.46 Raspberry Pi 4에서의 에러1$ gpio readall // error Raspberry Pi 3에서는 실행되는 명령어 Raspberry Pi 4에서는 에러가 발생 이는 루트 계정으로 접속하여 wiringpi를 업데이트 해준다. 123$ su$ wget https://project-downloads.drogon.net/wiringpi-latest.deb$ sudo dpkg -i wiringpi-latest.deb 루트 계정으로 접속하지 않으면 권한때문에 다운로드가 불가능하다. 12$ gpio readall$ exit gpio 테스트 Raspberry Pi 4에 LED를 연결 후 테스트 1$ npm install node-wiring-pi 123456789101112131415161718192021const gpio = require('node-wiring-pi');const LEDPIN = 29;var count = 0;const TimeOutHandler = function () { if (count &gt; 0) { gpio.digitalWrite(LEDPIN, 1); console.log('Node: LED on'); count = 0; } else { gpio.digitalWrite(LEDPIN, 0); console.log('Node: LED off'); count = 1; } setTimeout(TimeOutHandler, 1000);};gpio.setup('wpi');gpio.pinMode(LEDPIN, gpio.OUTPUT);setTimeout(TimeOutHandler, 1000);","link":"/2021/11/15/Raspberry-Pi-4-gpio-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/"},{"title":"Raspberry Pi 4 초기 세팅하기","text":"Download http://www.etcher.io https://www.raspberrypi.org/downloads/raspbian 중요 설정1$ sudo raspi-config 12345678910111213141516171819202122231. System Options S5. Boot / Auto Login Select boot into desktop or to command line B4. Desktop Autologin Desktop GUI, automatically logged in as 'pi' user3. Interface Options P2. SSH -&gt; Yes P5. I2C -&gt; Yes5. Localisation Options L1. Locale en_GB.UTF-8 UTF-8 en_US.UTF-8 UTF-8 ko_KR.UTF-8 UTF-8 ko_KR.UTF-8 UTF-8 -&gt; Ok L2. TimeZone Asia/SeoulFinish -&gt; Reboot? -&gt; No 언어 설정12345$ sudo apt-get install ibus$ sudo apt-get -y install ibus-hangul$ sudo apt-get -y install fonts-unfonts-core$ sudo reboot root 계정 암호 설정 su 명령어를 사용하기 위해 필수적으로 설정 12345$ sudo passwd root새 UNIX 암호:$exit","link":"/2021/11/15/Raspberry-Pi-4-%EC%B4%88%EA%B8%B0-%EC%84%B8%ED%8C%85%ED%95%98%EA%B8%B0/"},{"title":"Raspberry Pi mysql 비밀번호 설정 오류","text":"root 비밀번호 설정 오류 https://kihyeon-hong.github.io/2021/11/15/Raspberry-Pi-mysql-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/ 기존의 방식으로 root 비밀번호를 설정하는 과정에서 오류가 발생한다. 1ERROR 1356 (HY000): View 'mysql.user' references invalid table(s) or column(s) or function(s) or definer/invoker of view lack rights to use them 이는 MariaDB-10.4+에서 user가 table이 아니라 view로 변경되어 발생하는 오류이다. 오류 수정 다음의 명령어로 root의 password hash 값이 변경되는 것을 확인할 수 있다. 이를 적용한다. 123set password for root@'localhost' = PASSWORD('gachon654321');flush privileges;exit 변경 확인12sudo systemctl restart mariadb.servicemysql -u root -p 잘못된 비밀번호를 입력하면, 접속이 거부되며, 올바른 비밀번호로 접속이되는 것을 확인할 수 있다. 이때, 주의할 점은 sudo 명령어로 mysql 접속을 시도할 경우 잘못된 비밀번호를 입력하더라도 접속이 허용될 수 있다.","link":"/2022/02/12/Raspberry-Pi-mysql-%EB%B9%84%EB%B0%80%EB%B2%88%ED%98%B8-%EC%84%A4%EC%A0%95-%EC%98%A4%EB%A5%98/"},{"title":"Raspberry Pi mysql 시작하기","text":"mysql 설치1$ sudo apt-get install mariadb-server mysql 설정123$ cd /etc/mysql/mariadb.conf.d$ sudo cp 50-server.cnf server.cnf.backup$ sudo vi 50-server.cnf bind-address = 127.0.0.1를 주석처리 한다. 1# bind-address = 127.0.0.1 mysql 시작하기123$ sudo systemctl restart mariadb.service$ cd -$ sudo mysqladmin -u root password 'gachon654321' 12345678910$ sudo mysql -u root -pEnter password: *MariaDB &gt; set password for root@localhost = password('gachon654321');MariaDB &gt; use mysql;MariaDB &gt; update user set authentication_string=password(''), plugin='mysql_native_password' where user='root';MariaDB &gt; flush privileges;MariaDB &gt; exit$ mysql -u root -pEnter password: *MariaDB &gt; 비밀번호 설정 오류 MariaDB-10.4+에서는 user가 table이 아니라 view가 되어 에러가 발생한다. 1ERROR 1356 (HY000): View 'mysql.user' references invalid table(s) or column(s) or function(s) or definer/invoker of view lack rights to use them 이는 다음과 같이 수정한다. https://kihyeon-hong.github.io/2022/02/12/Raspberry-Pi-mysql-%EB%B9%84%EB%B0%80%EB%B2%88%ED%98%B8-%EC%84%A4%EC%A0%95-%EC%98%A4%EB%A5%98/ mysql 테스트 추후 진행할 9축센서 데이터를 이용한 충격감지 알고리즘 개발을 위한 데이터베이스 생성 12create database 9axisdb;use 9axisdb; 123456create table ShockData(time datetime(3), shocklevel int, shockdirection int, azimuthshockdirection int, shockvalue float, degree int, azimuth int, code int, message varchar(256));create table Log(time datetime(3), log varchar(256));desc ShockData;desc Log;","link":"/2021/11/15/Raspberry-Pi-mysql-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/"},{"title":"Raspberry Pi 모니터 없이 ssh와 wifi 설정하기","text":"Raspberry Pi의 한계점 라즈베리 파이를 처음 설치한 후 ssh 접속을 위해서는 무선 연결, 또는 유선 연결을 하여야 한다. 또한, 무선 연결이나 유선 연결을 한 후 IP주소를 알아야 한다. 이는 만약에 모니터가 없거나 Serial 케이블이 없다면 알 수 있는 방법이 없다. 이를 해결하기 위해 라즈베리 파이의 파일 설정하는 방법을 알아야 한다. ssh 활성화 초기설정을 아직 진행하지 않은 Raspbian이 설치된 SD카드를 데스크탑에 연결한다. 포맷은 진행하지 않으며, 데스크탑에 연결할 경우 boot 파티션이 나타난다. boot 디렉터리에서 확장자 없이 ssh 파일을 생성한다. wifi 설정 초기설정을 아직 진행하지 않은 Raspbian이 설치된 SD카드를 데스크탑에 연결한다. 포맷은 진행하지 않으며, 데스크탑에 연결할 경우 boot 파티션이 나타난다. boot 디렉터리에서 확장자 없이 wpa_supplicant.conf 파일을 생성한다. 라즈비안 최신 버전인 ‘Stretch’의 경우 123456ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdevnetwork={ ssid=&quot;접속하고자 하는 wifi 이름&quot; psk=&quot;접속하고자 하는 wifi 비밀번호&quot; key_mgmt=WPA-PSK} 그 이전 버전 12345network={ ssid=&quot;접속하고자 하는 wifi 이름&quot; psk=&quot;접속하고자 하는 wifi 비밀번호&quot; key_mgmt=WPA-PSK} 다음과 같은 결과가 나타난다. ssh 접속 후 wifi 설정1sudo vi /etc/wpa_supplicant/wpa_supplicant.conf priority가 높은 것을 먼저 시도한다. 12345678910111213network={ ssid=&quot;~&quot; psk=&quot;~&quot; priority=1 key_mgmt=WPA-PSK}network={ ssid=&quot;~&quot; psk=&quot;~&quot; priority=2 key_mgmt=WPA-PSK}","link":"/2022/01/27/Raspberry-Pi-%EB%AA%A8%EB%8B%88%ED%84%B0-%EC%97%86%EC%9D%B4-ssh%EC%99%80-wifi-%EC%84%A4%EC%A0%95%ED%95%98%EA%B8%B0/"},{"title":"Raspberry Pi 부팅 시 IP 주소 서버로 전송하기","text":"개요 라즈베리 파이가 부팅이 될 시, 실행 중인 서버로 IP 주소를 전송한다. 이를 위해, Node.js 기반의 Express.js와 Request 모듈을 이용한다. 서버 소스 코드 이를 위해, npm 모듈을 설치한다. 12npm i expressnpm i body-parser 소스 코드를 작성한다. 123456789101112131415161718192021222324252627const express = require('express');const bodyParser = require('body-parser');const fs = require('fs');const app = express();app.use(express.json());app.use(bodyParser.urlencoded({ extended: false }));fs.writeFileSync('log.txt', '', 'utf8');app.get('/', (req, res, next) =&gt; { let today = new Date(); console.log(today.toLocaleString() + ': ' + req.query.ip); fs.appendFileSync('log.txt', today.toLocaleString() + ': ' + req.query.ip + '\\n', 'utf8'); res.send(today.toLocaleString() + ': ' + req.query.ip);});app.get('/get', (req, res, next) =&gt; { let data = fs.readFileSync('log.txt', 'utf8'); data = data.split('\\n'); res.send(data);});app.listen(65001, () =&gt; { console.log('Server Running 65001...');}); Raspberry PI 소스 코드 https://kihyeon-hong.github.io/2021/11/24/Raspberry-Pi-부팅-시-프로그램-자동-수행/ rc.local 파일을 수정하여, 부팅 시 프로그램을 실행 할 때, 무선 네트워크를 잡기 전에 프로그램이 실행된다. 따라서, ‘127.0.0.1’이 출력이 되며, 서버로 전송이 불가능하다. 따라서, 무선 네트워크를 잡은 후, 전송이 되도록, 프로그램을 수정한다. 이를 위해, npm 모듈을 설치한다. 12npm i requestnpm i ip 소스 코드를 작성한다. 1234567const request = require('request');const ip = require('ip');while (ip.address() == '127.0.0.1') {}// 192.9.200.102 -&gt; 서버의 IP로 변경한다.request.get({ url: `http://192.9.200.102:65001?ip=${ip.address()}` }, function (_1, _2, body) {}); 이 후, 해당 소스 코드를 Raspberry PI 부팅 시, 실행되도록 설정한다.","link":"/2022/03/28/Raspberry-Pi-%EB%B6%80%ED%8C%85-%EC%8B%9C-IP-%EC%A3%BC%EC%86%8C-%EC%84%9C%EB%B2%84%EB%A1%9C-%EC%A0%84%EC%86%A1%ED%95%98%EA%B8%B0/"},{"title":"Raspberry Pi 부팅 시 프로그램 자동 수행","text":"텔레그램 서버를 라즈베리 파이가 부팅하는 동시에 실행하여 별도의 디스플레이 없이 ssh 접속 IP를 얻도록 한다. 라즈베리 파이가 부팅할 때 프로그램을 자동으로 수행 시키기 위해서는 루트 권한이 필요하다. su 명령어를 이용해 루트 계정으로 접속한다. 부팅 프로그램은 /etc 디렉터리에 존재하므로 cd 명령어를 이용해 이동한다. 부팅 프로그램 작성 전 중요 테스트 부팅 프로그램에서 실수를 한다면 부팅이 되지 않는 심각한 오류에 걸릴수도 있다. 이를 방지하기 위해 해당 디렉터리에서 절대 경로로 작성한 코드를 테스트 한다. 1node /home/user/Telegram/telegram.js rc.local 파일을 열고 exit 0 위에 실행할 명령어를 입력한다. 이 때, 중요한 점은 텔레그램 봇 서버와 같이 종료가 되지 않는 프로그램의 경우 &amp;를 붙여야 한다. 이를 통하여 텔레그램 봇 서버는 부팅과 별도로 수행된다. 12345678910vi rc.local~~node /home/user/Telegram/telegram.js &amp;exit 0:wq 라즈베리 파이를 재부팅하여 텔레그램 봇 서버가 정상적으로 동작하는 지 확인한다. 1sudo reboot 획인","link":"/2021/11/24/Raspberry-Pi-%EB%B6%80%ED%8C%85-%EC%8B%9C-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8-%EC%9E%90%EB%8F%99-%EC%88%98%ED%96%89/"},{"title":"Raspberry Pi에 code-server 설치하기","text":"Code-server란? 아이패드를 구입하고, 아이패드를 이용한 코딩을 하려고 시도하였지만, 아이패드에는 마땅한 어플이 존재하지 않는다. 따라서, 웹 브라우저를 이용해 서버의 환경에서 코딩을 할 수 있는 code-server를 이용하고자 한다. 이를 위해 goormide를 이용한 code-server를 구축하였지만, 이는 goormide가 켜저 있어야 하며, 이는 유료 플랜에서만 지원한다. 따라서, Raspberry Pi를 이용해 code-server를 구축하고, 이를 포트포워딩 하여 24시간 언제 어디에서나 코딩을 할 수 있는 환경을 구축하고자 한다. Code-server의 한계점 라즈베리파이에 보통 설치하는 운영체제는 라즈비안이다. 이는 32bit 운영체제만 지원하며, code-server가 지원하지 않아 동작이 불가능하다. 이를 해결하기 위해 라즈베리 파이에 64bit 운영체제인 우분투를 설치하여 해결한다. Raspberry Pi 우분투 설치 https://www.balena.io/etcher/ : SD카드를 라이브 USB로 만들기 위해 압축 폴더 뿐 아니라 iso파일, .img파일과 같은 이미지 파일을 저장매채에 기록하는 데 사용하는 무료 오픈 소스 유틸리티 https://ubuntu.com/download/raspberry-pi : 라즈베리파이 전용 우분투 (Ubuntu Desktop을 다운로드 한다.) Flash하여 SD카드에 우분투를 설치한다. 주의 사항 SD카드 파티션 재설정 후 포맷을 하지 않는다 -&gt; 오류가 발생 F: 드라이브의 디스크를 사용하기 전에 포맷해야 합니다. -&gt; 취소 초기 설정 Welcome -&gt; 한국어 키보드 레이아웃 -&gt; Korean -&gt; Korean (English(US)도 상관없다) 무선네트워크 설정 거주지 -&gt; Seoul 당신은 누구십니까? 이름: user 암호 선택: gachon654321 암호 확인: gachon654321 자동으로 로그인 (선택) Terminal 설치12345sudo apt-get install -y curlsudo apt-get install vimsudo apt install net-toolssudo apt install openssh-serversudo apt install nodejs Code-server 설치 code-server를 설치한다. 1curl -fsSL https://code-server.dev/install.sh | sh 실행 후 ctrl + c를 통해 종료한다. 처음 실행을 하여야 설정 파일이 생성된다. 설정 파일에서 접속 아이피와 비밀번호를 입력한다. 초기 비밀번호는 랜덤적인 문자열이므로, 반드시 수정하여야 한다. 1vim ~/.config/code-server/config.yaml 1234bind-addr: 127.0.0.1:8080auth: passwordpassword: ~~~~cert: false 1234bind-addr: 0.0.0.0:8080auth: passwordpassword: gachon654321cert: false bind-addr은 0.0.0.0:8080으로 수정한다. password는 원하는 비밀번호로 수정한다. code-server 재실행1code-server 비밀번호를 입력한 후 code-server를 이용할 수 있다. 포트포워딩 포트포워딩을 이용하여 외부에서 접속이 가능하다. nohup을 이용한 부팅 시 자동 실행 방법 nohup는 “no hangups”라는 의미로, 쉘 스크립트 파일을 데몬 형태로 실행하는 명령이다. 터미널이 끊겨도 실행한 프로세스는 계속 동작하게 된다. &amp;를 추가하여 백그라운드로 실행시킨다. 1nohup code-server &amp; 부팅 시 실행 방법 사용자의 메인 디렉터리에서 scripts.sh 파일에 부팅시 실행할 명령어를 입력한다. 1vi scripts.sh 1nohup code-server &amp; :wq로 저장한다. sh파일의 권한을 변경하여 실행이 가능하도록 한다. 1chmod +x scripts.sh crontab 명령어를 실행해서 예약 파일을 편집한다. 1crontab -e 맨밑에 추가한다. 1@reboot /home/user/scripts.sh 리부트 한다. 1reboot","link":"/2022/01/27/Raspberry-Pi%EC%97%90-code-server-%EC%84%A4%EC%B9%98%ED%95%98%EA%B8%B0/"},{"title":"Raspberry Pi에서 DHT-22 센서를 이용한 온습도 측정","text":"DHT-22 DHT-22 센서를 이용해 Raspberry Pi 4 model B에서 온도와 습도 데이터를 측정한다. Raspberry Pi 4 model B에서 gpio 핀 이용하기 Raspberry Pi 4 model B에서 gpio핀을 이용한 센서 데이터를 받아오려고 하면, 에러가 발생한다. 1$ gpio readall // error 이를 해결하기 위해 다음과 같이 입력한다. 123$ su$ wget https://project-downloads.drogon.net/wiringpi-latest.deb$ sudo dpkg -i wiringpi-latest.deb node-dht-sensor 에러 BCM2835 관련 라이브러리를 설치한다. 1234567$ curl -O http://www.airspayce.com/mikem/bcm2835/bcm2835-1.36.tar.gz$ tar zxvf bcm2835-1.36.tar.gz$ d bcm2835-1.36$ ./configure$ make$ sudo make check$ sudo make install node-dht-sensor 설치하기12$ npm init$ npm install node-dht-sensor DHT-22 센서 모듈 사용 예제12345678910111213141516171819202122const sensorLib = require('node-dht-sensor');const sensor = { sensors: [ { name: 'Outdoor', type: 22, pin: 21, }, ], read: function () { for (var index in this.sensors) { var s = sensorLib.read(this.sensors[index].type, this.sensors[index].pin); console.log('온도: ' + s.temperature.toFixed(1) + '°C, 습도: ' + s.humidity.toFixed(1) + '%'); } setTimeout(function () { sensor.read(); }, 5000); },};sensor.read(); 1node test.js","link":"/2022/03/19/Raspberry-Pi%EC%97%90%EC%84%9C-DHT-22-%EC%84%BC%EC%84%9C%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EC%98%A8%EC%8A%B5%EB%8F%84-%EC%B8%A1%EC%A0%95/"},{"title":"Raspberry Pi에서 MPU9250을 이용한 9축 데이터 수집 with Node.js","text":"참고 사이트 https://www.npmjs.com/package/mpu9250 MPU9250 9축 센서 모듈 연결 MPU9250은 3축 가속도 센서, 3축 자이로 센서, 그리고 3축 지자기 센서를 통합한 센서이다. 사용하는 핀은 3.3v, GND, SDA, 그리고 SCL이며, 다음과 같이 연결한다. 연결 후 테스트 1$ i2cdetect -y 1 Node.js 모듈 설치 모듈 설치는 권한 때문에 루트 계정으로 수행한다. 12$ su$ npm install mpu9250 테스트 코드123456789101112131415161718192021var mpu9250 = require('mpu9250');var mpu = new mpu9250({ device: '/dev/i2c-1', address: 0x68, UpMagneto: true, scaleValues: true, // 전처리 DEBUG: false, ak_address: 0x0c, GYRO_FS: 0, ACCEL_FS: 2, DLPF_CFG: mpu9250.MPU9250.DLPF_CFG_3600HZ, A_DLPF_CFG: mpu9250.MPU9250.A_DLPF_CFG_460HZ, SAMPLE_RATE: 8000,});mpu.initialize();setInterval(() =&gt; { console.log(mpu.getMotion9());}, 50);","link":"/2021/11/15/Raspberry-Pi%EC%97%90%EC%84%9C-MPU9250%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%9C-9%EC%B6%95-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%88%98%EC%A7%91-with-Node-js/"},{"title":"Raspberry Pi에서 MPU9250을 이용한 9축 데이터 수집 with python","text":"참고 사이트 https://medium.com/@niru5/hands-on-with-rpi-and-mpu9250-part-3-232378fa6dbc MPU9250 9축 센서 모듈 연결 MPU9250은 3축 가속도 센서, 3축 자이로 센서, 그리고 3축 지자기 센서를 통합한 센서이다. 사용하는 핀은 3.3v, GND, SDA, 그리고 SCL이며, 다음과 같이 연결한다. 연결 후 테스트 1$ i2cdetect -y 1 Python 모듈 설치12$ pip3 install imusensor$ pip3 install easydict 테스트 코드123456789101112131415161718192021import osimport sysimport timeimport smbusfrom imusensor.MPU9250 import MPU9250address = 0x68bus = smbus.SMBus(1)imu = MPU9250.MPU9250(bus, address)imu.begin()while True: imu.readSensor() imu.computeOrientation() print (&quot;Accel x: {0} ; Accel y : {1} ; Accel z : {2}&quot;.format(imu.AccelVals[0], imu.AccelVals[1], imu.AccelVals[2])) print (&quot;Gyro x: {0} ; Gyro y : {1} ; Gyro z : {2}&quot;.format(imu.GyroVals[0], imu.GyroVals[1], imu.GyroVals[2])) print (&quot;Mag x: {0} ; Mag y : {1} ; Mag z : {2}&quot;.format(imu.MagVals[0], imu.MagVals[1], imu.MagVals[2])) print (&quot;roll: {0} ; pitch : {1} ; yaw : {2}&quot;.format(imu.roll, imu.pitch, imu.yaw)) time.sleep(0.1) 추후 작업을 위한 추가 설치 예를 들어, Raspberry Pi의 전원이 들어오는 동시에 측정을 하고자 한다면, root 계정에 Python 모듈의 추가 설치가 필요하다. 123$ su$ sudo pip3 install imusensor$ sudo pip3 install easydict","link":"/2021/11/15/Raspberry-Pi%EC%97%90%EC%84%9C-MPU9250%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%9C-9%EC%B6%95-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%88%98%EC%A7%91-with-python/"},{"title":"Raspbian Docker 설치하기","text":"Docker 설치하기 Raspbian은 Docker가 기본으로 설치되어 있지 않으므로, apt를 이용해 설치하는 과정이 필요하다. 12apt install docker.iodocker -v Docker 예제 실행하기 설치된 Docker를 이용해 예제를 빌드하고 실행한다. 해당 예제는 express.js 위에서 REST API 형태로 제공되는 기능이므로, Docker 내부의 포트를 외부의 포트와 연결하여야 한다. 12docker build . -t passwordsecurityserverdocker run -p 65001:65001 -d passwordsecurityserver 해당 컨테이너의 bash로 들어가기 위해서는 다음과 같이 exec 명령어를 사용한다. 1docker exec -it &lt;container ID&gt; /bin/bash 예제 실행하기 run 명령어를 통해 docker는 실행중이며, 다음과 같이 확인할 수 있다. 12# GEThttp://localhost:65001/passwordModelTrain?versionData=0.2&amp;comment=TestComment localhost:65001 : 비밀번호 보안성 학습모듈이 실행중인 IP와 포트 versionData=0.2 : 학습을 요청할 모델 버전 comment=TestComment : 코멘트 1234567891011// 버전 중복{ &quot;state&quot;: 301, &quot;comment&quot;: &quot;0.1은 중복된 버전&quot;}// 학습 정상 동작{ &quot;state&quot;: 200, &quot;comment&quot;: &quot;0.2 model 학습 시작&quot;} Docker-compose 설치 docker-compose는 pip3을 이용하여 설치한다. 1sudo pip3 install docker-compose","link":"/2022/01/27/Raspbian-Docker-%EC%84%A4%EC%B9%98%ED%95%98%EA%B8%B0/"},{"title":"Raspbian OS BackUp 하기","text":"준비물 현재 시스템이 돌아가고 있는 Micro SD card BackUp을 위한 포맷이 완료된 Micro SD card BackUp 새로운 SD card를 SD card 리더기에 연결한 후 현재 사용중인 Raspberry Pi의 USB 포트에 연결한다. SD Card Copier에 접속 시작 메뉴 Accessories SD Card Copier SD Card Copier 설정 윗 부분(현재 시스템이 돌아가고 있는 SD card): SC16G(/dev/mmcblk0) 아래 부분(BackUp을 실행할 SD card): Generic Mass-Storage(/dev/sda) Start BackUp 완료 주의 사항 cloud not set flag 에러: 사용 중인 공간과 빈 공간을 그대로 가져오므로 현재 시스템이 돌아가고 있는 SD card와 동일, 또는 그 이상 크기의 SD card로 수행하여야 한다.","link":"/2021/11/29/Raspbian-OS-BackUp-%ED%95%98%EA%B8%B0/"},{"title":"Typescript 기초학습자료","text":"기본 타입과 커스텀 타입기본적인 타입 표기12let a: string;let b: number; 타입스크립트에서 제공하는 타입들 string: 문자열 boolean: true, false number: 숫자 symbol: Symbol 생성자를 호출해 생성된 고유한 값 any: 모든 타입을 허용 unknown: any와 비슷하나, 먼저 타입을 지정하거나 좁히지 않으면 조작이 불가능 never: 도달할 수 없는 코드 void: 값이 없음 명시적 타입 주의사항 변수의 타입은 이미 문자열이므로 타입스크립트는 string으로 유추할 수 있다. 따라서, n2와 같이 컴파일러가 유추할 수 있는 곳에 다시 타입을 지정할 필요가 없다. 12let n1 = 'AAA;';let n2: string = 'BBB'; 초기값 없이 변수를 선언하면 타입스크립트는 any로 유추한다. 1let product; // any 유니온 타입 or 연산자와 같이 변수에 지정할 수 있는 타입이 여러 개인 경우에 사용한다. 12345678910111213function padLeft(value: string, padding: any) { if (typeof padding === 'number') { return Array(padding + 1).join(' ') + value; } if (typeof padding === 'string') { return padding + value; } throw new Error(`Expected string or number, got '${padding}'.`);}console.log(padLeft('Hello world', 4)); // returns &quot; Hello world&quot;console.log(padLeft('Hello world', ' Yakov says ')); // returns &quot; Yakov says Hello world&quot;console.log(padLeft('Hello world', true)); // if padding had type any - runtime error 12345678910111213function padLeft(value: string, padding: string | number) { if (typeof padding === 'number') { return Array(padding + 1).join(' ') + value; } if (typeof padding === 'string') { return padding + value; } throw new Error(`Expected string or number, got '${padding}'.`);}console.log(padLeft('Hello world', 4)); // returns &quot; Hello world&quot;console.log(padLeft('Hello world', ' Yakov says ')); // returns &quot; Yakov says Hello world&quot;console.log(padLeft('Hello world', true)); // if padding had type any - compile error typeof, instanceof typeof는 typescript 내장 타입에 사용하며, instanceof는 사용자가 만든 타입에 사용한다. 12if (person instanceof Person) {} 커스텀 타입 ?는 해당 프로퍼티가 필수가 아닌 경우에 입력한다. 1234567type age = number;type Person = { age: number; name: string; weight?: number;}; 1234let person: Person = { age: 19, name: 'AAA',}; 접근 제한자 타입스크립트에는 readonly, private, protected, public 키워드가 있다. readonly는 const와 비슷하지만, 클래스 프로퍼티에 사용할 수 없다. 1234class Block { readonly a: string; constructor(readonly b: number) {}} 인터페이스 (interface, implements) 자바스크립트 코드로 컴파일 되지 않는다. 개발 도중 잘못된 타입을 피할 수 있게 도움을 준다. 12345interface Person { firstName: string; lastName: string; age: number;} class와 같이 new 키워드를 사용해 인스턴스화 시킬 수 있지만, 자바스크립트 코드에 해당 부분이 없다. 즉, 코드가 간결해진다. type, interface, class 런타임동안 객체를 인스턴스화한다면 interface, type을 사용하며, 값을 나타내는 데에 사용할 경우에는 class를 사용한다. 타입스크립트의 타입 검사기로 안전하게 커스텀 타입을 선언하고자 할 때에는 type, interface를 사용하며, 이들은 자바스크립트로 컴파일되지 않기 때문에 런타임 용량이 작아진다. class는 자바스크립트 코드로 컴파일되기 때문에 용량이 커진다. type 키워드는 interface와 동일한 기능뿐만이 아니라 더 많은 기능을 사용할 수 있다. 예를 들어, interface는 합집합, 교집합 개념을 사용할 수 없지만, type은 가능하다. 구조적 타입 시스템과 명목적 타입 시스템 타입스크립트는 구조적 타입 시스템을 사용한다. Person과 Customer은 같은 구조를 갖고 있기 때문에 오류가 발생하지 않는다. 1234567class Person { name: string;}class Customer { name: string;}const cust: Customer = new Person(); 123456789class Person { name: string; age: number;}class Customer { name: string;}const cust: Customer = new Person();const per: Person = new Customer(); // Error 클래스와 인터페이스를 사용한 객체 지향 프로그래밍public, private, protected 접근 제어자 public: 모든 내부 및 외부 클래스에서 접근 가능 private: 클래스 내에서만 접근 가능 protected: 동일 패키지에 속하는 클래스와 서브 클래스 관계일 경우에만 접근 가능 super() 키워드 사용 슈퍼 클래스와 서브 클래스가 같은 이름의 메소드를 가지고 있다면, super() 메소드로 슈퍼 클래스의 생성자를 호출하여야 한다. 123456789class Person { contructor(public firstName: string, public lastName: string, private age: number) {}}class Employee extends Person { contructor(firstName: string, lastName: string, age: number, public department: string) { super(firstName, LastName, age); }}const empl = new Employee('A', 'B', 30, 'C'); 추상 클래스 추상 클래스는 객체로 만들 수 없는 추상적인 개념으로 일종의 설계도이다. 인스턴스화 될 수 없다. 추상 메소드를 호출하는 명령은 사용할 수 없다. 추상 클래스는 인스턴스화될 수 없으므로, 추상 멤버는 절대로 호출되지 않는다. 1234abstract class Person { contructor() {} abstract increasePay(percent: number): void;} 메소드 오버로딩 타입스크립트에서는 1개의 메소드 구현을 갖는다. 1234567891011class ProductService { getProducts(); getProducts(id: number); getProducts(id?: number) { // 모든 가능한 파라매터를 다루는 생성자를 구현한다. console.log(`call getProducts`); }}const proSevice = new ProductService();proService.getProducts(123);proService.getProducts(); 인터페이스 사용 인터페이스로 클래스를 선언할 때, 인터페이스 내 각 메소드를 구현해야 한다. 인터페이스 확장12interface A {}interface B extends A {} 열거타입(Enum)과 제네릭(Generic)열거타입(Enum)123456789enum Weekdays { Monday = 1, Tuesday, // 2 Wednesday, // 3 Thursday, // 4 Friday, // 5 Saturday, // 6 Sunday, // 7} 열거 타입 멤버에 할당된 숫자를 신경 쓰지 않아도 되는 경우가 있다. 1234567enum Alpha { A, B,}function aOrB(alpha: Alpha): void {} // A, B 외의 문자가 들어올 위험이 없다.function aOrB(alpha: string): void {} // A, B 외의 문자가 들어올 위험이 있다. 문자열 열거123456789enum Direction { Up = 'UP', Down = 'DOWN', Left = 'LEFT', Right = 'RIGHT',}move(where:string) // move('North') Errormove(where:Direction) // move(Direction.Up) 커스텀 타입을 이용하는 방법 12type Direction = 'Up' | 'Down' | 'Left' | 'Right';function move(direction: Direction) {} const enum const enum은 자바스크립트가 생성되지 않는다. 제네릭(Generic) 제네릭을 사용하면 함수의 호출자가 나중에 구체적인 타입을 지정할 수 있다. 12class Person {}const people = new Array&lt;Person&gt;(10); 제네릭 타입 생성123456789interface Comp&lt;T&gt; { compTo(value: T): number;}class Rectangle implements Comp&lt;Rectangle&gt; { compTo(value: Rectangle): number {}}class Triangle implements Comp&lt;Triangle&gt; { compTo(value: Triangle): number {}} 고차함수 내 반환 타입 강제 함수를 파라매터로 받거나 다른 함수를 반환하는 함수를 고차함수라고 한다. 1234const outerFunc = (someValue: number) =&gt; (multiplier: number) =&gt; someValue * multiplier;const innerFunc = outerFunc(10);let result = innerFunc(5);console.log(result); //50 1234const outerFunc = (someValue: number) =&gt; (multiplier: number) =&gt; someValue * multiplier;const innerFunc = outerFunc(10);let result = innerFunc(5);console.log(result); //50 참고자료 기초부터 블록체인 실습까지 단숨에 배우는 타입스크립트, 영진닷컴, 야코프 페인","link":"/2022/02/03/Typescript-%EA%B8%B0%EC%B4%88%ED%95%99%EC%8A%B5%EC%9E%90%EB%A3%8C/"},{"title":"Ubuntu 환경에서 Node.js와 Python 설치 및 관리","text":"Node.js 설치 https://github.com/nodesource/distributions 우분투는 기본적으로 Node.js가 설치되어 있지 않다. 따라서 이를 설치하고 관리하고자 한다. 12curl -fsSL https://deb.nodesource.com/setup_12.x | sudo -E bash -sudo apt-get install -y nodejs Node.js 버전 관리 https://github.com/nvm-sh/nvm nvm은 노드 버전을 쉽게 관리할 수 있게 해준다. 1curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.1/install.sh | bash nvm을 zsh가 읽을 수 있게 해줘야 한다. 만약 설치 후 nvm 명령어가 먹히지 않는다면 다음과 같은 명령어를 ~/.zshrc에 추가한다. 12export NVM_DIR=&quot;$([ -z &quot;${XDG_CONFIG_HOME-}&quot; ] &amp;&amp; printf %s &quot;${HOME}/.nvm&quot; || printf %s &quot;${XDG_CONFIG_HOME}/nvm&quot;)&quot;[ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; \\. &quot;$NVM_DIR/nvm.sh&quot; # This loads nvm 설정 후 변경이 가능한 모든 Node.js의 버전을 확인한다. 1nvm ls-remote 노드 버전을 설치한다. 12nvm install v16.13.1node -v Python 설치 파이썬은 기본적으로 python3 명령어를 통해 실행할 수 있다. 그러나, 버전 관리를 위해 좀 더 추가하도록 한다. 개인 페이지 (PPA) 추가 https://launchpad.net/~deadsnakes/+archive/ubuntu/ppa 123sudo add-apt-repository ppa:deadsnakes/ppa엔터sudo apt-get update 파이썬 3.8을 설치한다. 1sudo apt-get install python3.8 python3.8 명령어는 매우 귀찮으므로, ~/.zshrc 파일을 수정한다. 1alias python=python3.8 이를 통해 python 명령어로 python3.8을 실행할 수 있다.","link":"/2022/01/27/Ubuntu-%ED%99%98%EA%B2%BD%EC%97%90%EC%84%9C-Node-js%EC%99%80-Python-%EC%84%A4%EC%B9%98-%EB%B0%8F-%EA%B4%80%EB%A6%AC/"},{"title":"VSCode Remote-SSH 프로세스에서 없는 파이프에 쓰려고 했습니다 에러","text":"Rempte-SSH Remote-SSh는 VSCode의 확장 기능 중 하나로 SSH 접속을 위한 도구 Ctrl + Shift + p를 이용해 접속 가능 프로세스에서 없는 파이프에 쓰려고 했습니다 에러 동일한 IP를 이용해 전에 접속을 하였지만, 다른 기기나 환경이라면 다음과 같은 에러 발생 12345678910111213141516[20:37:25.006] Log Level: 2[20:37:25.012] remote-ssh@0.66.1[20:37:25.012] win32 x64...&gt; 프로세스에서 없는 파이프에 쓰려고 했습니다.[20:37:27.428] &quot;install&quot; terminal command done[20:37:27.430] Install terminal quit with output: 프로세스에서 없는 파이프에 쓰려고 했습니다.[20:37:27.431] Received install output: 프로세스에서 없는 파이프에 쓰려고 했습니다.[20:37:27.436] Failed to parse remote port from server output[20:37:27.440] Resolver error: Error:... 해결 방법 {user}/.ssh/known_hosts 해당 파일을 열면 다음과 같은 내용을 볼 수 있음 123192.168.1.106 ~192.168.1.105 ~192.168.0.22 ~ 방금 접속을 시도한 IP 주소를 지우고 다음과 같이 저장을 수행 12192.168.1.106 ~192.168.1.105 ~ Remote-SSH를 이용해 재접속 실시","link":"/2021/12/07/VSCode-Remote-SSH-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%97%90%EC%84%9C-%EC%97%86%EB%8A%94-%ED%8C%8C%EC%9D%B4%ED%94%84%EC%97%90-%EC%93%B0%EB%A0%A4%EA%B3%A0-%ED%96%88%EC%8A%B5%EB%8B%88%EB%8B%A4-%EC%97%90%EB%9F%AC/"},{"title":"Windows 환경에서 Ubuntu 설치하기","text":"설치 전 참고 사항WSL 간편 설정 WSL 설치 및 세팅은 Docker를 설치한 후 실행하면 편하다. WSL2 업데이트가 나오는데, 커널 업데이트를 미리 실행할 것 https://www.docker.com/products/docker-desktop https://docs.microsoft.com/ko-kr/windows/wsl/install-manual#step-4---download-the-linux-kernel-update-package x64 머신용 최신 WSL2 Linux 커널 업데이트 패키지 다운 후 설치 Windows Terminal 설치 Windows Terminal을 chock 또는 microsoft store에서 설치를 할 것 Ubuntu 설치 Microsoft store에서 Ubuntu 18.0.4 LTS를 다운로드 한다. 처음 실행하면, username과 passowrd를 설정한다. sudo 명령어를 사용할 때, 해당 password를 이용하기 때문에 반드시 기억해야 한다. Windows Terminal을 보면 Ubuntu를 볼 수가 있는데, 이는 리눅스 환경에서 동작한다. WSL2 설치 확인 WSL2로 업데이트 및 확인을 위해 해당 명령어를 Ubuntu 콘솔에 작성한다. 만약 Docker를 설치하고, 커널 업데이트를 완료 했다면 다음과 같은 화면이 출력될 것이다. Windows Terminal 설정 Windows Terminal의 설정을 들어가면 Json 파일 열기가 있다. 이를 선택한다. Windows Terminal 선택 시 기본으로 열리는 콘솔을 Ubuntu로 하기 위해 settings.json의 “defaultProfile”을 수정한다. “Profiles”의 “list”를 보면 선택 가능한 콘솔이 있으며, “Ubuntu-18.04”의 “guid”를 복사해서 “defaultProfile”에 붙여넣는다. 12345678910111213141516{ &quot;$schema&quot;: &quot;https://aka.ms/terminal-profiles-schema&quot;, &quot;defaultProfile&quot;: &quot;{c6eaf9f4-32a7-5fdc-b5cf-066e8a4b1e40}&quot;, ... &quot;profiles&quot;: { &quot;list&quot;: [ ... { &quot;guid&quot;: &quot;{c6eaf9f4-32a7-5fdc-b5cf-066e8a4b1e40}&quot;, &quot;name&quot;: &quot;Ubuntu-18.04&quot;, &quot;source&quot;: &quot;Windows.Terminal.Wsl&quot; } ] }, ...} 재시작 하면 기본적으로 Ubuntu 환경으로 들어온다. Oh my zsh https://github.com/ohmyzsh/ohmyzsh zsh의 설정 관리를 위한 프레임워크인 oh-my-zsh를 설치한다. 이를 위해 먼저 zsh를 설치한다. 1sudo apt install zsh Oh my zsh를 설치한다. 1sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot; 콘솔이 바뀐 것을 확인할 수 있다. Powerlevel10k https://github.com/romkatv/powerlevel10k powerlevel10k는 zsh의 테마를 변경할 수 있다. 1sudo git clone --depth=1 https://github.com/romkatv/powerlevel10k.git ${ZSH_CUSTOM:-$HOME/.oh-my-zsh/custom}/themes/powerlevel10k .zshrc 파일을 수정한다. 이를 위해 .zshrc 파일을 열어야 한다.만약 code ~/.zshrc가 동작하지 않는다면 vi를 이용한다. 12code ~/.zshrcvi ~/.zshrc ZSH_THEME를 수정한다. 1ZSH_THEME=&quot;robbyrussell&quot; -&gt; ZSH_THEME=&quot;powerlevel10k/powerlevel10k&quot; :wq를 이용해 수정하고, 터미널을 재시작하면 다음과 같은 화면이 뜬다. 이는 powerlevel10k의 기본 설정이며, 처음 실행에서 나타난다. 이를 보면 사각형이 잘 나오지 않는 것을 볼 수가 있는데, 이는 폰트의 문제이다. powerlevel10k의 사이트에 들어가면 4개의 폰트가 있는데, 해당 4개 모두 다운로드 후 설치한다. Windows Terminal의 setting.json setting.json의 “defaults”에서 “FontFace”를 “MesloLGS NF”로 수정한다. 12345678910111213&quot;profiles&quot;: { &quot;defaults&quot;: { // Put settings here that you want to apply to all profiles. &quot;fontFace&quot;: &quot;MesloLGS NF&quot; }, &quot;list&quot;: [ { // Make changes here to the powershell.exe profile. &quot;guid&quot;: &quot;{61c54bbd-c2c6-5271-96e7-009a87ff44bf}&quot;, &quot;name&quot;: &quot;Windows PowerShell&quot;, &quot;commandline&quot;: &quot;powershell.exe&quot;, &quot;hidden&quot;: false }, Visual studio code 설정 File -&gt; Preferences -&gt; Settings 검색창에 integrated를 검색하면 Font Family가 있다 이를 “MesloLGS NF”로 수정한다. 콘솔 재시작 콘솔을 재시작하면 다음과 같이 정상적으로 나오는 것을 볼 수 있다. 원하는대로 설정을 모두 마치고 나면 다음과 같은 화면이 출력된다. ls color 변경 code ~/.zshrc 파일 맨 마지막 줄에 다음을 추가한다. 1LS_COLORS=&quot;ow=01;36;40&quot; &amp;&amp; export LS_COLOR powerlevel10k 재설정1p10k configure Windows에서 설치한 Ubuntu 상세 구조 분석 실제로 구현되는 구조는 아니라 가상화로 구현되는 구조이다. cmd, powershell, 그리고 Windows Terminal과 같은 window 환경에서 동작하는 터미널의 경우 C 드라이브가 루트이며, 이 이상으로 올라갈 수 없다. 그러나 가상화로 구현된 Ubuntu, 그리고 Ubuntu 위에서 동작하는 zsh 터미널은 루트 디렉터리까지 올라갈 수 있으며, Windows 환경은 mnt 디렉터리를 통해 들어간다. home 디렉터리의 user는 Ubuntu에서 생성한 사용자이며, 이는 user 사용자의 환경이다.","link":"/2022/01/27/Windows-%ED%99%98%EA%B2%BD%EC%97%90%EC%84%9C-Ubuntu-%EC%84%A4%EC%B9%98%ED%95%98%EA%B8%B0/"},{"title":"VSCode 단축어 정리","text":"VSCode 자체 중요 단축어Command + Shift + P, Ctrl + Shift + P Extenstion 및 설치하거나 제공되는 다양한 기능을 사용할 수 있다. Command + P, Ctrl + P 파일의 빠른 이동을 도와준다. Command + B, Ctrl + B 왼쪽의 사이드 바를 토글한다. ^ + `, Ctrl + ` 터미널을 토글한다. VSCode 중요 단축어 Code(File) -&gt; Preferences -&gt; Keyboard -&gt; Shortcuts에서 확인 및 설정할 수 있다. Command + D, Ctrl + D 반복된 것을 자동으로 선택해주고, 커서를 가져다 주므로 쉽게 수정할 수 있다. Option + Up and Down, Alt + Up and Down 선택한 코드를 위, 아래로 옮겨준다. Option + Shift + Up and Down, Alt + Shift + Up and Down 복사를 한 후, 위 아래로 움직인다. Option + Click, Alt + Click 클릭하는 곳마다 커서를 만들어준다. 편집이 끝난 후, ESC를 누르면 된다. (여러 줄을 선택한 후) + Option + Shift + I, (여러 줄을 선택한 후) + Alt + Shift + I 선택된 영역들에 커서가 생긴다. Option + Shift + (여러 줄 선택), Alt + Shift + (여러 줄 선택) 마우스가 가는 곳마다 커서가 생긴다. Command + L 한 줄을 선택하고 커서가 다음줄로 이동한다. 반복 선택이 가능하다. Command + Up and Down, Ctrl + Home and End 커서를 맨 위, 아래로 올리고 내린다. Command + Left and Right, Home and End 커서를 맨 왼쪽과 오른쪽으로 이동시킨다. Shift까지 누르면 선택이 된다. Option + Left and Right, Ctrl + Left and Right 단어 별로 이동한다. Shift까지 누르면 선택이된다. Command + Enter, Ctrl + Enter 라인 중간에서 다음 줄로 이동을 해야할 경우 사용한다. Command + U, Ctrl + U 이전에 커서가 있던 곳으로 이동한다. Command + /, Ctrl + / 코드 블록을 전부 주석처리 한다. 기타 유용한 VSCode 단축어F12 정의된 함수가 어떻게 구현되어 있는지 확인하고 싶을 때, 사용한다. Option + F12, Alt + F12를 누르면 잠깐 열어볼 수 있다. F2 변수를 선택한 후, F2를 눌러서 변수명을 전체 바꿀 수 있다. 연관된 변수를 전부 바뀌준다. 참조가 있는 다른 파일도 바꿔준다. Command + Shift + R, Ctrl + Shift + R 리펙토링 함수로 감싼다. Snippets 자동 완성 도우미이다. Extenstion에서 인스톨 후 사용한다. Debugger 빨간 점을 클릭하면, 실행 시, 일시 정지한다. 그리고 Run and Debug를 선택한다.","link":"/2022/03/26/VSCode-%EB%8B%A8%EC%B6%95%EC%96%B4-%EC%A0%95%EB%A6%AC/"},{"title":"goormide에 code-server 설치하기","text":"개발환경 설정 취지 아이패드를 구입하고 아이패드를 이용해 코딩을 하려고 했지만, 마땅한 어플이 존재하지 않는다. 따라서, 웹 브라우저로 간단하게 접속할 수 있는 code-server를 구축하여 아이패드를 이용해 코딩할 수 있는 환경을 구축하고자 한다. Code-server란? Visual studio code를 Node.js를 통해 Server에 올리고, 이를 웹 브라우저를 이용해 접속하는 프로그램이다. 이를 위해 접속할 환경에 code-server가 설치되어 있어야 하며, 이는 실행되어 있어야 한다. 외부에서 접속하기 위해 포트포워딩을 하여야 한다. https://vscode.dev/와의 차이점 https://vscode.dev/는 웹 브라우저를 이용해 로컬 환경에서 코딩을 하는 사이트이다. 이는 로컬 환경의 파일을 열어볼 수 없는, 또는 열기 힘든 아이패드와 같은 환경에서 적절하지 못하다. 그에 비해 code-server는 외부의 파일 디렉터리에 원격으로 접속하여 프로그래밍을 하므로, 아이패드의 제한적인 환경에 구애받지 않는다. goormide 설명 goormide는 웹 기반 클라우드 코딩 서비스이다. 컨테이너 기반의 개발 환경을 구축해준다. goormide를 이용한 code-server 설치 goormide의 컨테이너를 생성하며, 공개 범위는 public, 소프트웨어 스택은 node.js를 선택한다. 다음과 같은 명령어를 입력하여 code-server를 설치한다. 1vim ~/.config/code-server/config.yaml code-server를 실행하여 설정 파일을 생성한다. 123456789root@goorm:/workspace/code-server# code-server[2022-01-27T02:49:15.646Z] info Wrote default config file to ~/.config/code-server/config.yaml[2022-01-27T02:49:18.522Z] info code-server 4.0.1 735c6da829535969ff7193c79379299e4a1cb9bc[2022-01-27T02:49:18.525Z] info Using user-data-dir ~/.local/share/code-server[2022-01-27T02:49:18.555Z] info Using config file ~/.config/code-server/config.yaml[2022-01-27T02:49:18.555Z] info HTTP server listening on http://127.0.0.1:8080/[2022-01-27T02:49:18.556Z] info - Authentication is enabled[2022-01-27T02:49:18.619Z] info - Using password from ~/.config/code-server/config.yaml[2022-01-27T02:49:18.619Z] info - Not serving HTTPS ctrl+c로 종료 후 설정 파일을 연다. 1vi ~/.config/code-server/config.yaml 주소를 0.0.0.0:8080으로 수정한다. 비밀번호를 원하는 비밀번호로 수정한다. :wq 명령을 이용해 저장한다. code-server를 재실행한다. 1code-server 포트포워딩 goormide는 포트포워딩을 제공한다. 오른쪽 상단의 미리보기에서 실행 URL과 포트 설정을 선택한다. URL과 포트를 설정한다. 이때, 포트는 설정 파일에서 저장한 포트인 8080으로 한다. 웹브라우저를 이용해 해당 URL에 접속하면, 다음과 같은 화면이 나온다. 비밀번호를 입력한다. goormide의 디렉터리가 화면에 출력되는 것을 볼 수 있다.","link":"/2022/01/27/goormide%EC%97%90-code-server-%EC%84%A4%EC%B9%98%ED%95%98%EA%B8%B0/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server -p 3000 More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2019/11/30/hello-world/"},{"title":"모스부호를 이용한 Raspberry Pi IP 주소 획득하기","text":"모스부호를 이용하여 Raspberry Pi의 IP 주소 획득하기 Raspberry Pi의 IP 주소를 획득하거나, Wifi 설정을 위해 SSH 접속을 시도하려고 하여도, 결국 IP 주소가 필요하다. 또한, 유동 IP의 경우 라즈베리 파이의 부팅마다 IP 주소가 달라지므로, 모니터와 같이 IP 주소를 확인할 수 있는 추가적인 수단이 필요하다. 이를 해결하기 위해 gpio pin을 이용하여 모스부호를 반환해주는 프로그램을 작성한다. 모스부호 설명 모스부호는 짧은 발신 전류(.)와 간 발신 전류(-)를 조합하여 알파벳과 숫자를 표기한 것이다. IP 주소는 숫자와 ‘.’으로 이루어져 있으며, 이에 해당하는 모스부호는 다음과 같다. 소스 코드 IP 주소를 모스부호로 변환해주는 프로그램은 미리 작성하였다. https://github.com/KiHyeon-Hong/Convert_IP_address_to_morse_code_cjs.git 123git clone https://github.com/KiHyeon-Hong/Convert_IP_address_to_morse_code_cjs.gitcd Convert_IP_address_to_morse_code_cjsnpm i index.js에는 사용 예시 코드가 있으며, 공인 IP와 사설 IP를 모스부호로 반환해주는 메소드 2개를 사용하였다. Raspberry Pi에 연동 gpio pin을 이용해 센서 및 액츄에이터를 조작하는 방법은 아래 링크에서 참고할 수 있다. https://kihyeon-hong.github.io/2021/11/15/Raspberry-Pi-4-gpio-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/ 아래 소스 코드는 gpio 29번 핀을 사용하였으며, 소스 코드를 변경하여 원하는 방식으로 수정 가능하다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162const gpio = require('node-wiring-pi');const morse = require(__dirname + '/src/toMorseCode');const MORSE = 29;gpio.setup('wpi');gpio.pinMode(MORSE, gpio.OUTPUT);const stop100ms = () =&gt; { gpio.digitalWrite(MORSE, 0); return new Promise((resolve) =&gt; { setTimeout(() =&gt; { resolve(); }, 100); });};const stop500ms = () =&gt; { gpio.digitalWrite(MORSE, 0); return new Promise((resolve) =&gt; { setTimeout(() =&gt; { resolve(); }, 500); });};const short = () =&gt; { gpio.digitalWrite(MORSE, 1); return new Promise((resolve) =&gt; { setTimeout(() =&gt; { resolve(); }, 100); });};const long = () =&gt; { gpio.digitalWrite(MORSE, 1); return new Promise((resolve) =&gt; { setTimeout(() =&gt; { resolve(); }, 500); });};async function main() { let priIP = await morse.priToMorseCode(); priIP = priIP.split(''); for (let i = 0; i &lt; priIP.length; i++) { if (priIP[i] === '.') { await short(); await stop100ms(); } else if (priIP[i] === '-') { await long(); await stop100ms(); } else { await stop500ms(); } }}main(); ‘.’: 100ms 1 신호를 주며, 100ms 0 신호를 준다. ‘-‘: 500ms 1 신호를 주며, 100ms 0 신호를 준다. ‘ ‘: 각 모스 부호 사이의 간격은 500ms이며, 500ms 동안 0 신호를 준다. Raspberry Pi 부팅 시 프로그램 자동 수행 해당 프로그램을 라즈베리 파이가 부팅이 될때 실행하도록 하여야 한다. 이는 다음 링크를 참조한다. https://kihyeon-hong.github.io/2021/11/24/Raspberry-Pi-%EB%B6%80%ED%8C%85-%EC%8B%9C-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8-%EC%9E%90%EB%8F%99-%EC%88%98%ED%96%89/","link":"/2022/02/12/%EB%AA%A8%EC%8A%A4%EB%B6%80%ED%98%B8%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-Raspberry-Pi-IP-%EC%A3%BC%EC%86%8C-%ED%9A%8D%EB%93%9D%ED%95%98%EA%B8%B0/"},{"title":"우분투 타임존 설정하기","text":"우분투 타임존 설정하기 우분투 기반의 환경에서 타임존 기본 설정이 한국으로 되어 있지 않은 경우가 있다. (예를 들어, AWS의 EC2) 타임존 설정이 맞지 않는다면, 데이터베이스의 시간 저장, git commit 시간에 오차가 발생하여 문제가 발생한다. 12root@SERVER:/# dateTue Sep 19 19:16:05 UTC 2017 tzselect를 이용해 타임존을 설정한다. 123456789101112131415root@SERVER:/# tzselectPlease identify a location so that time zone rules can be set correctly.Please select a continent, ocean, &quot;coord&quot;, or &quot;TZ&quot;.1) Africa2) Americas3) Antarctica4) Asia5) Atlantic Ocean6) Australia7) Europe8) Indian Ocean9) Pacific Ocean10) coord - I want to use geographical coordinates.11) TZ - I want to specify the time zone using the Posix TZ format.#? 4 12345678910111213141516171819Please select a country whose clocks agree with yours.1) Afghanistan 18) Israel 35) Palestine2) Armenia 19) Japan 36) Philippines3) Azerbaijan 20) Jordan 37) Qatar4) Bahrain 21) Kazakhstan 38) Russia5) Bangladesh 22) Korea (North) 39) Saudi Arabia6) Bhutan 23) Korea (South) 40) Singapore7) Brunei 24) Kuwait 41) Sri Lanka8) Cambodia 25) Kyrgyzstan 42) Syria9) China 26) Laos 43) Taiwan10) Cyprus 27) Lebanon 44) Tajikistan11) East Timor 28) Macau 45) Thailand12) Georgia 29) Malaysia 46) Turkmenistan13) Hong Kong 30) Mongolia 47) United Arab Emirates14) India 31) Myanmar (Burma) 48) Uzbekistan15) Indonesia 32) Nepal 49) Vietnam16) Iran 33) Oman 50) Yemen17) Iraq 34) Pakistan#? 23 1234567Therefore TZ='Asia/Seoul' will be used.Local time is now: Tue Sep 19 19:21:47 KST 2017.Universal Time is now: Tue Sep 19 10:21:47 UTC 2017.Is the above information OK?1) Yes2) No#? 1 12root@SERVER:/# dateTue Sep 19 19:22:28 KST 2017 tzselect 오류 tzselect가 작동하지 않을 경우 tzdata를 설치한다. 그 전에 .profile의 맨 밑에 다음을 입력한 후 리부팅 한다. 1TZ='Asia/Seoul'; export TZ tzdata 설치 1sudo apt install tzdata","link":"/2022/01/27/%EC%9A%B0%EB%B6%84%ED%88%AC-%ED%83%80%EC%9E%84%EC%A1%B4-%EC%84%A4%EC%A0%95%ED%95%98%EA%B8%B0/"},{"title":"코딩테스트를 위한 기초 Javascript 문법 정리 Array","text":"코딩테스트에서 자주 사용하는 Array methods (참고자료) https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array 여러 메소드의 기초 사용법을 유형별로 정리한다. 데이터 반환 (특정 인덱스)at 해당 인덱스의 요소를 반환한다. .at(-1)을 사용할 수 있다. 1234567let arr = ['01', '02', '03', '04', '05', '06', '07', '08', '09', '10'];console.log(arr.at(1));// 2console.log(arr.at(2));// 3console.log(arr.at(-1));// 10 다른 메소드와 비교12345678910const colors = ['빨강', '초록', '파랑'];// length 속성 사용const lengthWay = colors[colors.length - 2];console.log(lengthWay); // '초록' 기록// slice() 메서드 사용. 배열을 반환함에 주의const sliceWay = colors.slice(-2, -1);console.log(sliceWay[0]);// at() 메서드 사용const atWay = colors.at(-2);console.log(atWay); 데이터 추가 및 삭제 (Stack과 Queue)pop 배열에서 마지막 요소를 제거하고 그 요소를 반환한다. 12345678const plants = ['broccoli', 'cauliflower', 'cabbage', 'kale', 'tomato'];console.log(plants.pop());// expected output: &quot;tomato&quot;console.log(plants);// expected output: [&quot;broccoli&quot;, &quot;cauliflower&quot;, &quot;cabbage&quot;, &quot;kale&quot;]plants.pop();console.log(plants);// expected output: [&quot;broccoli&quot;, &quot;cauliflower&quot;, &quot;cabbage&quot;] push 배열의 끝에 하나 이상의 요소를 추가하고, 배열의 길이를 반환한다. 123456789const animals = ['pigs', 'goats', 'sheep'];const count = animals.push('cows');console.log(count);// expected output: 4console.log(animals);// expected output: Array [&quot;pigs&quot;, &quot;goats&quot;, &quot;sheep&quot;, &quot;cows&quot;]animals.push('chickens', 'cats', 'dogs');console.log(animals);// expected output: Array [&quot;pigs&quot;, &quot;goats&quot;, &quot;sheep&quot;, &quot;cows&quot;, &quot;chickens&quot;, &quot;cats&quot;, &quot;dogs&quot;] shift 배열에서 첫번째 요소를 제거하고, 제거된 요소를 반환한다. 123456const array1 = [1, 2, 3];const firstElement = array1.shift();console.log(array1);// expected output: [2, 3]console.log(firstElement);// expected output: 1 unshift 새로운 요소를 배열의 맨 앞쪽에 추가한다. 12345const array1 = [1, 2, 3];console.log(array1.unshift(4, 5));// expected output: 5console.log(array1);// expected output: Array [4, 5, 1, 2, 3] 데이터 탐색 (조건문)some 배열 안의 어떤 요소라도 주어진 판별식을 통과하는 지 테스트한다. 12345const array = [1, 2, 3, 4, 5];// checks whether an element is evenconst even = (element) =&gt; element % 2 === 0;console.log(array.some(even));// expected output: true every 배열 안의 모든 요소가 주어진 판별 함수를 통과하는 지 테스트한다. 거짓을 반환하는 요소를 찾을 때까지 배열에 있는 각 요소에 대해 1번씩 실행한다. 1234const isBelowThreshold = (currentValue, index, array) =&gt; currentValue &lt; 40;const array1 = [1, 30, 39, 29, 10, 13];console.log(array1.every(isBelowThreshold));// expected output: true includes 배열이 특정 요소를 포함하고 있는지 판별한다. 123456789const array1 = [1, 2, 3];console.log(array1.includes(2));// expected output: trueconst pets = ['cat', 'dog', 'bat'];console.log(pets.includes('cat'));// expected output: trueconsole.log(pets.includes('at'));// expected output: false 탐색을 시작할 위치를 지정할 수 있다. 12345[1, 2, 3].includes(2); // true[1, 2, 3].includes(4); // false[1, 2, 3].includes(3, 3); // false[1, 2, 3].includes(3, -1); // true[1, 2, NaN].includes(NaN); // true 데이터 반환 (조건문)find 주어진 판별식을 만족하는 첫번째 요소의 값을 반환한다. 1234const array1 = [5, 12, 8, 130, 44];const found = array1.find((element) =&gt; element &gt; 10);console.log(found);// expected output: 12 findIndex 판별식을 만족하는 첫번째 요소에 대한 인덱스를 반환한다. 1234const array1 = [5, 12, 8, 130, 44];const isLargeNumber = (element) =&gt; element &gt; 13;console.log(array1.findIndex(isLargeNumber));// expected output: 3 indexOf 배열에서 지정된 요소를 찾을 수 있는 첫번째 인덱스를 반환하며, 없다면 -1을 반환한다. 12345678const beasts = ['ant', 'bison', 'camel', 'duck', 'bison'];console.log(beasts.indexOf('bison'));// expected output: 1// start from index 2console.log(beasts.indexOf('bison', 2));// expected output: 4console.log(beasts.indexOf('giraffe'));// expected output: -1 탐색을 시작할 위치를 지정할 수 있다. 123456var array = [2, 9, 9];array.indexOf(2); // 0array.indexOf(7); // -1array.indexOf(9, 2); // 2array.indexOf(2, -1); // -1array.indexOf(2, -3); // 0 lastIndexOf 배열에서 주어진 값을 찾을 수 있는 마지막 인덱스를 반환하며, 없다면 -1을 반환한다. 12345const animals = ['Dodo', 'Tiger', 'Penguin', 'Dodo'];console.log(animals.lastIndexOf('Dodo'));// expected output: 3console.log(animals.lastIndexOf('Tiger'));// expected output: 1 배열 구조 변경concat 기존 배열을 변경하지 않으며, 추가된 새로운 배열을 반환한다. 12345const array1 = ['a', 'b', 'c'];const array2 = ['d', 'e', 'f'];const array3 = array1.concat(array2); // array1.concat(array2, array3, array4); 가능console.log(array3);// expected output: [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;] flat 모든 하위 배열 요소를 지정한 깊이까지 재귀적으로 이어붙인 새로운 배열을 생성한다. 123456789101112131415const arr1 = [1, 2, [3, 4]];arr1.flat();// [1, 2, 3, 4]const arr2 = [1, 2, [3, 4, [5, 6]]];arr2.flat();// [1, 2, 3, 4, [5, 6]]const arr3 = [1, 2, [3, 4, [5, 6]]];arr3.flat(2);// [1, 2, 3, 4, 5, 6]const arr4 = [1, 2, [3, 4, [5, 6, [7, 8, [9, 10]]]]];arr4.flat(Infinity);// [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]const arr5 = [1, 2, , 4, 5]; // 빈 칸 제거 기능도 있다.arr5.flat();// [1, 2, 4, 5] flatMap 매핑함수를 사용해 각 엘리먼트에 대해 map을 수행 후, 결과를 새로운 배열로 평탄화 한다. 12345678let arr1 = [1, 2, 3, 4];arr1.map((x) =&gt; [x * 2]);// [[2], [4], [6], [8]]arr1.flatMap((x) =&gt; [x * 2]);// [2, 4, 6, 8]// 한 레벨만 평탄화됨arr1.flatMap((x) =&gt; [[x * 2]]);// [[2], [4], [6], [8]] 데이터 변경fill 배열의 시작부터 끝까지 정적인 값 하나로 채운다. 123456789const array1 = [1, 2, 3, 4, 5, 6];// fill with 0 from position 2 until position 4console.log(array1.fill(0, 2, 4));// expected output: [1, 2, 0, 0, 5, 6]// fill with 5 from position 1console.log(array1.fill(5, 1));// expected output: [1, 5, 5, 5, 5, 5]console.log(array1.fill(6));// expected output: [6, 6, 6, 6, 6, 6] slice 특정 배열의 처음부터 끝까지 얕은 복사하여 새로운 배열로 반환한다. 12345678910111213const animals = ['ant', 'bison', 'camel', 'duck', 'elephant'];console.log(animals.slice(2));// expected output: Array [&quot;camel&quot;, &quot;duck&quot;, &quot;elephant&quot;]console.log(animals.slice(2, 4));// expected output: Array [&quot;camel&quot;, &quot;duck&quot;]console.log(animals.slice(1, 5));// expected output: Array [&quot;bison&quot;, &quot;camel&quot;, &quot;duck&quot;, &quot;elephant&quot;]console.log(animals.slice(-2));// expected output: Array [&quot;duck&quot;, &quot;elephant&quot;]console.log(animals.slice(2, -1));// expected output: Array [&quot;camel&quot;, &quot;duck&quot;]console.log(animals.slice());// expected output: Array [&quot;ant&quot;, &quot;bison&quot;, &quot;camel&quot;, &quot;duck&quot;, &quot;elephant&quot;] splice 배열의 기존 요소를 삭제 또는 교체하거나 새 요소를 추가하여 배열의 내용을 변경한다. 123456789const months = ['Jan', 'March', 'April', 'June'];months.splice(1, 0, 'Feb');// inserts at index 1console.log(months);// expected output: Array [&quot;Jan&quot;, &quot;Feb&quot;, &quot;March&quot;, &quot;April&quot;, &quot;June&quot;]months.splice(4, 1, 'May');// replaces 1 element at index 4console.log(months);// expected output: Array [&quot;Jan&quot;, &quot;Feb&quot;, &quot;March&quot;, &quot;April&quot;, &quot;May&quot;] sort 기본 정렬 순서는 문자열의 유니코드 코드 포인트를 따른다. 123456789const months = ['March', 'Jan', 'Feb', 'Dec'];months.sort();console.log(months);// expected output: Array [&quot;Dec&quot;, &quot;Feb&quot;, &quot;Jan&quot;, &quot;March&quot;]const array1 = [1, 30, 4, 21, 100000];array1.sort();console.log(array1);// expected output: Array [1, 100000, 21, 30, 4] 12345678910function compare(a, b) { if (a is less than b by some ordering criterion) { return -1; } if (a is greater than b by the ordering criterion) { return 1; } // a must be equal to b return 0;} reverse 배열의 순서를 반전한다. 123456789const array1 = ['one', 'two', 'three'];console.log('array1:', array1);// expected output: &quot;array1:&quot; [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;]const reversed = array1.reverse();console.log('reversed:', reversed);// expected output: &quot;reversed:&quot; [&quot;three&quot;, &quot;two&quot;, &quot;one&quot;]// Careful: reverse is destructive -- it changes the original array.console.log('array1:', array1);// expected output: &quot;array1:&quot; [&quot;three&quot;, &quot;two&quot;, &quot;one&quot;] 배열로 변경, 혹은 배열을 변경from 유사 배열 객체나 반복 가능한 객체를 얕게 복사해 새로운 Array를 만든다. 1234console.log(Array.from('foo'));// expected output: [&quot;f&quot;, &quot;o&quot;, &quot;o&quot;]console.log(Array.from([1, 2, 3], (x) =&gt; x + x));// expected output: [2, 4, 6] Set에서 배열 만들기 123const s = new Set(['foo', window]);Array.from(s);// [&quot;foo&quot;, window] join 배열의 모든 요소를 연결해 하나의 문자열로 만든다. 1234567const elements = ['Fire', 'Air', 'Water'];console.log(elements.join());// expected output: &quot;Fire,Air,Water&quot;console.log(elements.join(''));// expected output: &quot;FireAirWater&quot;console.log(elements.join('-'));// expected output: &quot;Fire-Air-Water&quot; toString 지정된 배열 및 요소를 나타내는 문자열을 반환한다. 1234const array1 = [1, 2, 'a', '1a'];console.log(array1.toString());// expected output: &quot;1,2,a,1a&quot; 배열 데이터 반복map 배열 내의 모든 요소 각각에 대해 주어진 함수를 호출한 결과를 모아 새로운 배열로 반환한다. 1234const array1 = [1, 4, 9, 16];const map1 = array1.map((x, index, array) =&gt; x * 2);console.log(map1);// expected output: [2, 8, 18, 32] filter 주어진 함수의 테스트를 통과하는 모든 요소를 모아 새로운 배열로 반환한다. 1234const words = ['spray', 'limit', 'elite', 'exuberant', 'destruction', 'present'];const result = words.filter((word, index, arr) =&gt; word.length &gt; 6);console.log(result);// expected output: [&quot;exuberant&quot;, &quot;destruction&quot;, &quot;present&quot;] reduce 각 요소에 대해 주어진 함수를 실행하고, 하나의 결과 값을 반환한다. 12345678const array1 = [1, 2, 3, 4];const reducer = (previousValue, currentValue) =&gt; previousValue + currentValue;// 1 + 2 + 3 + 4console.log(array1.reduce(reducer));// expected output: 10// 5 + 1 + 2 + 3 + 4console.log(array1.reduce(reducer, 5));// expected output: 15","link":"/2021/12/02/%EC%BD%94%EB%94%A9%ED%85%8C%EC%8A%A4%ED%8A%B8%EB%A5%BC-%EC%9C%84%ED%95%9C-%EA%B8%B0%EC%B4%88-Javascript-%EB%AC%B8%EB%B2%95-%EC%A0%95%EB%A6%AC-Array/"},{"title":"코딩테스트를 위한 기초 Javascript 문법 정리 Math","text":"코딩테스트에서 자주 사용하는 Math methods (참고자료) https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Math 여러 메소드의 기초 사용법을 유형별로 정리한다. PropertiesMath.E 자연로그의 밑 값 e를 나타내며, 약 2.718이다. 123456789function compoundOneYear(interestRate, currentVal) { return currentVal * Math.E ** interestRate;}console.log(Math.E);// expected output: 2.718281828459045console.log((1 + 1 / 1000000) ** 1000000);// expected output: 2.718280469 (approximately)console.log(compoundOneYear(0.05, 100));// expected output: 105.12710963760242 Math.LN10 10의 자연로그 값, 약 2.302의 값이다. 12345function getNatLog10() { return Math.LN10;}console.log(getNatLog10());// expected output: 2.302585092994046 Math.LN2 2의 자연로그 값, 약 0.693의 값이다. 12345function getNatLog2() { return Math.LN2;}console.log(getNatLog2());// expected output: 0.6931471805599453 Math.LOG10E e의 로그 10 값, 약 0.434의 값이다. 12345function getLog10e() { return Math.LOG10E;}console.log(getLog10e());// expected output: 0.4342944819032518 Math.LOG2E e의 로그 2 값, 약 1.442의 값이다. 12345function getLog2e() { return Math.LOG2E;}console.log(getLog2e());// expected output: 1.4426950408889634 Math.PI 원의 둘레와 지름의 비율, 약 3.14159의 값이다. 1234567function calculateCircumference(radius) { return 2 * Math.PI * radius;}console.log(Math.PI);// expected output: 3.141592653589793console.log(calculateCircumference(10));// expected output: 62.83185307179586 Math.SQRT1_2 약 0.707의 값을 나타내는 루트 1/2이다. 12345function getRoot1Over2() { return Math.SQRT1_2;}console.log(getRoot1Over2());// expected output: 0.7071067811865476 Math.SQRT2 2의 제곱근을 나타내고 약 1.414이다. 1234function getRoot2() { return Math.SQRT2;}getRoot2(); // 1.4142135623730951 Methodsmax 입력값으로 받은 0개 이상의 숫자 중 가장 큰 숫자를 반환한다. 1234567console.log(Math.max(1, 3, 2));// expected output: 3console.log(Math.max(-1, -3, -2));// expected output: -1const array1 = [1, 3, 2];console.log(Math.max(...array1));// expected output: 3 min 입력값으로 받은 0개 이상의 숫자 중 가장 작은 숫자를 반환한다. abs 주어진 숫자의 절댓값을 반환한다. 123456789function difference(a, b) { return Math.abs(a - b);}console.log(difference(3, 5));// expected output: 2console.log(difference(5, 3));// expected output: 2console.log(difference(1.23456, 7.89012));// expected output: 6.6555599999999995 pow base에 exponent를 제곱한 값을 반환한다. 123456789console.log(Math.pow(7, 3));// expected output: 343console.log(Math.pow(4, 0.5));// expected output: 2console.log(Math.pow(7, -2));// expected output: 0.02040816326530612// (1/49)console.log(Math.pow(-7, 0.5));// expected output: NaN sqrt 숫자의 제곱근을 반환한다. 12345Math.sqrt(9); // 3Math.sqrt(2); // 1.414213562373095Math.sqrt(1); // 1Math.sqrt(0); // 0Math.sqrt(-1); // NaN cbrt 주어진 수의 세제곱근을 반환한다. 123456789Math.cbrt(NaN); // NaNMath.cbrt(-1); // -1Math.cbrt(-0); // -0Math.cbrt(-Infinity); // -InfinityMath.cbrt(0); // 0Math.cbrt(1); // 1Math.cbrt(Infinity); // InfinityMath.cbrt(null); // 0Math.cbrt(2); // 1.2599210498948734 round 입력값을 반올림한 수와 가장 가까운 정수 값을 반환한다. 123456console.log(Math.round(0.9));// expected output: 1console.log(Math.round(5.95), Math.round(5.5), Math.round(5.05));// expected output: 6 6 5console.log(Math.round(-5.05), Math.round(-5.5), Math.round(-5.95));// expected output: -5 -5 -6 ceil 주어진 숫자보다 크거나 같은 숫자 증 가장 작은 숫자를 integer로 반환한다. 123456Math.ceil(0.95); // 1Math.ceil(4); // 4Math.ceil(7.004); // 8Math.ceil(-0.95); // -0Math.ceil(-4); // -4Math.ceil(-7.004); // -7 floor 주어진 숫자와 같거나 작은 정수 중에서 가장 큰 수를 반환한다. 12345678console.log(Math.floor(5.95));// expected output: 5console.log(Math.floor(5.05));// expected output: 5console.log(Math.floor(5));// expected output: 5console.log(Math.floor(-5.05));// expected output: -6 trunc 주어진 값의 소수부분을 제거하고 숫자의 정수부분을 반환한다. 12345678console.log(Math.trunc(13.37));// expected output: 13console.log(Math.trunc(42.84));// expected output: 42console.log(Math.trunc(0.123));// expected output: 0console.log(Math.trunc(-0.123));// expected output: -0 12345678Math.trunc(13.37); // 13Math.trunc(42.84); // 42Math.trunc(0.123); // 0Math.trunc(-0.123); // -0Math.trunc('-1.123'); // -1Math.trunc(NaN); // NaNMath.trunc('foo'); // NaNMath.trunc(); // NaN sign 주어진 수의 부호를 나타내는 +/-1을 반환한다. 12345678console.log(Math.sign(3));// expected output: 1console.log(Math.sign(-3));// expected output: -1console.log(Math.sign(0));// expected output: 0console.log(Math.sign('-3'));// expected output: -1 log212345678console.log(Math.log2(3));// expected output: 1.584962500721156console.log(Math.log2(2));// expected output: 1console.log(Math.log2(1));// expected output: 0console.log(Math.log2(0));// expected output: -Infinity log1012345678console.log(Math.log10(100000));// expected output: 5console.log(Math.log10(2));// expected output: 0.3010299956639812console.log(Math.log10(1));// expected output: 0console.log(Math.log10(0));// expected output: -Infinity exp x를 인수로 하는 e^x 값을 반환한다. 12345678console.log(Math.exp(0));// expected output: 1console.log(Math.exp(1));// expected output: 2.718281828459 (approximately)console.log(Math.exp(-1));// expected output: 0.36787944117144233console.log(Math.exp(2));// expected output: 7.38905609893065 random 0 이상 1 미만의 구간에서 근사적으로 균일한(approximately uniform) 부동소숫점 의사난수를 반환한다. 123456// 두 값 사이의 정수 난수 생성function getRandomInt(min, max) { min = Math.ceil(min); max = Math.floor(max); return Math.floor(Math.random() * (max - min)) + min; //최댓값은 제외, 최솟값은 포함}","link":"/2022/02/03/%EC%BD%94%EB%94%A9%ED%85%8C%EC%8A%A4%ED%8A%B8%EB%A5%BC-%EC%9C%84%ED%95%9C-%EA%B8%B0%EC%B4%88-Javascript-%EB%AC%B8%EB%B2%95-%EC%A0%95%EB%A6%AC-Math/"},{"title":"텔레그램 봇 시작하기","text":"텔레그램을 이용하여 간단한 봇 구현 텔레그램에서 BotFather 검색 봇 생성 /newbot 이미 생성된 봇 이름은 선택할 수 없으며, bot으로 끝나는 이름을 선택한다. HTTP API를 이용하여 연결하므로 이를 기록해둔다. 봇 입장 생성한 봇 이름을 검색하여 생성한 봇과 채팅을 할 수 있다. 현재는 서버를 생성하지 않았으므로, 아무 작업을 하지 않는다. 텔레그램 봇 서버 구축 Node.js를 이용하여 봇 서버를 구축한다. https://www.npmjs.com/package/node-telegram-bot-api 프로젝트를 생성한 후 다음과 같이 터미널에 입력한다. 1npm init package.json에 다음과 같은 종속성을 추가한다. 1234567{ &quot;dependencies&quot;: { &quot;ip&quot;: &quot;^1.1.5&quot;, &quot;node-telegram-bot-api&quot;: &quot;^0.54.0&quot;, &quot;request&quot;: &quot;^2.88.2&quot; }} telegram.js 파일을 생성한 후 다음과 같은 코드를 작성한다. 1234567891011121314151617181920212223const request = require('request');const ip = require('ip');const TelegramBot = require('node-telegram-bot-api');const fs = require('fs');const token = fs.readFileSync(__dirname + '/token.txt', 'utf8');const bot = new TelegramBot(token, { polling: true });bot.onText(/\\/echo (.+)/, (msg, match) =&gt; { const chatId = msg.chat.id; const resp = match[1]; bot.sendMessage(chatId, resp);});bot.on('message', (msg) =&gt; { const chatId = msg.chat.id; console.log(chatId); request.get({ url: 'https://api.ipify.org' }, function (_1, _2, body) { bot.sendMessage(chatId, 'Public IP address &gt; ' + body + '\\nVirtual IP address &gt; ' + ip.address()); });}); token.txt 파일을 생성한 후 생성한 텔레그램 봇의 HTTP API를 입력한다. 코드 상에서 작성해도 문제없지만, 보안을 위한 작업이다. 봇 서버를 실행한다. 1node telegram.js 텔레그램 봇 테스트 봇에게 채팅을 하면, 텔레그램 봇이 돌아가고 있는 서버의 주소를 반환한다.","link":"/2021/11/24/%ED%85%94%EB%A0%88%EA%B7%B8%EB%9E%A8-%EB%B4%87-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/"},{"title":"코딩테스트를 위한 기초 Javascript 문법 정리 String","text":"코딩테스트에서 자주 사용하는 String methods (참고자료) https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/String 여러 메소드의 기초 사용법을 유형별로 정리한다. 문자열의 길이length 문자열의 길이를 나타낸다. 123const str = 'Life, the universe and everything. Answer:';console.log(`${str} ${str.length}`);// expected output: &quot;Life, the universe and everything. Answer: 42&quot; 특정 인덱스의 데이터 반환at1234567const sentence = 'The quick brown fox jumps over the lazy dog.';let index = 5;console.log(`Using an index of ${index} the character returned is ${sentence.at(index)}`);// expected output: &quot;Using an index of 5 the character returned is u&quot;index = -4;console.log(`Using an index of ${index} the character returned is ${sentence.at(index)}`);// expected output: &quot;Using an index of -4 the character returned is d&quot; charAt 문자열에서 특정 인덱스에 위치하는 유니코드 단일문자를 반환한다. 1234const sentence = 'The quick brown fox jumps over the lazy dog.';const index = 4;console.log(`The character at index ${index} is ${sentence.charAt(index)}`);// expected output: &quot;The character at index 4 is q&quot; charCodeAt 주어진 인덱스에 대한 UTF-16 코드를 나타내는 0 ~ 65535 사이의 정수를 반환한다. 1234const sentence = 'The quick brown fox jumps over the lazy dog.';const index = 4;console.log(`The character code ${sentence.charCodeAt(index)} is equal to ${sentence.charAt(index)}`);// expected output: &quot;The character code 113 is equal to q&quot; 문자열 병합concat 매개변수로 전달된 모든 문자열을 호출 문자열에 붙인 새로운 문자열을 반환한다. 123456const str1 = 'Hello';const str2 = 'World';console.log(str1.concat(' ', str2));// expected output: &quot;Hello World&quot;console.log(str2.concat(', ', str1));// expected output: &quot;World, Hello&quot; 문자열 탐색 (조건문)startsWith 어떤 문자열이 특정 문자로 시작하는 지 확인하여 결과를 true 또는 false로 반환한다. 탐색을 시작할 위치를 지정할 수 있다. 1234var str = 'To be, or not to be, that is the question.';console.log(str.startsWith('To be')); // trueconsole.log(str.startsWith('not to be')); // falseconsole.log(str.startsWith('not to be', 10)); // true endsWith 어떤 문자열에서 특정 문자열로 끝나는지를 확인한다. 1234var str = 'To be, or not to be, that is the question.';console.log(str.endsWith('question.')); // trueconsole.log(str.endsWith('to be')); // falseconsole.log(str.endsWith('to be', 19)); // true, 19는 찾고자하는 문자열의 길이값이며, 기본값은 문자열 전체길이이다. includes 하나의 문자열이 다른 문자열에 포함되어 있는지를 판별하고, 결과를 true 또는 false로 반환한다. 대소문자를 구분한다. 1234const sentence = 'The quick brown fox jumps over the lazy dog.';const word = 'fox';console.log(`The word &quot;${word}&quot; ${sentence.includes(word) ? 'is' : 'is not'} in the sentence`);// expected output: &quot;The word &quot;fox&quot; is in the sentence&quot; 123456var str = 'To be, or not to be, that is the question.';console.log(str.includes('To be')); // trueconsole.log(str.includes('question')); // trueconsole.log(str.includes('nonexistent')); // falseconsole.log(str.includes('To be', 1)); // falseconsole.log(str.includes('TO BE')); // false indexOf String 객체에서 주어진 값과 일치하는 첫번째 인덱스를 반환한다. 1234567const paragraph = 'The quick brown fox jumps over the lazy dog. If the dog barked, was it really lazy?';const searchTerm = 'dog';const indexOfFirst = paragraph.indexOf(searchTerm);console.log(`The index of the first &quot;${searchTerm}&quot; from the beginning is ${indexOfFirst}`);// expected output: &quot;The index of the first &quot;dog&quot; from the beginning is 40&quot;console.log(`The index of the 2nd &quot;${searchTerm}&quot; is ${paragraph.indexOf(searchTerm, indexOfFirst + 1)}`);// expected output: &quot;The index of the 2nd &quot;dog&quot; is 52&quot; lastIndexOf 일치하는 부분을 fromIndex로부터 역순으로 탐색하여 최초로 마주치는 인덱스를 반환한다. 1234const paragraph = 'The quick brown fox jumps over the lazy dog. If the dog barked, was it really lazy?';const searchTerm = 'dog';console.log(`The index of the first &quot;${searchTerm}&quot; from the end is ${paragraph.lastIndexOf(searchTerm)}`);// expected output: &quot;The index of the first &quot;dog&quot; from the end is 52&quot; 문자열 탐색 (정규식)match 문자열이 정규식과 매치되는 부분을 검색한다. 12345var str = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz';var regexp = /[A-E]/gi;var matches_array = str.match(regexp);console.log(matches_array);// ['A', 'B', 'C', 'D', 'E', 'a', 'b', 'c', 'd', 'e'] 정규식이 아닌 객체를 매개변수로 사용할 수 있다. 1234567891011var str1 = 'NaN means not a number. Infinity contains -Infinity and +Infinity in JavaScript.', str2 = 'My grandfather is 65 years old and My grandmother is 63 years old.', str3 = 'The contract was declared null and void.';str1.match('number'); // &quot;number&quot;는 문자열임. [&quot;number&quot;]를 반환함.str1.match(NaN); // NaN 타입은 숫자형임. [&quot;NaN&quot;]을 반환함.str1.match(Infinity); // Infinity 타입은 숫자형임. [&quot;Infinity&quot;]를 반환함.str1.match(+Infinity); // [&quot;Infinity&quot;]를 반환함.str1.match(-Infinity); // [&quot;-Infinity&quot;]를 반환함.str2.match(65); // [&quot;65&quot;]를 반환함str2.match(+65); // 플러스 기호가 붙은 숫자형. [&quot;65&quot;]를 반환함.str3.match(null); // [&quot;null&quot;]을 반환함. matchAll1234567const regexp = /t(e)(st(\\d?))/g;const str = 'test1test2';const array = [...str.matchAll(regexp)];console.log(array[0]);// expected output: Array [&quot;test1&quot;, &quot;e&quot;, &quot;st1&quot;, &quot;1&quot;]console.log(array[1]);// expected output: Array [&quot;test2&quot;, &quot;e&quot;, &quot;st2&quot;, &quot;2&quot;] search 정규 표현식과 String 객체간의 같은 것을 찾는다. 첫번째로 매치되는 것의 인덱스를 반환한다. (없다면 -1) 1234567const paragraph = 'The quick brown fox jumps over the lazy dog. If the dog barked, was it really lazy?';// any character that is not a word character or whitespaceconst regex = /[^\\w\\s]/g;console.log(paragraph.search(regex));// expected output: 43console.log(paragraph[paragraph.search(regex)]);// expected output: &quot;.&quot; 문자열 채우기padStart 현재 문자열에 다른 문자열을 채워 주어진 길이를 만족하는 새로운 문자열을 반환한다. 채워넣기는 처음부터 적용된다. 12345678910111213const str1 = '5';console.log(str1.padStart(2, '0'));// expected output: &quot;05&quot;const fullNumber = '2034399002125581';const last4Digits = fullNumber.slice(-4);const maskedNumber = last4Digits.padStart(fullNumber.length, '*');console.log(maskedNumber);// expected output: &quot;************5581&quot;'abc'.padStart(10); // &quot; abc&quot;'abc'.padStart(10, 'foo'); // &quot;foofoofabc&quot;'abc'.padStart(6, '123465'); // &quot;123abc&quot;'abc'.padStart(8, '0'); // &quot;00000abc&quot;'abc'.padStart(1); // &quot;abc&quot; padEnd 현재 문자열에 다른 문자열을 채워 주어진 길이를 만족하는 새로운 문자열을 반환한다. 채워넣기는 끝부터 적용된다. 12345678910const str1 = 'Breaded Mushrooms';console.log(str1.padEnd(25, '.'));// expected output: &quot;Breaded Mushrooms........&quot;const str2 = '200';console.log(str2.padEnd(5));// expected output: &quot;200 &quot;'abc'.padEnd(10); // &quot;abc &quot;'abc'.padEnd(10, 'foo'); // &quot;abcfoofoof&quot;'abc'.padEnd(6, '123456'); // &quot;abc123&quot;'abc'.padEnd(1); // &quot;abc&quot; repeat 문자열을 주어진 횟수만큼 반복해 붙인 새로운 문자열을 반환한다. 12345678'abc'.repeat(-1); // RangeError'abc'.repeat(0); // '''abc'.repeat(1); // 'abc''abc'.repeat(2); // 'abcabc''abc'.repeat(3.5); // 'abcabcabc' (count will be converted to integer)'abc'.repeat(1 / 0); // RangeError({ toString: () =&gt; 'abc', repeat: String.prototype.repeat }.repeat(2));// 'abcabc' (repeat() is a generic method) trim 문자열 양 끝 공백을 제거한다. 공백이란 모든 공백문자(space, tab, NBSP 등)와 모든 개행문자(LF, CR 등)를 의미한다. 123456const greeting = ' Hello world! ';console.log(greeting);// expected output: &quot; Hello world! &quot;;console.log(greeting.trim());// expected output: &quot;Hello world!&quot;; trimStart 문자열 시작 부분의 공백을 제거한다. trimLeft라는 별칭으로 호출 가능하다. 123456const greeting = ' Hello world! ';console.log(greeting);// expected output: &quot; Hello world! &quot;;console.log(greeting.trimStart());// expected output: &quot;Hello world! &quot;; trimEnd 문자열 끝 부분의 공백을 제거한다. trimRight라는 별칭으로 호출 가능하다. 123456const greeting = ' Hello world! ';console.log(greeting);// expected output: &quot; Hello world! &quot;;console.log(greeting.trimEnd());// expected output: &quot; Hello world!&quot;; 문자열 일부분 변경replace 어떤 패턴에 일치하는 일부 또는 모든 부분이 교체된 새로운 문자열을 반환한다. 패턴이 문자열인 경우에는 첫번째 문자열만 치환된다. 123456const p = 'The quick brown fox jumps over the lazy dog. If the dog reacted, was it really lazy?';console.log(p.replace('dog', 'monkey'));// expected output: &quot;The quick brown fox jumps over the lazy monkey. If the dog reacted, was it really lazy?&quot;const regex = /Dog/i;console.log(p.replace(regex, 'ferret'));// expected output: &quot;The quick brown fox jumps over the lazy ferret. If the dog reacted, was it really lazy?&quot; replaceAll1234567const p = 'The quick brown fox jumps over the lazy dog. If the dog reacted, was it really lazy?';console.log(p.replaceAll('dog', 'monkey'));// expected output: &quot;The quick brown fox jumps over the lazy monkey. If the monkey reacted, was it really lazy?&quot;// global flag required when calling replaceAll with regexconst regex = /Dog/gi;console.log(p.replaceAll(regex, 'ferret'));// expected output: &quot;The quick brown fox jumps over the lazy ferret. If the ferret reacted, was it really lazy?&quot; 문자열 자르기slice 문자열의 일부를 추출하면서 새로운 문자열을 반환한다. 123456789const str = 'The quick brown fox jumps over the lazy dog.';console.log(str.slice(31));// expected output: &quot;the lazy dog.&quot;console.log(str.slice(4, 19));// expected output: &quot;quick brown fox&quot;console.log(str.slice(-4));// expected output: &quot;dog.&quot;console.log(str.slice(-9, -5));// expected output: &quot;lazy&quot; 123456789var str1 = 'The morning is upon us.', // the length of str1 is 23. str2 = str1.slice(1, 8), str3 = str1.slice(4, -2), str4 = str1.slice(12), str5 = str1.slice(30);console.log(str2); // OUTPUT: he mornconsole.log(str3); // OUTPUT: morning is upon uconsole.log(str4); // OUTPUT: is upon us.console.log(str5); // OUTPUT: &quot;&quot; split 문자열을 구분자를 이용해서 여러개의 문자열로 나눈다. 12345678910const str = 'The quick brown fox jumps over the lazy dog.';const words = str.split(' ');console.log(words[3]);// expected output: &quot;fox&quot;const chars = str.split('');console.log(chars[8]);// expected output: &quot;k&quot;const strCopy = str.split();console.log(strCopy);// expected output: Array [&quot;The quick brown fox jumps over the lazy dog.&quot;] 대소문자 변경toLowerCase 문자열을 소문자로 반환한다. 123const sentence = 'The quick brown fox jumps over the lazy dog.';console.log(sentence.toLowerCase());// expected output: &quot;the quick brown fox jumps over the lazy dog.&quot; toUpperCase 문자열을 대문자로 반환한다. 123const sentence = 'The quick brown fox jumps over the lazy dog.';console.log(sentence.toUpperCase());// expected output: &quot;THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG.&quot;","link":"/2022/02/03/%EC%BD%94%EB%94%A9%ED%85%8C%EC%8A%A4%ED%8A%B8%EB%A5%BC-%EC%9C%84%ED%95%9C-%EA%B8%B0%EC%B4%88-Javascript-%EB%AC%B8%EB%B2%95-%EC%A0%95%EB%A6%AC-String/"}],"tags":[{"name":"API Gateway","slug":"API-Gateway","link":"/tags/API-Gateway/"},{"name":"AWS","slug":"AWS","link":"/tags/AWS/"},{"name":"EC2","slug":"EC2","link":"/tags/EC2/"},{"name":"Lambda","slug":"Lambda","link":"/tags/Lambda/"},{"name":"lightsail","slug":"lightsail","link":"/tags/lightsail/"},{"name":"S3","slug":"S3","link":"/tags/S3/"},{"name":"Blockchain","slug":"Blockchain","link":"/tags/Blockchain/"},{"name":"Windows","slug":"Windows","link":"/tags/Windows/"},{"name":"DynamoDB","slug":"DynamoDB","link":"/tags/DynamoDB/"},{"name":"Node.js","slug":"Node-js","link":"/tags/Node-js/"},{"name":"docker","slug":"docker","link":"/tags/docker/"},{"name":"git Blog","slug":"git-Blog","link":"/tags/git-Blog/"},{"name":"Git","slug":"Git","link":"/tags/Git/"},{"name":"HTTPS","slug":"HTTPS","link":"/tags/HTTPS/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"javascript","slug":"javascript","link":"/tags/javascript/"},{"name":"Promise","slug":"Promise","link":"/tags/Promise/"},{"name":"Asynchronous","slug":"Asynchronous","link":"/tags/Asynchronous/"},{"name":"Raspberry Pi","slug":"Raspberry-Pi","link":"/tags/Raspberry-Pi/"},{"name":"gpio","slug":"gpio","link":"/tags/gpio/"},{"name":"mysql","slug":"mysql","link":"/tags/mysql/"},{"name":"Telegram","slug":"Telegram","link":"/tags/Telegram/"},{"name":"Code-server","slug":"Code-server","link":"/tags/Code-server/"},{"name":"MPU9250","slug":"MPU9250","link":"/tags/MPU9250/"},{"name":"I2C","slug":"I2C","link":"/tags/I2C/"},{"name":"typescript","slug":"typescript","link":"/tags/typescript/"},{"name":"Ubuntu","slug":"Ubuntu","link":"/tags/Ubuntu/"},{"name":"VSCode","slug":"VSCode","link":"/tags/VSCode/"},{"name":"Error","slug":"Error","link":"/tags/Error/"},{"name":"Remote-SSH","slug":"Remote-SSH","link":"/tags/Remote-SSH/"},{"name":"Morse code","slug":"Morse-code","link":"/tags/Morse-code/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"Coding test","slug":"Coding-test","link":"/tags/Coding-test/"}],"categories":[{"name":"AWS","slug":"AWS","link":"/categories/AWS/"},{"name":"Blockchain","slug":"Blockchain","link":"/categories/Blockchain/"},{"name":"Windows","slug":"Windows","link":"/categories/Windows/"},{"name":"Node.js","slug":"Node-js","link":"/categories/Node-js/"},{"name":"docker","slug":"docker","link":"/categories/docker/"},{"name":"Git Blog","slug":"Git-Blog","link":"/categories/Git-Blog/"},{"name":"Git","slug":"Git","link":"/categories/Git/"},{"name":"HTTPS","slug":"HTTPS","link":"/categories/HTTPS/"},{"name":"Python","slug":"Python","link":"/categories/Python/"},{"name":"Javascript","slug":"Javascript","link":"/categories/Javascript/"},{"name":"Asynchronous","slug":"Javascript/Asynchronous","link":"/categories/Javascript/Asynchronous/"},{"name":"Promise","slug":"Javascript/Promise","link":"/categories/Javascript/Promise/"},{"name":"Raspberry Pi","slug":"Raspberry-Pi","link":"/categories/Raspberry-Pi/"},{"name":"Typescript","slug":"Typescript","link":"/categories/Typescript/"},{"name":"Ubuntu","slug":"Ubuntu","link":"/categories/Ubuntu/"},{"name":"VSCode","slug":"VSCode","link":"/categories/VSCode/"},{"name":"Ubuntu","slug":"Windows/Ubuntu","link":"/categories/Windows/Ubuntu/"},{"name":"Development","slug":"Development","link":"/categories/Development/"},{"name":"Linux","slug":"Linux","link":"/categories/Linux/"},{"name":"Coding test","slug":"Coding-test","link":"/categories/Coding-test/"},{"name":"Node.js","slug":"Raspberry-Pi/Node-js","link":"/categories/Raspberry-Pi/Node-js/"},{"name":"Python","slug":"Raspberry-Pi/Python","link":"/categories/Raspberry-Pi/Python/"},{"name":"docker","slug":"Raspberry-Pi/docker","link":"/categories/Raspberry-Pi/docker/"},{"name":"Error","slug":"VSCode/Error","link":"/categories/VSCode/Error/"},{"name":"Code-server","slug":"Development/Code-server","link":"/categories/Development/Code-server/"},{"name":"Ubuntu","slug":"Linux/Ubuntu","link":"/categories/Linux/Ubuntu/"},{"name":"Javascript","slug":"Coding-test/Javascript","link":"/categories/Coding-test/Javascript/"}]}