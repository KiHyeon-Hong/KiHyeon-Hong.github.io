{"pages":[{"title":"","text":"body { background-color: #95c2de; } .mainbox { background-color: #95c2de; margin: auto; height: 600px; width: 600px; position: relative; } .err { color: #ffffff; font-family: 'Nunito Sans', sans-serif; font-size: 11rem; position:absolute; left: 20%; top: 8%; } .far { position: absolute; font-size: 8.5rem; left: 42%; top: 15%; color: #ffffff; } .err2 { color: #ffffff; font-family: 'Nunito Sans', sans-serif; font-size: 11rem; position:absolute; left: 68%; top: 8%; } .msg { text-align: center; font-family: 'Nunito Sans', sans-serif; font-size: 1.6rem; position:absolute; left: 16%; top: 45%; width: 75%; } a { text-decoration: none; color: white; } a:hover { text-decoration: underline; } 4 4 블로그에 없는 URL입니다. 메인화면으로 갑니다.","link":"/404.html"},{"title":"about","text":"","link":"/about/index.html"}],"posts":[{"title":"API 게이트웨이 시작하기","text":"API 게이트웨이는 HTTP 프로토콜을 이용하여 API를 개발자가 손쉽게 구축할 수 있는 완전 관리형 서비스입니다. 실습 요약 API 게이트웨이용 람다 함수 생성A. 람다 함수 생성(람다 함수 이름 : lambda_for_apigateway_get)B. 람다 함수 실행 역할 생성(람다 함수 역할 이름 : role_for_apigateway) API 게이트웨이용 람다 이벤트 구성 람다 함수 소스코드 작성 다이나모 DB 서비스 실행 권한을 위한 IAM 생성A. 정책 생성 및 검토(정책 이름 : policy_dynamodb_crud)B. 역할 생성(역할 이름 : role_for_apigateway_get) 다이나모 DB 생성 람다 함수 수정 API Gateway 테스트 및 다이나모 DB GET 확인 AWS 콘솔에서 람다 함수를 선택하고, 함수 생성을 선택 함수 이름을 lambda_for_apigateway_get로 지정 권한은 AWS 정책 템플릿에서 새 역할 생성을 선택 역할 이름은 role_for_apigateway 정책 템플릿은 Lambda@Edge 선택 람다 함수 에디터 부분의 코드를 다음과 같이 입력 1234567exports.handler = async (event) =&gt; { const response = { statusCode: 200, body: JSON.stringify(event.queryStringParameters), }; return response;}; 추가 트리거를 선택한 후 API 게이트웨이를 선택 API 생성을 선택한 후 보안을 열기로 선택 추기를 선택하면 다음과 같이 화면이 뜸 API 게이트웨이가 추가되면 기존에는 없던 리소스 경로가 뜸 API 엔드포인트라는 항목과 URL이 나타나는데 함수를 실행시키기 위해 접속해야 하는 주소 ?”key”=”value”&amp;”key”=”value” 형태로 URL 뒤에 붙혀서 URI를 만들어 준다 화면에 GET으로 보내준 파라매터가 뜨는 것을 확인할 수 있음 다이나모DB에 대한 권한을 주기 위해 권한에 들어감 role_for_apigateway_get을 선택하면 다음과 같은 화면이 뜸 정책 연결을 선택 정책 생성을 선택 서비스는 DynamoDB, 리소스는 모든 리소스, 작업은 수동작업으로 모든 DynamoDB 작업을 선택 정책 검토를 선택 정책 이름으로 policy_dynamodb_crud를 입력 정책 생성을 선택 검색에서 이전에 만들었던 role_for_apigateway_get을 입력한 후 표시되는 역할을 선택 요약정보가 뜨며, 정책 연결을 선택 이전에 만든 정책 이름을 입력하여 검색 체크 박스 선택 후 하단 정책 연결 버튼을 선택 policy_dynamodb_crud역할에 role_forapigateway 정책이 성공적으로 연결 이제 람다 함수가 다이나모 DB에 접근 가능함 다이나모DB에서 테이블 만들기를 선택하며, 테이블 이름은 dynamo_apigateway_query를 입력한 후, 기본 키는 id를 입력 테이블 생성 람다 함수로 돌아와서 함수 코드를 다음과 같이 입력 123456789101112131415161718192021222324252627282930313233343536373839404142//aws-sdk를 불러옵니다.const AWS = require('aws-sdk');//다이나모디비 클라이언트를 초기화합니다.const dynamodb = new AWS.DynamoDB.DocumentClient();exports.handler = async (event) =&gt; { //리턴할 값을 선언합니다. let response; //queryStringParameters즉 GET값들이 들어오는지 들어온다면 id가 있는지 체크합니다. if (!event.queryStringParameters || !event.queryStringParameters.id) { response = { statusCode: 400, body: JSON.stringify('id가 없습니다.'), }; return response; } else { let params = { Item: { id: event.queryStringParameters.id, data: event.queryStringParameters, }, TableName: 'dynamo_apigateway_query', }; await dynamodb .put(params) .promise() .catch((e) =&gt; { response = { statusCode: 500, body: JSON.stringify('에러가 발생하였습니다:' + e), }; return response; }); response = { statusCode: 200, body: JSON.stringify('데이터가 성공적으로 저장되었습니다..'), }; return response; }}; queryStringParameter를 인자로 받아 다이나모 DB에 저장하고 GET에이터나 id 값이 없다면 400, 저장하는데 문제가 발생한다면 500, 성공적으로 데이터를 넣었다면 200을 반환 파라매터가 없는경우 파라매터를 정상적을 넣는 경우 다이나오 DB에 들어가보면 데이터가 정상적으로 들어가 있음을 확인할 수 있음 1234{ &quot;text&quot;: &quot;hello world&quot;, &quot;number&quot;: &quot;+821012345678&quot;}","link":"/2020/11/03/API-%EA%B2%8C%EC%9D%B4%ED%8A%B8%EC%9B%A8%EC%9D%B4-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/"},{"title":"API Gateway기반의 번역 웹 서비스","text":"실습 요약 번역 API 게이트웨이용 람다 함수 생성 A. 람다 함수 생성(람다 함수 이름 : lambda_for_translate_Service) B. 람다 함수 실행 역할 생성(람다 역할 이름 : role_for_translate_Service) 람다 함수 소스코드 작성 람다 함수 역할 수정 A. 정책 생성 및 검토(정책 이름 : role_for_translate_Service) B. 기존 관리형 정책 선택(TranslateFullAccess) 람다 API 게이트웨이 설정 index.html 파일 수정 및 S3버킷 생성 S3 버킷에 수정 파일 업로드 번역 서비스 정적 웹 사이트 설정 및 테스트 API 게이트웨이용 람다 함수를 생성한다 함수 이름에 lambda_for_translate_Service를 입력한다 AWS 정책 템플릿에서 새 역할 생성 선택 role_for_translate_Service 입력 정책 템플릿은 ‘기본 Lambda@Edge’ 입력 람다 함수 코드는 다음과 같이 작성 1234567891011121314151617181920212223242526272829303132333435363738394041/* AWS SDK 를 가져옵니다.*/var AWS = require('aws-sdk');AWS.config.update({region: 'us-east-1'});var translate = new AWS.Translate();exports.handler = function(event, context,callback){console.log(JSON.stringify(event.body));const response = JSON.parse(event.body) //event.body로 POST로 받은 데이터를 받습니다. try{ const translateParams = { SourceLanguageCode: 'ko', TargetLanguageCode: 'en', Text: response.text } //translate SDK를 불러옵니다. translate.translateText(translateParams, function (err, data) { if (err) callback(err) callback(null,{ statusCode:200, headers: { &quot;Access-Control-Allow-Origin&quot; : &quot;*&quot;, //S3에서 요청을 할 수 있도록 허용해줍니다. &quot;Access-Control-Allow-Credentials&quot; : true }, body:data.TranslatedText }) }) }catch(e){ callback(null,{ statusCode:200, body:JSON.stringify(e) }) }}; 람다 함수 역할을 수정 권한의 실행 역할에서 role_for_translate_Service 선택 기존에 있는 권한인 TranslateFullAccess를 선택 새롭게 translate로의 접근 권한이 생김 추가 트리거를 통하여 API 게이트웨이를 연간함 API 생성을 선택 보안은 열기로 설정 API 엔드포인트를 보면 주소가 생김 해당 주소가 홈페이지를 통해 서비스르 만들어 요청할 주소 웹 페이지를 다음과 같이 생성 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;번역웹사이트&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://stackpath.bootstrapcdn.com/bootstrap/4.2.1/css/bootstrap.min.css&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col align-self-center&quot;&gt; &lt;h5 id=&quot;resultText&quot;&gt;&lt;/h5&gt; &lt;form action=&quot;javascript:void(0)&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label&gt;텍스트를 입력해주세요.&lt;/label&gt; &lt;textarea class=&quot;form-control&quot; id=&quot;textInput&quot; rows=&quot;3&quot;&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;button onclick=&quot;sendReqeust()&quot; class=&quot;btn btn-primary&quot;&gt;Submit&lt;/button&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;script type=&quot;text/javascript&quot;&gt; var inputSelector = document.querySelector('#textInput'); var resultText = document.querySelector('#resultText'); function sendReqeust() { resultText.innerHTML = &quot;로딩중...&quot; fetch(&quot;https://0pmjclpe95.execute-api.ap-northeast-2.amazonaws.com/default/lambda_for_translate_service&quot;, { method: &quot;POST&quot;, body: JSON.stringify({ text:inputSelector.value }) }).then(function (response) { return response.text().then(function(text) { resultText.innerHTML = text; }); }) }&lt;/script&gt;&lt;/html&gt; 이때, fetch 안에 아까 람다 함수의 API 게이트웨이 엔드포인트를 복사한다. S3 버킷을 생성 버킷 이름은 전세계에서 유일한 이름으로 설정해야 함 이때, 퍼블릭 액세스 차단을 위한 버킷 설정에서 모든 퍼블릭 액세스 차단을 해제하고, 경고문을 체크 해당 버킷에 방금 생성한 index.html 파일을 업로드 한다. 이때 중요한점은 해당 index.html 파일을 퍼블릭으로 설정해야 함 정적 웹 사이트 호스팅 편집에서 활성화를 선택 인덱스 문서로 index.html, 파일은 없지만 오류 문서로 error.html을 입력 버킷 웹 사이트 엔드포인트가 뜨는데, 이것이 바로 번역 사이트의 엔드 포인트 사이트 접속 시 해당 화면이 나오는 것을 볼 수 있음 텍스트 입력 후 submit 선택 시 번역이 작동되는 것을 확인","link":"/2020/11/10/API-Gateway%EA%B8%B0%EB%B0%98%EC%9D%98-%EB%B2%88%EC%97%AD-%EC%9B%B9-%EC%84%9C%EB%B9%84%EC%8A%A4/"},{"title":"DynamoDB 시작하기","text":"관계형 DB vs NO SQL 비교 관계형 DB 정형 데이터 대용량 처리 시 성능 하향 미리 정해진 스키마 존재 트랜잭션을 통해 일관성 유지 보장 조인 등의 복잡한 검색 기능 클러스터 환경에 적합하지 않음 고가의 라이센스 비용 Oracle, MySql, MSSql 등 NO SQL 정형, 반정형, 비정형 데이터 대용량 데이터 처리 지원 스키마가 없거나 변경이 자유로움 트랜잭션 지원하지 않음, 일관성이 보장 어려움(사실, 보장 하지만 관계형 DB보다는 여유롭게 보장) 단순히 데이터 검색 기능 클러스터 환경에 적합 오픈 소스 카산드라, 몽고DB 등 DynamoDB는 크게 쿼리와 스캔이라는 데이터 탐색 방법을 제공 - 쿼리 : 삽입된 기본키를 기준으로 데이터를 찾는 방법 - 스캔 : 조건 값과 맞는 데이터를 찾을 때까지 모든 데이터를 검색 구축 과정 다이나모DB 테이블 만들기 A. 테이블 이름 : univStudent B. 기본키 : univ_name + univ_id 테이블 데이터 추가 데이터 수정 및 삭제 데이터 스캔과 쿼리 테이블 삭제 AWS console에서 DynamoDB를 선택 죄측 대시보드 밑의 테이블을 선택 테이블 만들기를 선택 테이블 이름은 univStudent, 기본키는 univ_name과 univ_id를 선택 후 생성 버튼을 클릭 항목 만들기 선택 내용을 입력 이 때, + 키를 누른 후 append를 클릭하여 데이터를 추가할 수 있음 저장을 클릭 데이터를 여러개 넣을 수 있으며, 형식이 전부 통일되지 않아도 됨 해당 데이터를 선택한 후 작업의 삭제를 통하여 데이터를 삭제할 수 있음 스캔은 조건값이 맞는 데이터를 찾을 때까지 모든 데이터를 탐색해서 어떤 조건 값에 맞는 데이터를 몇 개 찾아와라라는 명령어가 없다고, 모든 데이터를 찾음 필터를 통해서 조건을 줄 수 있음 쿼리는 아무런 값도 없이 검색을 누르면 에러가 발생 쿼리는 기본키를 입력하여 데이터를 검색하는 방법 글로벌 보조 인덱스는 동일한 데이터를 갖지만, 다른 키 값과 정렬키를 갖는 클론 테이블을 만들어서 테이블을 만들때와 같은 처리 용량이 필요함 인덱스를 만드는 시간은 오래 걸리지만 상태가 활성이 되면 완료된 것 스캔을 인덱스로 변경한 후 검색 시작을 선택하면 major가 포함된 데이터만 표시 됨 인덱스를 만든 테이블에서는 major을 기본키로 하기 때문에 원 테이블에서 major가 포함되지 않은 데이터는 가져올 수 가 없음 쿼리는 키 값을 찾아 데이터를 검색하는 방법 원 테이블에서 스캔으로 major을 찾는 것보다 인덱스에서 쿼리로 찾는 것이 처리용량이 더 작음 좌측 상단의 테이블 삭제를 클릭하여 안전하게 테이블을 삭제할 수 있음","link":"/2020/10/13/DynamoDB-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/"},{"title":"EC2를 활용한 Node.js 서버 구축!","text":"실습 요약 EC2, Ubuntu를 이용하여 인스턴스를 생성한다 Node.js를 설치하며, MariaDB를 설치한다. 간단한 예제를 통하여 환경을 테스트 한다. EC2의 새 인스턴스 생성을 통하여 다음과 같은 화면이 나온다. Ubuntu Server 20.04 LTS를 선택한다. 인스턴스 유형은 프리티어이므로 t2.micro를 선택한다. 인스턴스 세부 정보 구성은 건드리지 않는다. 스토리지 추가에서도 아무것도 선택하지 않는다. 태그 추가에서는 키에 Name을 입력하고 값에 TestServer를 입력한다. 이는 추후 인스턴스의 이름이 된다. 보안 그룹 구성에서는 기본으로 SSH가 있을 것이다. HTTP와 HTTPS를 추가하며 소스는 모두가 접근할 수 있도록 0.0.0.0/0을 선택한다. 인스턴스 시작 검토는 현재까지 설정한 정보를 볼 수 있다. 문제가 없다면 시작하기를 선택한다. 키를 발급 받는다. 기존에 가지고 있는 키를 선택해도 되며, 새로운 키를 발급 받아도 된다. 해당 키를 재발급이 불가능 하므로 반드시 저장을 해야한다. 인스턴스가 실행되면 연결 버튼을 통하여 다음의 정보를 얻을 수 있다. 이때 ec2-3-87-0-78.compute-1.amazonaws.com는 우리의 인스턴스의 퍼블릭 Ip의 역할을 한다. 인스턴스 요약을 통하여 5.87.0.78의 ip도 얻을 수 있는데, 이는 위의 ec2-3-87-0-78.compute-1.amazonaws.com와 같다. Putty를 통해 접속을 시도한다. 이때 Connection -&gt; SSH -&gt; Auth에 방금 발급 받은 키를 넣어줘야 한다. 주의할 점은 putty에서는 발급받은 pem이 아니라 ppk로 변환을 해줘야 하는데, 이 부분은 추후에 포스팅 한다. Putty의 Session에 Host Name에 방금 얻은 ec2-3-87-0-78.compute-1.amazonaws.com를 입력한다. 또한, ubuntu 계정으로 접근을 위해 앞에 ubuntu@를 붙인다. ubuntu@ec2-3-87-0-78.compute-1.amazonaws.com 연결을 누르게 되면 ubuntu 계정으로 로그인된 것을 볼 수 있다. Node.js 설치와 MariaDB는 ec2의 ubuntu에서 좀 다르게 설치된다. Node.js 설치법 https://docs.aws.amazon.com/ko_kr/sdk-for-javascript/v2/developer-guide/setting-up-node-on-ec2-instance.html 노드의 설치 방법은 위 사이트에 나와있다. 아래의 코드를 한줄씩 입력한다. curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.34.0/install.sh | bash . ~/.nvm/nvm.sh nvm install node node -e &quot;console.log('Running Node.js ' + process.version)&quot; 위의 명령어를 통해 Node.js가 설치되고, 버전을 확인할 수 있다. Node.js가 설치된 후 다음의 명령어를 통해 예제 코드 실행을 위한 모듈을 설치한다. npm install ejs npm install jade np install express npm install cookie-parser npm install body-parser npm install express-session npm install mysql npm install sync-mysql 한줄씩 입력하여 모듈을 설치한다. MariaDB 설치 https://downloads.mariadb.org/mariadb/repositories MariaDB를 설치하는 코드는 다음과 같다. sudo apt-get install software-properties-common sudo apt-key adv --fetch-keys 'https://mariadb.org/mariadb_release_signing_key.asc' sudo add-apt-repository 'deb [arch=amd64,arm64,ppc64el] https://ftp.harukasan.org/mariadb/repo/10.5/ubuntu focal main' sudo apt update sudo apt install mariadb-server mysql -V 위 코드를 통해 MariaDB가 설치되고 버전을 확인할 수 있다. 접속을 위해 MariaDB의 환경 설정을 해야한다. cd /etc/mysql/mariadb.conf.d sudo cp 50-server.cnf server.cnf.backup sudo vi 50-server.cnf bind-addess = 127.0.0.1을 주석 처리한다. bind-addess = 127.0.0.1 -&gt; #bind-addess = 127.0.0.1 mariaDB를 재시작 시키며, 접속을 위한 비밀번호를 설정 sudo systemctl restart mariadb.service sudo mysqladmin -u root password 'gachon654321' sudo mysql -u root -p Enter password: * set password for root@localhost = password('gachon654321'); use mysql; flush privileges; exit mysql -u root -p gachon654321 예제 페이지를 위해 테이블을 하나 만든다create database mydb; create table member ( name varchar(10), uid varchar(10), pass varchar(10)); Atom으로 접속을 한다. 이때 자세한 환경 세팅은 다음 포스팅에서 실시한다. ftp-remote을 통하여 .ftpconfig 파일을 다음과 같이 작성한다. { &quot;protocol&quot;: &quot;sftp&quot;, &quot;host&quot;: &quot;ec2-3-87-0-78.compute-1.amazonaws.com&quot;, &quot;port&quot;: 22, &quot;user&quot;: &quot;ubuntu&quot;, &quot;promptForPass&quot;: false, &quot;remote&quot;: &quot;/home/ubuntu&quot;, &quot;local&quot;: &quot;&quot;, &quot;agent&quot;: &quot;&quot;, &quot;privatekey&quot;: &quot;C:/users/ghdrl/Desktop/MyFiles/AwsKey/aws_password.pem&quot;, &quot;passphrase&quot;: &quot;&quot;, &quot;hosthash&quot;: &quot;&quot;, &quot;ignorehost&quot;: true, &quot;connTimeout&quot;: 10000, &quot;keepalive&quot;: 10000, &quot;keyboardInteractive&quot;: false, &quot;keyboardInteractiveForPass&quot;: false, &quot;remoteCommand&quot;: &quot;&quot;, &quot;remoteShell&quot;: &quot;&quot;, &quot;watch&quot;: [], &quot;watchTimeout&quot;: 500 } 소스 코드 작성 예제를 돌려보기 위해 소스 코드를 다음과 같이 작성한다. mydbsvr.js const fs = require('fs'); const ejs = require('ejs'); const mysql = require('mysql'); const express = require('express'); const bodyParser = require('body-parser'); // MySQL DB 연결 const client = mysql.createConnection({ host: 'localhost', // DB서버 IP주소 port: 3306, // DB서버 Port주소 user: 'root', // DB접속 아이디 password: 'gachon654321', // DB암호 database: 'mydb' //사용할 DB명 }); // 서버를 생성합니다. const app = express(); app.use(bodyParser.urlencoded({ extended: false })); // 서버를 실행합니다. app.listen(65001, function () { console.log('server running at http://127.0.0.1:65001'); }); app.get('/insert', (request, response) =&gt; { fs.readFile('9-insert.html', 'utf8', (error, data) =&gt; { //회원가입화면 response.send(data); // 회원가입 화면전송 }); }); app.get('/members', (request, response) =&gt; { fs.readFile('9-list.ejs', 'utf8', (error, data) =&gt; { // List화면 // 데이터베이스 쿼리를 실행합니다. client.query('SELECT * FROM member', (error, results) =&gt; { // 응답합니다. response.send(ejs.render(data, { data: results // 회원조회 결과화면 })); }); }); }); app.post('/insert', function (request, response) { // 변수를 선언합니다. var body = request.body; console.log(body.name); console.log(body.uid); console.log(body.pass); // 데이터베이스 쿼리를 실행합니다. client.query('INSERT INTO member (name, uid, pass) VALUES (?, ?, ?)', [body.name, body.uid, body.pass], () =&gt; { console.log(&quot;Insertion into DB was completed !&quot;); response.end(); }); }); 9-insert.html &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;회원가입&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;회원가입&lt;/h1&gt; &lt;hr /&gt; &lt;form method=&quot;post&quot;&gt; &lt;fieldset&gt; &lt;legend&gt;회원가입&lt;/legend&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;&lt;label&gt;이름&lt;/label&gt;&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;name&quot; /&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;label&gt;사용자id&lt;/label&gt;&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;uid&quot; /&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;label&gt;비밀번호&lt;/label&gt;&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;password&quot; name=&quot;pass&quot; /&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;input type=&quot;submit&quot; value = &quot;가입&quot; /&gt; &lt;/fieldset&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; 9-list.ejs &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;List Page&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;List Page&lt;/h1&gt; &lt;hr /&gt; &lt;table width=&quot;100%&quot; border=&quot;1&quot;&gt; &lt;tr&gt; &lt;th&gt;Name&lt;/th&gt; &lt;th&gt;Model Number&lt;/th&gt; &lt;th&gt;Series&lt;/th&gt; &lt;/tr&gt; &lt;% data.forEach(function (item, index) { %&gt; &lt;tr&gt; &lt;td&gt;&lt;%= item.name %&gt;&lt;/td&gt; &lt;td&gt;&lt;%= item.uid %&gt;&lt;/td&gt; &lt;td&gt;&lt;%= item.pass %&gt;&lt;/td&gt; &lt;/tr&gt; &lt;% }); %&gt; &lt;/table&gt; &lt;/body&gt; &lt;/html&gt; Node mydbsvr.js 명령을 통하여 예제 페이지를 실행한다. 3.87.0.78:65001/insert 그러나 접속을 하더라도 페이지가 제대로 뜨지 않는 것을 확인할 수 있다. 이는 Ec2의 보안 설정에서 포트 65001을 허용하지 않았기 때문이다. 해당 인스턴스의 보안그룹을 들어가면 인바운드 규칙을 볼 수 있다. 인바운드 규칙 편집을 선택한다. 유형을 사용자 지정 TCP로 하며 포트 범위를 65001로 한다. 그 후 0.0.0.0/0을 선택한 후 저장을 누른다. 같은 URL로 접속하면 정상적으로 뜨는 것을 확인할 수 있다. 입력 후 /members로 들어가게 되면 정상적으로 출력되는 것으 확인할 수 있다. DB에 접속해보면 입력한 데이터가 정상적으로 저장되어 있는 것을 확인할 수 있다.","link":"/2020/11/30/EC2%EB%A5%BC-%ED%99%9C%EC%9A%A9%ED%95%9C-Node-js-%EC%84%9C%EB%B2%84-%EA%B5%AC%EC%B6%95/"},{"title":"Git Tag","text":"Tag 태그는 언제나 똑같은 것을 가리켜야 한다 현재 버전의 상태를 다운로드 하고 싶다 git tag 1.0.0 현재 master 브랜치에서 태그가 만들어진다 git tag master git tag (커밋번호) 브랜치와는 달리 태그는 항상 일정한 것을 가리킨다 git checkout 1.0.0(태그명) : 테그명을 입력하면 해당 커밋으로 넘어갈 수 있다. Annotated Tag 태그에 대해 좀 더 자세한 설명을 추가하고 싶을 때 git tag -a 1.1.0 -m “bug fix” master : 어노테이션 태그 git tag -v 1.1.0 : 상세한 태그 설명을 볼 수 있음 태그를 올리고 싶으면 git push –tags origin master : –tags가 없으면 태그는 원격 저장소로 가지 않음 올라갈 태그는 releases로 올라감 git tag -d 1.1.0 : 태그 삭제 Tag의 원리 git tag 1.1.2 refs/tags/1.1.2 : 텍스트 파일이고 내용은 objets id 가리키며, commit을 가리킨다. git tag -a 1.1.3 -m “bug fix” objects/3e/… 특정한 오비젝트 가리키며 커밋을 가리킴 태그 이름과 태그 내용 또한 저장됨 refs/tags/1.1.3 : 3e…인 objects밑의 태그를 가리킴","link":"/2021/02/21/Git-Tag/"},{"title":"Git Blog 시작","text":"블로그 임시 로고 입니다.","link":"/2020/09/18/Git-Blog-%EC%8B%9C%EC%9E%91/"},{"title":"Git 과거로 돌아가기","text":"Reset checkout 과거로 돌아가고 그 뒤에 있는 commit을 삭제하고 싶다. git reset –hard 490c7285a63e6531ea7d4b3eb3f95d0784c6066d HEAD인 refs/heads/master가 490c7285a63e6531ea7d4b3eb3f95d0784c6066d을 가리키게 된다. 그러나 정보는 최대한 지우지 않는다 reest 취소 방법 ORIG_HEAD 파일은 reset 전 head가 있다(현재 branch의 최신 commit, 즉 head가 가리키는 것을 저장) logs/refs/heads/master는 head 기록이 남는다 - 기록 역사(head 변경의 역사) git log –hard ORIG_HEAD : 기존의 head로 다시 돌아옴 git reflog : 각각의 commit들이 기록됨 checkout으로 돌아가는 법 checkout 뒤에다가 commit id를 직접 적을 수 있다 git checkout 490c7285a63e6531ea7d4b3eb3f95d0784c6066d 123You are in 'detached HEAD' state. You can look around, make experimentalchanges and commit them, and you can discard any commits you make in thisstate without impacting any branches by switching back to a branch. $ git branch (HEAD detached at 490c728) HEAD 파일을 보면 직접 commit id를 가리킴 다시 git checkout master를 통하여 돌아오면 됨","link":"/2021/02/21/Git-%EA%B3%BC%EA%B1%B0%EB%A1%9C-%EB%8F%8C%EC%95%84%EA%B0%80%EA%B8%B0/"},{"title":"Git Branch","text":"git branch git branch : 치면 *master라고 뜨는데 기본 브랜치를 의미한다. git branch exp(생성할 브랜치명) : branch를 생성한다 -&gt; 현재 브랜치 상태를 그대로 복사한다. 현재 사용되는 브랜치에 *가 뜬다 git checkout git checkout exp : 브랜치를 exp 브랜치로 이동 f1.txt라는 파일이 어떤 브랜치에 있냐에 따라 내용이 완전히 달라짐 (exp branch에서 f2.txt를 만들고 add, commit하고 master branch로 넘어가면 f2.txt파일이 보이지 않음, 그러나 f2.txt파일을 만들고 add, commit을 하지 않으면 master branch로 넘어가도 사라지지 않음) git log –branches –decorate –graph 자신이 체크아웃된 브랜치 말고 모든 브랜치를 보여줌 HEAD -&gt; exp 되면 현재의 브랜치 –graph 하면 흐름을 알 수 있음 git log –branches –decorate –graph –oneline 1줄로 현재의 상태를 보여줌 git log master..exp : 2개의 브랜치 사이의 차이를 보여줌 git log exp..master : exp에는 없고 master에는 있는 것들 git log -p exp..master : 소스코드의 차이까지 보여줌 git diff master..exp : master와 exp의 현재 상태를 비교 함 Branch 병합exp에서 작업했던 내용을 master로 병합을 하고 싶다 (그 반대와는 다름) exp =&gt; master로 병합을 원할 경우 master에 checkout을 한 후 master에서 merge 명령어를 작성 git merge exp : master에서 실행하면 exp를 master로 병합 merge된 commit은 2개의 부모를 갖는다 (exp와 master였던 것) git checkout exp -&gt; git merge master git branch -d exp : exp branch를 삭제한다 병합 순서 git checkout -b test = git branch test -&gt; git checkout test merge를 했을 때 Fast-forward가 뜰 경우 branch 후 아무 일도 하지 않고 merge를 할 경우 이동만 시키면 병합 작업이 끝남 fast-forword하면 별도의 commit을 생성하지 않음, 바꾸기만 함 merge made by the ‘recursive’ strategy가 뜰 경우 fast-forward를 할 수 없는 경우이다 두 commit의 공통의 조상을 찾고, 두 commit을 합치고 합친 것을 알려주고, 합친 새로운 commit을 자동으로 생성한다. fast-forard가 아닌 방식은 merge commit을 생성한다. Stash branch에서 작업하다가 다른 branch로 checkout해야 하는 경우, commit하기도 애매하고 commit하지 않으면 checkout을 할수 없을 경우에 사용 작업한 내용을 숨겨놓고 그 브랜치의 최신 commit(head)의 버전으로 이동해서 깔끔하게 하고 다른 브랜치로 checkout 할 수 있음 exp 브랜치에서 작업하였지만, add, commit을 하지 않으면 master로 checkout을 했을때 add되지 않았다고 뜸 -&gt; exp에서 한 작업이 master에게 까지 영향을 미침 git stash Saved working directory and index state WIP on exp: b416d47 Merge branch ‘exp’, 워킹 디렉터리의 내용이 저장되었고 인덱스 내용도 세이브되었음 exp에 exp, master에서 git status하면 작업했던 내용들이 숨겨져서 사라짐 git stash apply : 숨겨진 파일을 다시 불러옴 git stash list : list를 볼 수 있음 git reset –hard HEAD 가장 최신 커밋 상태로 우리의 워킹 카피를 보냄, stash의 내용은 사라지지 않음! -&gt; 명시적으로 삭제를 하지 않는한 살아있음 git stash apply를 통하여 다시 숨겨놓은 것을 받아올 수 있음 (가장 최근의 stash를 적용함) git stash drop : 가장 최근의 stash를 삭제 stash를 전부 적용하기 위해 apply -&gt; drop -&gt; apply -&gt; drop을 반복한다 git stash pop : apply drop까지 됨 stash는 워킹 디렉터리의 변경사항을 감추는 것이다 add 하지 않은 것은 stash를 하더라도 숨겨지지 않는다 (untracked) -&gt; stash는 최소한 버전관리중인 파일에 대해서만 적용이 된다. Branch 상세 .git의 HEAD 파일 -&gt; refs/heads/master : objects의 id, 즉 commit의 object id를 가리키고 있음 새로운 commit 시 방금 commit으로 바뀜(가장 최신의 commits), 그리고 해당 commit의 parent를 통해서 탐색해 갈 수 있음 새로운 branch 생성 refs/heads/exp가 생성되며 최신 commits을 가리킨다 rm .git/refs/heads/exp를 하면 삭제 가능 git에서 브랜치는 매우 중요하지만 단순한 파일일 뿐이다 HEAD는 head를 가리킴 git checkout 시 HEAD 내용이 바뀜 Branch 병합 과정의 충돌 merge 과정에서 파일의 내용이 다를 경우 같은 파일임에도 서로 수정하는 위치가 다르다면 자동으로 합쳐준다 ex} master -&gt; function a(기존), function b(추가) exp -&gt; function c(추가), function a(기존) merge -&gt; function c, finction a, function b but, 수정하는 위치가 같다면 ex) function a(master){}, function a(exp){} 123CONFLICT (add/add): Merge conflict in common.txtAuto-merging common.txtAutomatic merge failed; fix conflicts and then commit the result. git status 시123Unmerged paths: (use &quot;git add &lt;file&gt;...&quot; to mark resolution) both added: common.txt vi common.txt 시123- ======= 구분자 중심으로- &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD : 현재 checkout branch- &gt;&gt;&gt;&gt;&gt;&gt;&gt; exp : exp branch의 내용 자기가 자동 merge 실패하였기 때문에 충돌을 해결하라 충돌이 난 부분 표시이다 -&gt; 문제를 수정하자 그 후 git add common.txt git commit (보면 충돌난 것 해결했다고 메시지가 뜸) git add 없이 merge를 또 시도할 경우 뜨는 에러1234error: Merging is not possible because you have unmerged files.hint: Fix them up in the work tree, and then use 'git add/rm &lt;file&gt;'hint: as appropriate to mark resolution and make a commit.fatal: Exiting because of an unresolved conflict.","link":"/2021/02/21/Git-Branch/"},{"title":"Git rebase vs merge","text":"rebase vs merge 병합을 하지만 결과가 좀 다르다 merge master내용을 feature로 가져오고 싶다 git checkout feature git merge master -&gt; 공통 조상과 3way merge 실시, master는 하나 전을 가리키고 있음 rebase 공통 조장 : base git checkout feature git rebase master -&gt; 임시 저장소 어딘가에 feature의 커밋들이 저장되고, feature는 master의 최신 커밋으로 checkout된다. -&gt; 임시 저장소의 commit들과 f,m인 브랜치와 병합 -&gt; 임시에 2개 커밋 있었으면 1개하고 임시에서 1개 지우고 1개 하고 임시에서 1개 지워서 새 브랜치 만듬 merge의 경우 history가 병렬 rebase는 history가 1개로 나아감 역사 파악이 더 편함 rebase는 어렵고 위험하다 merge는 충돌 발생해도 해결이 쉬움","link":"/2021/02/21/Git-rebase-vs-merge/"},{"title":"Git merge","text":"merge &amp; conflict 충돌이 발생했을 때의 처리 방법 123CONFLICT (add/add): Merge conflict in common.txtAuto-merging common.txtAutomatic merge failed; fix conflicts and then commit the result. index 파일에는 보통 490c7285a63e6531ea7d4b3eb3f95d0784c6066d 0 f1.txt이지만 0이 늘어난다. 1 -&gt; 원본 2 -&gt; 현재 브랜치의 바뀐내용 3 -&gt; 병합하고 싶은 브랜치의 바뀐내용 자동으로 깃은 병합작업을 실시 MERGE_HEAD_ MERGE_MSG : 충돌 해결 했을 때 커밋시 메시지 3way merge vs 2 way merge12345ME Base Other 2way 3way A A x ? x B B B B B 1 C 2 ? ? x D D ? x 2way는 base를 보지 않고 2개의 차이점만을 본다 3way는 base를 참조해서 2개의 대상을 병합한다(훨씬 good)","link":"/2021/02/21/Git-merge/"},{"title":"Git 시작하기","text":"Git에 대한 기초 학습 내용Git version control system Backup, Recovery, Collaboration version control system : CVS, SVN, Git등 다양하다. Dropbox, Google Drive도 버전관리 시스템의 일종이다. 1git git 입력 시 사용할 수 있는 명령어 목록이 뜬다. git init Initialized empty Git repository in ~ git 저장소를 초기화 한다. .git Directory가 생성되며 version에 관련된 정보가 저장되므로 삭제하면 안됨 vim vim f1.txt 입력시 f1.txt 파일이 생성된다. 입력모드와 명령모드로 구분되어 있다.(i, a, o를 통하여 입력모드로, esc를 통하여 명령모드로 전환) :wq를 통하여 저장 후 나가기 git add Untracked files : 디렉터리 안에는 존재하지만, 버전관리를 하기 전까지는 git이 무시한다. git이 관리를 시작하기 위한 명령어가 add이다. git add f1.txt 후 Changes to be committed로 변경됨 프로젝트를 하다보면 프로젝트 핵심 파일과 임시 파일이 있는데 임시 파일은 버전 관리를 하면 안됨, 따라서 이를 배제하기 위해 관리해야 할 파일을 명확히 알려줌 초기 환경 설정 git config –global user.name KiHyeon-Hong git config –global user.email ghdrlgus96@gmail.com git commit version : 모든 변화는 버전이 아니라 의미 있는 변화이다. 새로운 버전으로 만들기, 일정한 작업이 완결된 상태 git commit 후 commit message를 적어야 하는데 vim이므로 vim 입력방식대로 입력을 해야 한다. 123[master (root-commit) 4347df6] first commit 1 file changed, 1 insertion(+) create mode 100644 f1.txt 수정한 후 add 명령어를 항상 적어야지 버전 관리를 시작한다. 새로운 파일을 버전 관리 뿐만이 아니라 버전 관리가 되고 있는 파일을 수정하더라도 add를 해야 함 Changes not staged for commit : 수정 시 뜨는 메시지 (git status) git log 버전 생성된 것 확인(commit history 확인) git은 왜 add를 해야 하는가? commit 하나는 하나의 작업을 담는게 이상적이다. add를 통해서 commit 하고자 하는 것만 commit 할 수 있다. git add f1.txt를 하면 f1.txt는 stage에 올라감, commit 대기중인 파일들 stage - repository commit 결과는 repository commit에는 각각의 고유한 id가 있음 (commit 4347df685c78fe904d0363550936367d17851481) git log의 옵션들1git log -p 각 commit 사이의 소스 코드 차이를 보여준다. 1git log 4347df685c78fe904d0363550936367d17851481 이 commit 이전의 commit만 보인다. 1git diff 4347df685c78fe904d0363550936367d17851481..8d49b7cfa3e2c42d2be75e33169b640bbb48d8e9 두 commit 사이의 소스 차이를 보여준다. 파일 수정 후 git diff 시 : 현재 어떠한 작업이 진행되었는지 알 수 있음 -&gt; 자기가 작업한 내용이 마지막으로 리뷰할 수 있는 기회 (git add 시 git diff로 보이지 않음, 이전 commit과의 차이를 보여줌) 과거로 돌아가기 commit을 취소하는 명령어 현재의 log를 취소해서 과거로 돌아가기 reset vs revert reset 시 1git reset 8d49b7cfa3e2c42d2be75e33169b640bbb48d8e9 --hard 8d49b7cfa3e2c42d2be75e33169b640bbb48d8e9가 head로 바뀌며 이 이후의 commit이 사라짐 (–hard, –soft등 다양한 요소가 있음) git reset을 하더라도 실제로 삭제되지는 않고 복구가 가능 협업을 하게되면 원격저장소에 올라가는데 공유한 후에는 reset을 절대로 하면 안됨, 로컬에서만 reset을 써야함 git revert : 버전을 새로 만들면서 이전 commit으로 돌아간다 git commit –help git commit -a : 수정 및 삭제 파일은 자동으로 add 후 commit git commit -m “commit message” git commit -am “2” : 한번도 버전 관리, 즉 add를 하지 않은 파일을 제외하고 전부 add 후 메시지도 입력받지 않음","link":"/2021/02/18/Git-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/"},{"title":"Git 원격 저장소","text":"GIT 원격 저장소 - Remote repository 원격 저장소에 올리기(backup. 협업) -&gt; 1대의 컴퓨터 안에서 원격 저장소 만드는 법, 이런 방법은 거의 활용하지도 않음 git init –bare remote –bare(작업을 할 수 없고 저장소로만 사용하겠다는 옵션으로 remote라는 디렉터리 생성), working 디렉터리가 없고 .git 내용만 있음, 수정같은 작업이 불가능 함, 원격 저장소 만들때는 bare 넣는다 git remote add origin /home/git/git/remote : origin이라는 별명으로 리모트 원격 저장소 연결함 git remote remove origin : origin 저장소를 지운다. git config –global push.default matching : git이 암시적으로 git config –global push.default simple : 새 버전부터 simple 방식으로 push 하는 것이 좋음 -&gt; 이에 대한 설정, 어디로 업로드 하겠다. git push origin master : origin 저장소에 master 브랜치를 저장한다 git push –set-upstream origin master : 앞으로 push는 origin에 master를 하겠다 Github 원격저장소는 구축하기 어렵기 때문에 제공해주는 서비스를 이용 그 중 대표적인 예가 Github -&gt; 오픈소스 프로젝트들의 작업장 이미 존재하는 오픈소스 가져오기 git/git : git에 대한 오픈소스 코드 commits : 지금까지 commit 횟수 branches : branch의 개수 contributes : 이 소스코드에 접근할 수 있는 사람들 watch : 지켜보는 사람들 star : 좋아요 수 fork : 해당 소스 코드를 내것으로 해서 수정이 가능(ghdrlgus96/git 이 된다) -&gt; fork의 수가 그 소스코드의 수준을 보여준다. git clone https://github.com/git/git.git gitsrc : gitsrc 이름으로 clone git log –reverse : log를 거꾸로 봄 -&gt; 첫번째 로그를 볼 수 있음 git checkout (해당 commit) : 해당 commit일때 상태로 이동 원격 저장소 만들기 new repository git init git add . git commit -m “1” git remote add origin https://github.com/ghdrlgus96/git.git : 원격 저장소(remote repository)를 연결 시키고 origin 이라는 별명을 부여하겠다. git remote : 원격저장소 확인 git remote -v : 상세 보기 작업한 내용을 여러 저장소를 remote로 해서 보낼 수 있다. git remote remove friend : friend remote 삭제 git push origin master : 현재 checkout 되어있는 브랜치를 origin의 master 브랜치를 서로 연결시킨다. git clone https://github.com/ghdrlgus96/git.git . git commit –amend : 최근 커밋의 메시지 변경 push 이후의 내용은 수정하지 말자 git push origin master //다른 로컬 저장소 git pull origin master : 가져오기(공재 저장소에서 가져오므로 비밀번호를 묻지 않음) git add . git commit -m “2” git push //다른 로컬 저장소 git pull … 지역 저장소에서 원격 저장소를 만들어 올리기 git init local cd local git commit -am “1” 원격 저장소 git init –bare remote cd remote 로컬 저장소 git remote add origin ssh://git@13.124.42.13/home/7. git/git/remote/ : ssh로 접속하는데 사용자 이름은 8. git git remote -v git push –set-upstream origin master 원격 저장소 git log 백업 및 동기화의 의미를 갖는다. git clone ssh://git@13.124.42.13/home/git/git/remote/ office push pull push 전에 로컬과 원격 저장소의 내용이 다르면 pull을 하고 push를 하라 분산관리 시스템 특징 : 로컬에서 버전관리 하다가 필요시 원격과 동기화 자주 pull, push를 하여 다른 사람의 push 기록을 자주 가져오도록 하자 pull - 작업 - push pull, push는 자주해야 충돌 가능성을 낮춘다. 원격 저장소 원리 git remote add origin git@github.com:ghdrlgus96/repo.git .git/config123[remote &quot;origin&quot;] url=git@github.com:ghdrlgus96/repo.git fetch =+refs/heads/*:refs/remotes/origin/* git push 1current branch master has no upstream breanch - 연결되어 있는 원격저장소 브랜치가 없다 git push –set-upstream origin master : origin의 master 브랜치에 연결 .git/config 123456[remote &quot;origin&quot;] url=git@github.com:ghdrlgus96/repo.git fetch =+refs/heads/*:refs/remotes/origin/*[branch &quot;master&quot;] remote=origin merge=refs/heads/master refs/remotes/origin/master 파일 origin으로 push한 commit이 무엇인가가 적혀있음 (원격 저장소의 master)refs/heads/master 지역 저장소의 master내용 둘이 같음 -&gt; 인터넷에서 가져온것이 아니라, 지역에서 마지막으로 원격으로 push 했던 기록일 뿐이다. git log –decorate –graph git pull, git fetchgit log –decorate –all –onelinepull 지역 저장소 master 브랜치와 원격저장소(origin)의 master의 브랜치가 같아짐 ORIG_HEAD는 이전 commit을 가리키고 있음 git fetch 지역저장소의 master 브랜치는 6, 원격저장소 origin의 master 브랜치는 7을 가리키고 있음 -&gt; merge되지 않음 ORIG_HEAD가 변하지 않음 원격 저장소로부터 받고 병합을 안하지 때문에 원격과 지역의 차이를 비교해 볼 수 있음 git diff HEAD origin/master : 최신 커밋과 원격의 최신을 비교 가능 git merge origin/master : git fetch 후 병합을 해야 함 git fetch -&gt; git merge origin/master","link":"/2021/02/21/Git-%EC%9B%90%EA%B2%A9-%EC%A0%80%EC%9E%A5%EC%86%8C/"},{"title":"Git 원리","text":".git directory git add 시 : index, objects directory가 변경됨 objects directory 내부에는 git add한 기록이 있으며, 이에 대한 자세한 내용은 index에 존재함index : 100644 8d49b7cfa3e2c42d2be75e33169b640bbb48d8e9 0 f1.txt cp 명령어로 파일을 복사할 경우 cp 명령어를 쓰면 같은 8d49b7cfa3e2c42d2be75e33169b640bbb48d8e9를 갖는다 -&gt; 같은 object를 갖는다 파일의 이름이 달라도 내용이 같으면 같은 object를 갖는다 내용이 a라면 같은 8d49b7cfa3e2c42d2be75e33169b640bbb48d8e9를 가질 것이다 (이 세상 누가 작성하더라도) objects 파일명과 원리SHA1 online -&gt; hash, 일정한 길이, git은 SHA1을 통과시켜서 hash값에서 2글자 빼고 objects 디렉터리를 만들고 그 나머지를 파일을 만들어서 정보를 저장한다. git add를 하면 git은 add한 파일의 내용과 부가적인 정보로 hash를 통과시키고 디렉터리와 파일을 만들고 그 정보를 저장한다음 index파일에서 이를 표시해준다. commit의 원리 git commit -m “1” 시 objects 디렉터리 안에 commit 정보가 저장, commit도 내부적으로는 객체 tree 8d49b7cfa3e2c42d2be75e33169b640bbb48d8e9 -&gt; 트리는 해당 버전의 파일의 이름과 그 내용 해쉬가 있음 parent에는 이전 commit을 볼 수 있음 각각의 버전은 그 버전이 만들었을 때의 스냅샷을 찍는다 objects 파일의 3가지 : 파일의 내용blob, 디렉터리 파일명과 파일명의 blob에 대한 정보tree, commit git status의 원리 index 파일은 무엇일까index와 최신 objects에 있는 commit을 비교 -&gt; 일치한다면 commit할 내용이 없음 index의 hash와 실제 디렉터리 hash가 다르면 수정되었음을 알림 add 하면 objects에 새로운 것이 생성되었고 index에 반영됨, 실제 파일과 hash는 같음, 그러나 가장 최신 커밋이 가리키는 f2.txt의 hash와는 다르므로 현재 f2.txt는 add되고 commit 대기 상태임을 알 수 있음 프로젝트 폴더(working directory, work tree), index, objects, 최신 commit이 전부 일치하면 commit할 것이 없다고 알려줌 working directory, work tree - index, staging area, cache - repository","link":"/2021/02/19/Git-%EC%9B%90%EB%A6%AC/"},{"title":"Git 저장소 원리","text":"working copy &amp; index &amp; repository working directory(working tree, working copy), index(git add 시, staging area, chche), repository(commit이 저장, history, tree) git reset –hard하면 저장소, add, working까지 삭제됨 git reset –soft하면 repository만 삭제됨 git reset –mixed하면 레포지토리랑 add 삭제됨 git reset –soft 490c7285a63e6531ea7d4b3eb3f95d0784c6066d git diff : working copy와 index 비교 git reset –hard : 최신 커밋 상태로 바꿔버림 working copy까지","link":"/2021/02/21/Git-%EC%A0%80%EC%9E%A5%EC%86%8C-%EC%9B%90%EB%A6%AC/"},{"title":"S3 시작하기","text":"S3은 어디서나 원하는 양의 데이터를 저장하고 검색할 수 있도록 구축된 객체 스토리지이다. S3은 스토리지 형식으로 객체 스토리지를 사용한다. 계층 구조가 없고, 고유식별 번호와 데이터 그리고 메타 데이터 등 최소한의 정보만을 가지고 있기 때문에 파일 개수가 많아져도 파일 스토리지에 비해 훨씬 많은 수의 파일들을 처리할 수 있다. 높은 내구성 손쉬운 혹장성 보안성과 편리성 관리 유연성 &lt;부트 스토립을 이용한 반응형 페이지 생성 실습&gt; 부트스트랩 홈페이지 접속 부트스트랩 템플릿 다운로드 S3버킷 생성 부트스트랩 템플릿 파일 업로드 정적 웹 사이트 설정 엔드포인트 URL을 통한 부트스트랩 index.html 확인 AWS 콘솔에서 스토리지 서비스인 S3을 검색한다. 다음과 같은 화면이 나오면 버킷 만들기를 클릭한다. 버킷 이름과 리전을 선택한다. 이 때, 버킷 이름은 저세계에서 유일해야 하며, 리전은 Educate 버전 사용 시 버지니아 북부로 해야 한다. 옵션은 기본으로 설정하고 넘어간다. 모든 퍼블릭 엑세스 차단을 해제한다. 차단을 해제 하여야 외부 사람이 접근 가능하다. 검토 후 문제가 없다면 버킷 만들기를 선택한다. 버킷이 새로 만들어 졌다. 새로 새성한 버킷을 선택하면 다음과 같은 화면이 출력된다. https://startbootstrap.com/ 부트스트랩을 이용한 반응형 웹 페이지를 만드려고 한다. 부트스트랩 사이트에서 마음에 드는 템플릿을 다운 받는다 다운받은 템플릿의 압축을 풀면 다음과 같은 파일들이 생겨난다. 해당 파일 전부를 업로드를 한다. 퍼블릭 권한 관리에서 “이 객체를 퍼블릭 읽기 엑세스 권한을 부여함”을 선택한다. 스토리지 클래스는 기본인 스탠다드를 선택한다. 완료 후 속성의 정적 웹 사이트 호스팅을 선택한다. 이 버킷을 사용하여 웹 사이트를 호스팅합니다를 선탣한다. 인덱스 문서는 엔드 포인트로 index.html을 입력한다. 엔드포인트는 다음과 같다. 해당 엔드 포인트를 웹 브라우저에 입력하면 해당하는 웹 페이지가 정상적으로 뜨는 것을 볼 수 있다.","link":"/2020/10/06/S3-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/"},{"title":"Lambda 시작하기","text":"AWS Lambda 함수 기반 문자 알림 서비스를 구축해본다. 구축 과정 SNS 서비스 실행 권한을 위한 IAM 정책 설정 A. 정책 생성 및 검토(정책 이름 policy_for_publising_SNS) B. 역할 생성(역할 이름 role_for_sns_sending) SNS 람다 함수 만들기 A. 람다 함수 생성(람다 함수 이름 : lambda_for_sns) B. 람다 함수 실행 역할 생성(람다 역할 이름 : role_for_sns_sending) SNS 람다 이벤트 구성 A. 람다 함수 이벤트 이름(eventForSendingsSNS) B. 람다 함수 소스코드 작성 SNS 람다 함수 테스트 AIM 대시 보드에서 죄측 정책 메뉴를 클릭한 후 정책 생성을 선탣한다. 서비스 선택에서 SNS 입력 후 필터링 된 SNS를 선택한다. 문자 보내기는 사용자에게 알림 서비스를 생성하는 것이므로 액세스 레벨 “쓰기”에 해당한다. 리소스는 모든 리소스를 선택한다. 요청 조건은 기본 설정으로 하고 정책 검토를 클릭한다. 정책 이름은 policy_for_publising_SNS로 한 후 정책 생성을 클릭한다. 정책과 연결해 줄 역할을 만든다. 역할 만들기를 선택한다. 신뢰할 수 있는 유형의 개체로 AWS 서비스를 선택한다. 사용 사례 선택은 Lambda를 선택한다. 권한 정책 연결에서 policy_for_publising_SNS를 선택한다. 태그는 없으므로 넘어간다. 역할 이름에 role_for_sns_sending를 입력하고 역할 만들기를 선택한다. AWS console에서 Lambda를 클릭한다. 람다 함수 대시보드에서 함수 생성을 선택한다. 함수 이름은 lambda_for_sns로 입력한다. 권한은 기존 역할 사용을 선택하며, role_for_sns_sending을 선택한다. 함수 행성을 선택한다. 성공적으로 함수가 만들어진 후 이벤트 선택에서 테스트 이벤트 구성을 선택한다. 이벤트 이름은 eventForSendingsSns로 입력한 후, 코드는 다음과 같이 입력한다. 1234{ &quot;text&quot;: &quot;hello world&quot;, &quot;number&quot;: &quot;+821012345678&quot;} 함수 코드에는 다음과 같이 입력한다. //AWS를 실행시키기위한 라이브러리를 가져옵니다. const AWS = require('aws-sdk'); //이전과 다른부분이 있다면 context와 callback을 파라미터로 받습니다. //context에서는 현재 실행중인 람다의 메타정보를 받고 //callback은 람다가 끝나는 시점 호출합니다. exports.handler = (event, context, callback) =&gt; { //위에 입력했던 json값이 event 즉 input으로 들어옵니다. //params에 Message와 PhonNumber 변수를 선언합니다. const params = { Message: event.text, PhoneNumber: event.number }; // SNS SDK를 가져옵니다. // SNS서비스에서 메세지를 보내는것은 한정된 리전에서만 사용할 수 있기때문에 // region을 도쿄리전으로 설정해주어야합니다. 이를 위해 인자값으로 // region에 도쿄리전의 식별자인 'ap-northeast-1'을 입력합니다. const publishTextPromise = new AWS.SNS({ apiVersion: '2010-03-31',region: 'ap-northeast-1'}).publish(params).promise(); // SDK를 실행합니다. publishTextPromise.then( function(data) { //메세지가 있다면 첫번째에 null, 두번째에 메세지를 리턴합니다. callback(null,&quot;MessageID is &quot; + data.MessageId); }).catch( function(err) { //에러가 있다면 err를 리턴합니다. callback(err); }); }; 오른쪽 상단의 테스트 버튼을 클릭하면 함수가 실행된다. 입력한 텍스트가 문자로 온 것을 확인할 수 있다","link":"/2020/10/27/Lambda-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/"},{"title":"Lightsail 시작하기","text":"lightsail은 플랫폼과 시작 이미지를 선택하는 것만으로 인스턴스를 바로 시작할 수 있다. 웹 사이트 블로그 단순 앱 개발 및 테스트 환경 소수의 서버로 구성된 비즈니스 소프트웨어 wordpress blig를 구축한다. 구축 과정 AWS Lightsail 접속 Lightsail 인스턴스 생성 Lightsail 인스턴스 확인 wordpress 사용자 설정 wordpress 관리자 설정 A. 사용자명, 패스워드 설정을 위한 원격 서버 접속 B. Bitnami(SSH) 접속을 통한 아이디 패스워드 생성/확인 C. wordpress 관리자 페이지 접속/확인 AWS console에서 lightsail 접속 인스턴스 생성을 누른다. 첫번째는 인스턴스 이미지를 선택하는 과정이다. 플랫폼과 블루푸린트 메뉴가 존재한다. 플랫폼은 Linux/Unix를 선택하며, 블루프린트는 Wordpress를 선택한다. 시작 스크립트는 맨 처음 서버가 구성될 때 실행되는 스크립트이며, 사용자에 따라 필수적으로 설치해야 하는 소프트웨어가 있을 경우 선택한다. SSH 키 페어는 원격 서버 접속을 위해 사용한다. 인스턴스 플랜은 프리티어 가입 후 첫 달 무료 서비스를 이용하기 위해 가장 저렴한 플랜을 선택한다. 인스턴스 확인에서 고유한 이름을 선택해야하며, 인스턴스 수를 늘릴경우 추가 요금이 발생할 수 있다. 처음 인스턴스를 생성하면 실행 중 메시지가 뜨며, IP 주소가 할당된다. 해당 IP 주소를 웹 브라우저에 입력하면 기본으로 생성되는 포스트와 블로그 레이아웃을 볼 수 있다. 관리자 페이지는 퍼블릭IP/wp-damin 이다. 관리자 대시보드를 이용하기 위해서는 유저명과 비밀번호를 입력해야 한다. lightsail 대시보드에 돌아가 이름 옆의 콘솔 창을 클릭한다. CLI console창이 뜬다. 1$ cat bitnami_credentials 명령어를 입력하면 default userName과 password를 출력한다. bitnami 관리자 정보는 잘 보관되어야 한다. 관리자 정보를 통하여 관리자 대시보드로 접속 가능하다. Setting의 General에서 Site Language를 한국어로 바꾸고 저장한다. wordpress와 polly wordpress 플러그인 설정 lightsail 기반 wordpress 사용을 위한 IAM 설정 A. 정책 설정 B. 정책 샐성 및 검토 C. 사용자 설정 D. 사용자 생성 E. 기존 정책과 사용자 연결 F. 사용자 키 보관 wordpress 플러그인 설정 및 사용 플러그인을 보면 AWS for WordPress가 보인다. 활성화를 클릭한다. 활성화를 하면 AWS라는 매뉴가 나타난다. 클릭하면 AWS access key와 AWS secret key를 입력하라는 메시지가 출력된다. 이를 이용하기 위해서는 IAM이 필요하다. IAM의 대시보드를 들어가면 액세스 관리에 사용자와 정책이 있다. 정책 생성을 클릭한 후 시각적 편집기가 아닌 JSON을 클릭한다. 123456789101112131415161718192021222324252627282930313233{ &quot;Version&quot;: &quot;2012-10-17&quot;, &quot;Statement&quot;: [ { &quot;Sid&quot;: &quot;Permissions1&quot;, &quot;Effect&quot;: &quot;Allow&quot;, &quot;Action&quot;: [ &quot;s3:HeadBucket&quot;, &quot;polly:SynthesizeSpeech&quot;, &quot;polly:DescribeVoices&quot;, &quot;translate:TranslateText&quot; ], &quot;Resource&quot;: &quot;*&quot; }, { &quot;Sid&quot;: &quot;Permissions2&quot;, &quot;Effect&quot;: &quot;Allow&quot;, &quot;Action&quot;: [ &quot;s3:ListBucket&quot;, &quot;s3:GetBucketAcl&quot;, &quot;s3:GetBucketPolicy&quot;, &quot;s3:PutObject&quot;, &quot;s3:DeleteObject&quot;, &quot;s3:CreateBucket&quot;, &quot;s3:PutObjectAcl&quot; ], &quot;Resource&quot;: [ &quot;arn:aws:s3:::audio_for_wordpress*&quot;, &quot;arn:aws:s3:::audio-for-wordpress*&quot; ] } ]} 해당 json 파일을 복사 &amp; 붙여넣기 한다. 정책 검토를 하면 다음과 같은 화면이 나온다. 정책 명을 policy_for_wordpress_polly으로 입력한 후 정책 생성을 클릭한다. 정책이 생성되었으면, 사용자에서 사용자 추가를 클릭한다. 사용자 이름은 userForWordpress로 하며, 액세스 유형은 일반 사용자가 아닌 워드프레스라는 애플리케이션을 통해 AWS에 서비스 접근하기 때문에 ‘프로그래밍 방식 액세스’를 선택한다. 기존 정책 직접 연결을 통하여 방금 생성한 정책을 선택한다. 태그 화면은 별도의 설정을 하지 않고 넘어간다. 이상이 없다면 사용자 만들기를 클릭한다. 프로그래밍 액세스 방식은 액세스 키와 비밀 액세스 키가 발급된다. 키는 .csv 파일로 보관할 수 있다. 앞서 생성한 키를 입력한다. 변경 사항 저장을 클릭한다. Text to Speech에서 source language를 한국어로 선택하며, Enable text-to-speech support를 체크한다. 글을 클릭한 후 새로 추가를 선택한다. 제목과 내용을 입력한 후 밑에 있는 enable Text-to-speech에 체크 박스를 선택한다. 우측 상단의 공개 버튼을 클릭한다. 다음과 같이 포스트된 글을 확인할 수 있으며, 재생 버튼을 통하여 polly 서비스를 확인할 수 있다. 다운로드도 가능하다. 첫 한달 간은 무료로 사용이 가능하지만, 그 이후로는 매달 $3.5의 금액이 나가므로, 실습 후 인스턴스를 삭제한다.","link":"/2020/09/29/Lightsail-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/"},{"title":"docker 시작하기","text":"docker 설치 도커 설치 : https://www.docker.com/get-started docker desktop을 설치 powershell에서 도커 버전 확인 : docker –version docker 설치 시 주의사항 windows에서 설치할 경우 WSL 2와 관련된 설정이 나올 텐데 이를 허용해야 한다. 실습 환경 설정 git clone https://gitlab.com/yalco/practice-docker.git DokerStudy Node.js : 브라우저가 아닌 컴퓨터 환경에서 자바스크립트를 돌리게 해줌 실습 코드 수행 npm install –global http-server : global로 설치를 해야 http-server 명령어 이용 가능합니다. cd frontend로 들어간 후 http-server -p 8080 ./public 명령으로 서버 실행 그러나 이러한 Node.js와 http-server 없이 실행하기 위해 도커를 사용한다. docker 실행 docker run -it node : 만약 permission 관련 오류 발생 시 sudo를 붙이면 됨 Node.js 깔린 것처럼 입력 콘솔이 출력된다 이 Node.js 환경은 이미지 형태인데, docker의 이미지란 것은 캡쳐해서 박제한 것이다 docker 설명 run은 다운 후 이미지를 해동해서 컨테이너로 만든다 -it는 컨테이너를 연 다음 cli를 사용하겠다는 의미이다 그 후 node 명령어가 실행되므로 입력 화면이 나오는 것이다 docker 조작하기 docker images : 설치 된 것 확인, 설치 되었으니 docker run -it node 명령어 사용하면 설치없이 바로 실행 docker ps : 컨테이너 확인 가능 docker exec -it (docker ps 명령어로 확인한 컨테이너 명) bash root@f44956de125d:/# 가 뜨면서 컨테이너 내부를 통해 가상의 리눅스 환경으로 들어간 것이다 ls를 입력하면 리눅스 기본 디렉터리들이 보인다 -&gt; 컨테이너마다 각각 이 파일 시스템과 네트워크가 존재, 도커 데스크탑 프로그램으로 구현된 것!!! 도커의 컨테이너들은 리눅스 가상 환경의 형태로 돌아감! docker 종료하기 node cli에서 ctrl+c를 하면 컨테이너 안의 Node와 회의를 끝마친 것이다 이 후 docker ps를 입력하더라도 컨테이너가 나타나지 않는다 docker ps -a : 모든 컨테이너를 보여줌, 현재 중지된 컨테이너도 보임 이 디렉터리에서만 확인할 수 있는 것이 아니라 docker에 의해 다른 곳에서 관리 되므로 어떠한 디렉터리에서도 확인이 가능 docker container 삭제 한번에 도커 컨테이너 삭제 docker stop $(docker ps -aq) docker system pune -a Dockerfile 이미지를 만들기 위한 설계서 Dockerfile 내용 FROM node:12.18.4 : node version RUN npm install -g http-server : 이미지를 생성할 과정에서 실행할 명령어 WORKDIR /home/node/app : 이 안에서 명령어를 수행할 위치 CMD [“http-server”, “-p”, “8080”, “./public”] : 이미지로부터 컨테이너가 만들어져 가동될 때 기본적으로 바로 실행되는 명령어 Dockerfile 실행 cli에서 이 폴더로 들어온 다음 -t 뒤에 원하는 이미지명을 적은 뒤 Docker file로의 상대 경로를 적는다 파일이 Dockerfile이면 따로 명시할 필요가 없음 docker build -t frontend-img . docker images 명령어를 통하여 node 이미지가 다운 받아지고 이를 기반으로 frontend-img 이미지가 만들어진다 image run 시키기 docker run –name frontend-con -v $(pwd):/home/node/app -p 8080:8080 frontend-img docker run –name frontend-con -v “%cd%”:/home/node/app -p 8080:8080 frontend-img 아까는 도커가 임의의 컨테이너명을 지어줬지만 이번에는 frontend-con이라는 이름을 지어준다 -v는 볼륨의 약자인데 컨테이너의 특정 폴더를 공유 코드를 짠 후 그 파일을 거실 탁자에 두면 그 거실 탁자는 Node.js가 일하는 컨테이너의 /home/node/app 서랍과 연결된 것 pwd는 현재 디렉터리 컨테이너가 언제 몇개가 만들어지든 각 컨테이너의 app 서랍에서는 거실에 둔 파일들로 얼마든지 서비스를 실행 이를 통하여 CMD [“http-server”, “-p”, “8080”, “./public”]로 파일 실행이 가능한 것이다 Port 설명 -p는 포트 컨테이너는 CMD [“http-server”, “-p”, “8080”, “./public”]를 통하여 8080 포트로 송출할 거니까집에서도 같은 곳으로 송출한다는 의미이다 Dockerfile database file FROM mysql:5.7 : mySql 사용하겠다 환경변수 : 어떤 사용자? 비번? 디비명? 등등 설정 ENV MYSQL_USER mysql_user ENV MYSQL_PASSWORD mysql_password ENV MYSQL_ROOT_PASSWORD mysql_root_password ENV MYSQL_DATABASE visitlog COPY ./scripts/ /docker-entrypoint-initdb.d/ : script 안의 파일들을 이미지 내부의 /docker-entrypoint-initdb.d/로 저장 mysql이 실행이 될 때 /docker-entrypoint-initdb.d/안의 명령어들을 실행 script 파일들은 컨테이너 초기화 과정에서 필요한 것들이니까 copy로 이미지 안에 미리 넣어두는 것이 좋을 것이다 copy와 run의 차이점 copy는 run처럼 이미지를 생성하는 과정에서 해당 이미지 안에 특정 파일을 미리 넣어두는 것이고 volume은 CMD 처럼 컨테이너가 생성되어 실행될 때 그 내부의 폴더를 외부의 것과 연결하는 것이다!!! Dokcerfile 실행 docker build -t database-img . docker run –name database-con -p 3306:3306 database-img 컨테이너명과 포트만 지정하면 됨 -&gt; 실전에서는 데이터를 유지해야 하니까 데이터 폴더를 -v 옵션으로 집의 데이터 창고와 볼륨 창고를 연동할 것이다 docker run –name database-con -p 3306:3306 -d database-img : daemon의 줄임말, 뒤의 안보이는 곳에 가서 알아서 컨테이너 설치 및 실행… 현재 어떻게 실행되는지 보고 싶다면 : docker logs -f database-con Dockerfile backend file FROM python:3.8.5 RUN pip3 install flask flask-cors flask-mysql : flask로 api를 돌림 WORKDIR /usr/src/app CMD [“python3”, “backend.py”] : 백엔드 서버를 실행 docker-compose 이처럼 서비스를 구성하는 3개의 요소가 각각의 폴더에 Dockerfile를 통해 도커에서 어떻게 실행될지 설정이 되어 있는 것이다 각각의 네트워크로 분리되어 있기 때문에 백엔드와 데이터베이스는 데이터를 주고 받지 못한다 요소 연결 및 서비스 간편하게 실행? 이를 위해 사용되는 것이 거시적인 설계도인 docker-compose version: ‘3’ : 버전이며 지금의 최신 버전이 3이다 각각의 docker의 내용들이 services란 항목의 내부 항목들로 들어간다 docker-compose 내용 설명 항목명은 각 서비스들의 이름 (database:) 이며 이들간의 네트워크에서 각각의 호스트명이 된다 build: 는 도커 파일의 위치이다 compose 파일로부터.. ports: 는 외부에 개방할 포트이다 run 실행마다 작성해야되었던 명령어를 문서로 미리 작성한 것이다 backend에서는 volume을 사용하기 때문에 volumes:를 작성한다 환경 변수도 compose에서 environment:로 미리 설정할 수 있다 docker-compose 실행 docker-compose/yml이 있는 위치에서 docker-compose up을 실행 docker-compose up -d를 하면 뒤에서 알아서 컨테이너 생성 및 실행 마무리 이를 통하여 어느 서버에서든 도커 환경만 설치되어 있으면 git 등으로 이 프로젝트를 다운 받고 도커를 실행해서 이 컴퓨터와 똑같은 환경을 조성하고 문제없이 서비스를 돌릴 수 있을 것이다!!! 추가 라이브러리들을 일일히 하지 않아도 된다. 구름 IDE는 도커 기반의 서비스이다 -&gt; 도커 안의 도커 설치는 현재에서는 안된다 윈도우에서는 WSL로 실습할 수 있지만 오류가 많을 수도 있음 우분투에서는 ubuntu onstall docker를 검색한 후에 도커 설치할 수 있고 docker-compose도 따로 설치해야 함 docker-compose up","link":"/2021/04/04/docker-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/"},{"title":"Hello World!!!","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server -p 3000 More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2019/11/30/hello-world/"},{"title":"javascript 정규식","text":"정규 표현식은 대 소문자를 구분함 정규 표현식은 띄어쓰기 개수를 구분함 ^who -&gt; who가 시작 위치에 있을 때 ^를 사용 who$ -&gt; who가 끝에 위치할 때 $를 사용 $12$ -\\ $25$ ^$ -&gt; $로 시작하는 것을 의미했더라도 $가 문자 끝을 의미해서 안됨 $ -&gt; \\는 그 기호 뒤에 따라오는 문자를 정규 표현식의 의미가 있는 문자가 아니라 단순한 문자로 바꿔줌 ^ -&gt; 단순한 문자열 ^$ -&gt; $가 처음 들어가는 문장을 의미함 $$ -&gt; $가 뒤에 들어가는 문장을 의미함 \\ -&gt; \\ 문자를 의미함 \\는 escape 문자라고 함 . -&gt; 모든 캐릭터를 매칭, 어떠한 문자 모든 것을 뜻함 …… -&gt; 어떠한 문자건 상관없이 6개의 문자를 의미 (6 덩어리씩 쪼개고 뒤에 남은 문자는 포함 안됨) . -&gt; . any character를 의미하는 의미가 아니라 .을 의미 ... -&gt; 문자. any character 문자.을 의미 (.K.) [] [oyu] -&gt; o나 y나 u를 찾는다 (first, all matches)에 따라 몇개인지 달라짐 [] 안에는 문자 하나하를 의미함 [dH]. -&gt; Ho 와 같이 d나 H 후 아무 문자 선택됨 [oyu][yow] -&gt; ow, yo 등이 추출됨 [-] -&gt; range [c-k] -&gt; c부터 k까지 범위의 문자 ([cdefghijk]와 같음) [2-6] -&gt; [23456] [c-k1-8] [^CDgh45] -&gt; [] 안의 ^는 not을 의미함, ABEF 등등이 추출됨 [^W-Z] (on|ues|rida) -&gt; on, ues, rida 각각 1덩어리, 문자를 선택함 (Mon|Tues|Fri)day -&gt; (Monday|Tuesday|Friday) ..(id|esd|nd)ay -&gt; 앞의 아무 문자 2개까지 포함 Quantifiers -&gt; 수량자 *, +, ? a*b -&gt; a가 0 ~ 여러개, (ab, aab, b) a+b -&gt; a가 1 ~ 여러개, (aab, ab) a?b -&gt; a가 0 ~ 1개, (ab, b) .* -&gt; !@#$%^^&amp;&amp;등등 모든 텍스트 등등이 전부 선택 -A*- -&gt; - 앞에 A가 0 ~ 여러개, (–, -A-) [-@]* -&gt; (-@-, – 등등) *+ =&gt; (*, **), *가 1개 이상이여야 함 -@+- -&gt; (-@@@-) @가 1개 이상있어야 함 [^ ]+ -&gt; 공백에 대한 부분이 아닌것이 전부 선택됨 -X?XX?X -&gt; (-XX) 등 -@?@?@?- -&gt; (–, -@-, -@@-, -@@@-) 원하는 수량 정하기 -&gt; {} .{5} -&gt; 모든 문자건 5글자여야 함, 만약에 12글자라면 5글자씩 2번 묶이고 2글자가 선택되지 않음 [els]{1,3} -&gt; 3개 이하 [a-z]{3,} -&gt; 3이상이란 의미 AB*A -&gt; AB{0,}A AB+A -&gt; AB{1,}A AB?A -&gt; AB{0,1}A r.* -&gt; *은 any character, r부터 모든 문자가 선택이 되어버림 r.*? -&gt; 수량자 뒤에 ? 오면은 *?는 *는 최소인 0의 의미 (r) r.+? -&gt; +는 최소인 1의 의미가 됨, (ri, rk) r.?? -&gt; ?는 최소인 0을 의미 (r) .+ -> 비어있지 않은 div 태그 선택, 탐욕적인 수량자(Greedy) .+? -> lazy 선택자, 게으른 선택자 \\w -&gt; word = [A-z0-9_] \\w* [a-z]\\w* -&gt; (c3, d_4 등등) \\w{5} -&gt; 문자 5개 충족하면 추출 \\W -&gt; word가 아니다, 공백이랑 :, . @#$% 등이 선택됨 \\d -&gt; digit, (1, 123 등) \\D -&gt; 숫자가 아닌 것들 \\b. -&gt; 바운더리 \\B. \\A… -&gt; A는 시작점을 의미 시작에서 3문자 …\\Z -&gt; 맨끝에서 3문자 선택됨 ^과 \\A의 차이점 -&gt; multi line 시 \\A 하면 멅타라인이 있더라도 맨 앞 1개만 선택됨 \\w+(?=X) -&gt; ?=는 X를 문자를 검색하는 데에는 X를 쓰지만 선택은 하지 않음, (AAAX에서 AAA만 선택됨) \\w+(?=\\w) -&gt;","link":"/2021/02/11/javascript-%EC%A0%95%EA%B7%9C%EC%8B%9D/"}],"tags":[{"name":"API Gateway","slug":"API-Gateway","link":"/tags/API-Gateway/"},{"name":"DynamoDB","slug":"DynamoDB","link":"/tags/DynamoDB/"},{"name":"EC22","slug":"EC22","link":"/tags/EC22/"},{"name":"Git","slug":"Git","link":"/tags/Git/"},{"name":"gitBlog","slug":"gitBlog","link":"/tags/gitBlog/"},{"name":"S3","slug":"S3","link":"/tags/S3/"},{"name":"Lambda","slug":"Lambda","link":"/tags/Lambda/"},{"name":"lightsail","slug":"lightsail","link":"/tags/lightsail/"},{"name":"docker","slug":"docker","link":"/tags/docker/"},{"name":"javascript","slug":"javascript","link":"/tags/javascript/"}],"categories":[{"name":"AWS","slug":"AWS","link":"/categories/AWS/"},{"name":"AWS Guide","slug":"AWS/AWS-Guide","link":"/categories/AWS/AWS-Guide/"},{"name":"Git","slug":"Git","link":"/categories/Git/"},{"name":"Git Blog","slug":"Git-Blog","link":"/categories/Git-Blog/"},{"name":"docker","slug":"docker","link":"/categories/docker/"}]}