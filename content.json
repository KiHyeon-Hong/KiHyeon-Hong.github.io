{"pages":[{"title":"","text":"body { background-color: #95c2de; } .mainbox { background-color: #95c2de; margin: auto; height: 600px; width: 600px; position: relative; } .err { color: #ffffff; font-family: 'Nunito Sans', sans-serif; font-size: 11rem; position:absolute; left: 20%; top: 8%; } .far { position: absolute; font-size: 8.5rem; left: 42%; top: 15%; color: #ffffff; } .err2 { color: #ffffff; font-family: 'Nunito Sans', sans-serif; font-size: 11rem; position:absolute; left: 68%; top: 8%; } .msg { text-align: center; font-family: 'Nunito Sans', sans-serif; font-size: 1.6rem; position:absolute; left: 16%; top: 45%; width: 75%; } a { text-decoration: none; color: white; } a:hover { text-decoration: underline; } 4 4 블로그에 없는 URL입니다. 메인화면으로 갑니다.","link":"/404.html"},{"title":"about","text":"","link":"/about/index.html"}],"posts":[{"title":"API Gateway기반의 번역 웹 서비스","text":"실습 요약 번역 API 게이트웨이용 람다 함수 생성 A. 람다 함수 생성(람다 함수 이름 : lambda_for_translate_Service) B. 람다 함수 실행 역할 생성(람다 역할 이름 : role_for_translate_Service) 람다 함수 소스코드 작성 람다 함수 역할 수정 A. 정책 생성 및 검토(정책 이름 : role_for_translate_Service) B. 기존 관리형 정책 선택(TranslateFullAccess) 람다 API 게이트웨이 설정 index.html 파일 수정 및 S3버킷 생성 S3 버킷에 수정 파일 업로드 번역 서비스 정적 웹 사이트 설정 및 테스트 API 게이트웨이용 람다 함수를 생성한다 함수 이름에 lambda_for_translate_Service를 입력한다 AWS 정책 템플릿에서 새 역할 생성 선택 role_for_translate_Service 입력 정책 템플릿은 ‘기본 Lambda@Edge’ 입력 람다 함수 코드는 다음과 같이 작성 1234567891011121314151617181920212223242526272829303132333435363738394041/* AWS SDK 를 가져옵니다.*/var AWS = require('aws-sdk');AWS.config.update({region: 'us-east-1'});var translate = new AWS.Translate();exports.handler = function(event, context,callback){console.log(JSON.stringify(event.body));const response = JSON.parse(event.body) //event.body로 POST로 받은 데이터를 받습니다. try{ const translateParams = { SourceLanguageCode: 'ko', TargetLanguageCode: 'en', Text: response.text } //translate SDK를 불러옵니다. translate.translateText(translateParams, function (err, data) { if (err) callback(err) callback(null,{ statusCode:200, headers: { &quot;Access-Control-Allow-Origin&quot; : &quot;*&quot;, //S3에서 요청을 할 수 있도록 허용해줍니다. &quot;Access-Control-Allow-Credentials&quot; : true }, body:data.TranslatedText }) }) }catch(e){ callback(null,{ statusCode:200, body:JSON.stringify(e) }) }}; 람다 함수 역할을 수정 권한의 실행 역할에서 role_for_translate_Service 선택 기존에 있는 권한인 TranslateFullAccess를 선택 새롭게 translate로의 접근 권한이 생김 추가 트리거를 통하여 API 게이트웨이를 연간함 API 생성을 선택 보안은 열기로 설정 API 엔드포인트를 보면 주소가 생김 해당 주소가 홈페이지를 통해 서비스르 만들어 요청할 주소 웹 페이지를 다음과 같이 생성 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;번역웹사이트&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://stackpath.bootstrapcdn.com/bootstrap/4.2.1/css/bootstrap.min.css&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col align-self-center&quot;&gt; &lt;h5 id=&quot;resultText&quot;&gt;&lt;/h5&gt; &lt;form action=&quot;javascript:void(0)&quot;&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label&gt;텍스트를 입력해주세요.&lt;/label&gt; &lt;textarea class=&quot;form-control&quot; id=&quot;textInput&quot; rows=&quot;3&quot;&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;button onclick=&quot;sendReqeust()&quot; class=&quot;btn btn-primary&quot;&gt;Submit&lt;/button&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;script type=&quot;text/javascript&quot;&gt; var inputSelector = document.querySelector('#textInput'); var resultText = document.querySelector('#resultText'); function sendReqeust() { resultText.innerHTML = &quot;로딩중...&quot; fetch(&quot;https://0pmjclpe95.execute-api.ap-northeast-2.amazonaws.com/default/lambda_for_translate_service&quot;, { method: &quot;POST&quot;, body: JSON.stringify({ text:inputSelector.value }) }).then(function (response) { return response.text().then(function(text) { resultText.innerHTML = text; }); }) }&lt;/script&gt;&lt;/html&gt; 이때, fetch 안에 아까 람다 함수의 API 게이트웨이 엔드포인트를 복사한다. S3 버킷을 생성 버킷 이름은 전세계에서 유일한 이름으로 설정해야 함 이때, 퍼블릭 액세스 차단을 위한 버킷 설정에서 모든 퍼블릭 액세스 차단을 해제하고, 경고문을 체크 해당 버킷에 방금 생성한 index.html 파일을 업로드 한다. 이때 중요한점은 해당 index.html 파일을 퍼블릭으로 설정해야 함 정적 웹 사이트 호스팅 편집에서 활성화를 선택 인덱스 문서로 index.html, 파일은 없지만 오류 문서로 error.html을 입력 버킷 웹 사이트 엔드포인트가 뜨는데, 이것이 바로 번역 사이트의 엔드 포인트 사이트 접속 시 해당 화면이 나오는 것을 볼 수 있음 텍스트 입력 후 submit 선택 시 번역이 작동되는 것을 확인","link":"/2020/11/10/API-Gateway%EA%B8%B0%EB%B0%98%EC%9D%98-%EB%B2%88%EC%97%AD-%EC%9B%B9-%EC%84%9C%EB%B9%84%EC%8A%A4/"},{"title":"API 게이트웨이 시작하기","text":"API 게이트웨이는 HTTP 프로토콜을 이용하여 API를 개발자가 손수비게 구축할 수 있는 완전 관리형 서비스 실습 요약 API 게이트웨이용 람다 함수 생성 A. 람다 함수 생성(람다 함수 이름 : lambda_for_apigateway_get) B. 람다 함수 실행 역할 생성(람다 함수 역할 이름 : role_for_apigateway) API 게이트웨이용 람다 이벤트 구성 람다 함수 소스코드 작성 다이나모 DB 서비스 실행 권한을 위한 IAM 생성 A. 정책 생성 및 검토(정책 이름 : policy_dynamodb_crud) B. 역할 생성(역할 이름 : role_for_apigateway_get) 다이나모 DB 생성 람다 함수 수정 API Gateway 테스트 및 다이나모 DB GET 확인 AWS 콘솔에서 람다 함수를 선택하고, 함수 생성을 선택 함수 이름을 lambda_for_apigateway_get로 지정 권한은 AWS 정책 템플릿에서 새 역할 생성을 선택 역할 이름은 role_for_apigateway 정책 템플릿은 Lambda@Edge 선택 람다 함수 에디터 부분의 코드를 다음과 같이 입력 12345678exports.handler = async (event) =&gt; { const response = { statusCode:200, body:JSON.stringify(event.queryStringParameters) } return response}; 추가 트리거를 선택한 후 API 게이트웨이를 선택 API 생성을 선택한 후 보안을 열기로 선택 추기를 선택하면 다음과 같이 화면이 뜸 API 게이트웨이가 추가되면 기존에는 없던 리소스 경로가 뜸 API 엔드포인트라는 항목과 URL이 나타나는데 함수를 실행시키기 위해 접속해야 하는 주소 ?”key”=”value”&amp;”key”=”value” 형태로 URL 뒤에 붙혀서 URI를 만들어 준다 화면에 GET으로 보내준 파라매터가 뜨는 것을 확인할 수 있음 다이나모DB에 대한 권한을 주기 위해 권한에 들어감 role_for_apigateway_get을 선택하면 다음과 같은 화면이 뜸 정책 연결을 선택 정책 생성을 선택 서비스는 DynamoDB, 리소스는 모든 리소스, 작업은 수동작업으로 모든 DynamoDB 작업을 선택 정책 검토를 선택 정책 이름으로 policy_dynamodb_crud를 입력 정책 생성을 선택 검색에서 이전에 만들었던 role_for_apigateway_get을 입력한 후 표시되는 역할을 선택 요약정보가 뜨며, 정책 연결을 선택 이전에 만든 정책 이름을 입력하여 검색 체크 박스 선택 후 하단 정책 연결 버튼을 선택 policy_dynamodb_crud역할에 role_forapigateway 정책이 성공적으로 연결 이제 람다 함수가 다이나모 DB에 접근 가능함 다이나모DB에서 테이블 만들기를 선택하며, 테이블 이름은 dynamo_apigateway_query를 입력한 후, 기본 키는 id를 입력 테이블 생성 람다 함수로 돌아와서 함수 코드를 다음과 같이 입력 12345678910111213141516171819202122232425262728293031323334353637383940//aws-sdk를 불러옵니다.const AWS = require('aws-sdk')//다이나모디비 클라이언트를 초기화합니다.const dynamodb = new AWS.DynamoDB.DocumentClient()exports.handler = async (event) =&gt; { //리턴할 값을 선언합니다. let response //queryStringParameters즉 GET값들이 들어오는지 들어온다면 id가 있는지 체크합니다. if (!event.queryStringParameters || !event.queryStringParameters.id) { response = { statusCode: 400, body: JSON.stringify(&quot;id가 없습니다.&quot;), } return response } else { let params = { Item:{ id:event.queryStringParameters.id, data: event.queryStringParameters }, TableName: &quot;dynamo_apigateway_query&quot;, } await dynamodb.put(params).promise().catch(e =&gt; { response = { statusCode: 500, body: JSON.stringify(&quot;에러가 발생하였습니다:&quot; + e), } return response }) response = { statusCode: 200, body: JSON.stringify(&quot;데이터가 성공적으로 저장되었습니다..&quot;), } return response }} queryStringParameter를 인자로 받아 다이나모 DB에 저장하고 GET에이터나 id 값이 없다면 400, 저장하는데 문제가 발생한다면 500, 성공적으로 데이터를 넣었다면 200을 반환 파라매터가 없는경우 파라매터를 정상적을 넣는 경우 다이나오 DB에 들어가보면 데이터가 정상적으로 들어가 있음을 확인할 수 있음 1234{ &quot;text&quot;: &quot;hello world&quot;, &quot;number&quot;: &quot;+821012345678&quot;}","link":"/2020/11/03/API-%EA%B2%8C%EC%9D%B4%ED%8A%B8%EC%9B%A8%EC%9D%B4-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/"},{"title":"DynamoDB 시작하기","text":"관계형 DB vs NO SQL 비교 관계형 DB 정형 데이터 대용량 처리 시 성능 하향 미리 정해진 스키마 존재 트랜잭션을 통해 일관성 유지 보장 조인 등의 복잡한 검색 기능 클러스터 환경에 적합하지 않음 고가의 라이센스 비용 Oracle, MySql, MSSql 등 NO SQL 정형, 반정형, 비정형 데이터 대용량 데이터 처리 지원 스키마가 없거나 변경이 자유로움 트랜잭션 지원하지 않음, 일관성이 보장 어려움(사실, 보장 하지만 관계형 DB보다는 여유롭게 보장) 단순히 데이터 검색 기능 클러스터 환경에 적합 오픈 소스 카산드라, 몽고DB 등 DynamoDB는 크게 쿼리와 스캔이라는 데이터 탐색 방법을 제공 - 쿼리 : 삽입된 기본키를 기준으로 데이터를 찾는 방법 - 스캔 : 조건 값과 맞는 데이터를 찾을 때까지 모든 데이터를 검색 구축 과정 다이나모DB 테이블 만들기 A. 테이블 이름 : univStudent B. 기본키 : univ_name + univ_id 테이블 데이터 추가 데이터 수정 및 삭제 데이터 스캔과 쿼리 테이블 삭제 AWS console에서 DynamoDB를 선택 죄측 대시보드 밑의 테이블을 선택 테이블 만들기를 선택 테이블 이름은 univStudent, 기본키는 univ_name과 univ_id를 선택 후 생성 버튼을 클릭 항목 만들기 선택 내용을 입력 이 때, + 키를 누른 후 append를 클릭하여 데이터를 추가할 수 있음 저장을 클릭 데이터를 여러개 넣을 수 있으며, 형식이 전부 통일되지 않아도 됨 해당 데이터를 선택한 후 작업의 삭제를 통하여 데이터를 삭제할 수 있음 스캔은 조건값이 맞는 데이터를 찾을 때까지 모든 데이터를 탐색해서 어떤 조건 값에 맞는 데이터를 몇 개 찾아와라라는 명령어가 없다고, 모든 데이터를 찾음 필터를 통해서 조건을 줄 수 있음 쿼리는 아무런 값도 없이 검색을 누르면 에러가 발생 쿼리는 기본키를 입력하여 데이터를 검색하는 방법 글로벌 보조 인덱스는 동일한 데이터를 갖지만, 다른 키 값과 정렬키를 갖는 클론 테이블을 만들어서 테이블을 만들때와 같은 처리 용량이 필요함 인덱스를 만드는 시간은 오래 걸리지만 상태가 활성이 되면 완료된 것 스캔을 인덱스로 변경한 후 검색 시작을 선택하면 major가 포함된 데이터만 표시 됨 인덱스를 만든 테이블에서는 major을 기본키로 하기 때문에 원 테이블에서 major가 포함되지 않은 데이터는 가져올 수 가 없음 쿼리는 키 값을 찾아 데이터를 검색하는 방법 원 테이블에서 스캔으로 major을 찾는 것보다 인덱스에서 쿼리로 찾는 것이 처리용량이 더 작음 좌측 상단의 테이블 삭제를 클릭하여 안전하게 테이블을 삭제할 수 있음","link":"/2020/10/13/DynamoDB-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/"},{"title":"EC2를 활용한 Node.js 서버 구축!","text":"실습 요약 EC2, Ubuntu를 이용하여 인스턴스를 생성한다 Node.js를 설치하며, MariaDB를 설치한다. 간단한 예제를 통하여 환경을 테스트 한다. EC2의 새 인스턴스 생성을 통하여 다음과 같은 화면이 나온다. Ubuntu Server 20.04 LTS를 선택한다. 인스턴스 유형은 프리티어이므로 t2.micro를 선택한다. 인스턴스 세부 정보 구성은 건드리지 않는다. 스토리지 추가에서도 아무것도 선택하지 않는다. 태그 추가에서는 키에 Name을 입력하고 값에 TestServer를 입력한다. 이는 추후 인스턴스의 이름이 된다. 보안 그룹 구성에서는 기본으로 SSH가 있을 것이다. HTTP와 HTTPS를 추가하며 소스는 모두가 접근할 수 있도록 0.0.0.0/0을 선택한다. 인스턴스 시작 검토는 현재까지 설정한 정보를 볼 수 있다. 문제가 없다면 시작하기를 선택한다. 키를 발급 받는다. 기존에 가지고 있는 키를 선택해도 되며, 새로운 키를 발급 받아도 된다. 해당 키를 재발급이 불가능 하므로 반드시 저장을 해야한다. 인스턴스가 실행되면 연결 버튼을 통하여 다음의 정보를 얻을 수 있다. 이때 ec2-3-87-0-78.compute-1.amazonaws.com는 우리의 인스턴스의 퍼블릭 Ip의 역할을 한다. 인스턴스 요약을 통하여 5.87.0.78의 ip도 얻을 수 있는데, 이는 위의 ec2-3-87-0-78.compute-1.amazonaws.com와 같다. Putty를 통해 접속을 시도한다. 이때 Connection -&gt; SSH -&gt; Auth에 방금 발급 받은 키를 넣어줘야 한다. 주의할 점은 putty에서는 발급받은 pem이 아니라 ppk로 변환을 해줘야 하는데, 이 부분은 추후에 포스팅 한다. Putty의 Session에 Host Name에 방금 얻은 ec2-3-87-0-78.compute-1.amazonaws.com를 입력한다. 또한, ubuntu 계정으로 접근을 위해 앞에 ubuntu@를 붙인다. ubuntu@ec2-3-87-0-78.compute-1.amazonaws.com 연결을 누르게 되면 ubuntu 계정으로 로그인된 것을 볼 수 있다. Node.js 설치와 MariaDB는 ec2의 ubuntu에서 좀 다르게 설치된다. Node.js 설치법 https://docs.aws.amazon.com/ko_kr/sdk-for-javascript/v2/developer-guide/setting-up-node-on-ec2-instance.html 노드의 설치 방법은 위 사이트에 나와있다. 아래의 코드를 한줄씩 입력한다. curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.34.0/install.sh | bash . ~/.nvm/nvm.sh nvm install node node -e &quot;console.log('Running Node.js ' + process.version)&quot; 위의 명령어를 통해 Node.js가 설치되고, 버전을 확인할 수 있다. Node.js가 설치된 후 다음의 명령어를 통해 예제 코드 실행을 위한 모듈을 설치한다. npm install ejs npm install jade np install express npm install cookie-parser npm install body-parser npm install express-session npm install mysql npm install sync-mysql 한줄씩 입력하여 모듈을 설치한다. MariaDB 설치 https://downloads.mariadb.org/mariadb/repositories MariaDB를 설치하는 코드는 다음과 같다. sudo apt-get install software-properties-common sudo apt-key adv --fetch-keys 'https://mariadb.org/mariadb_release_signing_key.asc' sudo add-apt-repository 'deb [arch=amd64,arm64,ppc64el] https://ftp.harukasan.org/mariadb/repo/10.5/ubuntu focal main' sudo apt update sudo apt install mariadb-server mysql -V 위 코드를 통해 MariaDB가 설치되고 버전을 확인할 수 있다. 접속을 위해 MariaDB의 환경 설정을 해야한다. cd /etc/mysql/mariadb.conf.d sudo cp 50-server.cnf server.cnf.backup sudo vi 50-server.cnf bind-addess = 127.0.0.1을 주석 처리한다. bind-addess = 127.0.0.1 -&gt; #bind-addess = 127.0.0.1 mariaDB를 재시작 시키며, 접속을 위한 비밀번호를 설정 sudo systemctl restart mariadb.service sudo mysqladmin -u root password 'gachon654321' sudo mysql -u root -p Enter password: * set password for root@localhost = password('gachon654321'); use mysql; flush privileges; exit mysql -u root -p gachon654321 예제 페이지를 위해 테이블을 하나 만든다create database mydb; create table member ( name varchar(10), uid varchar(10), pass varchar(10)); Atom으로 접속을 한다. 이때 자세한 환경 세팅은 다음 포스팅에서 실시한다. ftp-remote을 통하여 .ftpconfig 파일을 다음과 같이 작성한다. { &quot;protocol&quot;: &quot;sftp&quot;, &quot;host&quot;: &quot;ec2-3-87-0-78.compute-1.amazonaws.com&quot;, &quot;port&quot;: 22, &quot;user&quot;: &quot;ubuntu&quot;, &quot;promptForPass&quot;: false, &quot;remote&quot;: &quot;/home/ubuntu&quot;, &quot;local&quot;: &quot;&quot;, &quot;agent&quot;: &quot;&quot;, &quot;privatekey&quot;: &quot;C:/users/ghdrl/Desktop/MyFiles/AwsKey/aws_password.pem&quot;, &quot;passphrase&quot;: &quot;&quot;, &quot;hosthash&quot;: &quot;&quot;, &quot;ignorehost&quot;: true, &quot;connTimeout&quot;: 10000, &quot;keepalive&quot;: 10000, &quot;keyboardInteractive&quot;: false, &quot;keyboardInteractiveForPass&quot;: false, &quot;remoteCommand&quot;: &quot;&quot;, &quot;remoteShell&quot;: &quot;&quot;, &quot;watch&quot;: [], &quot;watchTimeout&quot;: 500 } 소스 코드 작성 예제를 돌려보기 위해 소스 코드를 다음과 같이 작성한다. mydbsvr.js const fs = require('fs'); const ejs = require('ejs'); const mysql = require('mysql'); const express = require('express'); const bodyParser = require('body-parser'); // MySQL DB 연결 const client = mysql.createConnection({ host: 'localhost', // DB서버 IP주소 port: 3306, // DB서버 Port주소 user: 'root', // DB접속 아이디 password: 'gachon654321', // DB암호 database: 'mydb' //사용할 DB명 }); // 서버를 생성합니다. const app = express(); app.use(bodyParser.urlencoded({ extended: false })); // 서버를 실행합니다. app.listen(65001, function () { console.log('server running at http://127.0.0.1:65001'); }); app.get('/insert', (request, response) =&gt; { fs.readFile('9-insert.html', 'utf8', (error, data) =&gt; { //회원가입화면 response.send(data); // 회원가입 화면전송 }); }); app.get('/members', (request, response) =&gt; { fs.readFile('9-list.ejs', 'utf8', (error, data) =&gt; { // List화면 // 데이터베이스 쿼리를 실행합니다. client.query('SELECT * FROM member', (error, results) =&gt; { // 응답합니다. response.send(ejs.render(data, { data: results // 회원조회 결과화면 })); }); }); }); app.post('/insert', function (request, response) { // 변수를 선언합니다. var body = request.body; console.log(body.name); console.log(body.uid); console.log(body.pass); // 데이터베이스 쿼리를 실행합니다. client.query('INSERT INTO member (name, uid, pass) VALUES (?, ?, ?)', [body.name, body.uid, body.pass], () =&gt; { console.log(&quot;Insertion into DB was completed !&quot;); response.end(); }); }); 9-insert.html &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;회원가입&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;회원가입&lt;/h1&gt; &lt;hr /&gt; &lt;form method=&quot;post&quot;&gt; &lt;fieldset&gt; &lt;legend&gt;회원가입&lt;/legend&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;&lt;label&gt;이름&lt;/label&gt;&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;name&quot; /&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;label&gt;사용자id&lt;/label&gt;&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;uid&quot; /&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;label&gt;비밀번호&lt;/label&gt;&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;password&quot; name=&quot;pass&quot; /&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;input type=&quot;submit&quot; value = &quot;가입&quot; /&gt; &lt;/fieldset&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; 9-list.ejs &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;List Page&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;List Page&lt;/h1&gt; &lt;hr /&gt; &lt;table width=&quot;100%&quot; border=&quot;1&quot;&gt; &lt;tr&gt; &lt;th&gt;Name&lt;/th&gt; &lt;th&gt;Model Number&lt;/th&gt; &lt;th&gt;Series&lt;/th&gt; &lt;/tr&gt; &lt;% data.forEach(function (item, index) { %&gt; &lt;tr&gt; &lt;td&gt;&lt;%= item.name %&gt;&lt;/td&gt; &lt;td&gt;&lt;%= item.uid %&gt;&lt;/td&gt; &lt;td&gt;&lt;%= item.pass %&gt;&lt;/td&gt; &lt;/tr&gt; &lt;% }); %&gt; &lt;/table&gt; &lt;/body&gt; &lt;/html&gt; Node mydbsvr.js 명령을 통하여 예제 페이지를 실행한다. 3.87.0.78:65001/insert 그러나 접속을 하더라도 페이지가 제대로 뜨지 않는 것을 확인할 수 있다. 이는 Ec2의 보안 설정에서 포트 65001을 허용하지 않았기 때문이다. 해당 인스턴스의 보안그룹을 들어가면 인바운드 규칙을 볼 수 있다. 인바운드 규칙 편집을 선택한다. 유형을 사용자 지정 TCP로 하며 포트 범위를 65001로 한다. 그 후 0.0.0.0/0을 선택한 후 저장을 누른다. 같은 URL로 접속하면 정상적으로 뜨는 것을 확인할 수 있다. 입력 후 /members로 들어가게 되면 정상적으로 출력되는 것으 확인할 수 있다. DB에 접속해보면 입력한 데이터가 정상적으로 저장되어 있는 것을 확인할 수 있다.","link":"/2020/11/30/EC2%EB%A5%BC-%ED%99%9C%EC%9A%A9%ED%95%9C-Node-js-%EC%84%9C%EB%B2%84-%EA%B5%AC%EC%B6%95/"},{"title":"Git Blog 시작","text":"블로그 임시 로고 입니다.","link":"/2020/09/18/Git-Blog-%EC%8B%9C%EC%9E%91/"},{"title":"Lambda 시작하기","text":"AWS Lambda 함수 기반 문자 알림 서비스를 구축해본다. 구축 과정 SNS 서비스 실행 권한을 위한 IAM 정책 설정 A. 정책 생성 및 검토(정책 이름 policy_for_publising_SNS) B. 역할 생성(역할 이름 role_for_sns_sending) SNS 람다 함수 만들기 A. 람다 함수 생성(람다 함수 이름 : lambda_for_sns) B. 람다 함수 실행 역할 생성(람다 역할 이름 : role_for_sns_sending) SNS 람다 이벤트 구성 A. 람다 함수 이벤트 이름(eventForSendingsSNS) B. 람다 함수 소스코드 작성 SNS 람다 함수 테스트 AIM 대시 보드에서 죄측 정책 메뉴를 클릭한 후 정책 생성을 선탣한다. 서비스 선택에서 SNS 입력 후 필터링 된 SNS를 선택한다. 문자 보내기는 사용자에게 알림 서비스를 생성하는 것이므로 액세스 레벨 “쓰기”에 해당한다. 리소스는 모든 리소스를 선택한다. 요청 조건은 기본 설정으로 하고 정책 검토를 클릭한다. 정책 이름은 policy_for_publising_SNS로 한 후 정책 생성을 클릭한다. 정책과 연결해 줄 역할을 만든다. 역할 만들기를 선택한다. 신뢰할 수 있는 유형의 개체로 AWS 서비스를 선택한다. 사용 사례 선택은 Lambda를 선택한다. 권한 정책 연결에서 policy_for_publising_SNS를 선택한다. 태그는 없으므로 넘어간다. 역할 이름에 role_for_sns_sending를 입력하고 역할 만들기를 선택한다. AWS console에서 Lambda를 클릭한다. 람다 함수 대시보드에서 함수 생성을 선택한다. 함수 이름은 lambda_for_sns로 입력한다. 권한은 기존 역할 사용을 선택하며, role_for_sns_sending을 선택한다. 함수 행성을 선택한다. 성공적으로 함수가 만들어진 후 이벤트 선택에서 테스트 이벤트 구성을 선택한다. 이벤트 이름은 eventForSendingsSns로 입력한 후, 코드는 다음과 같이 입력한다. 1234{ &quot;text&quot;: &quot;hello world&quot;, &quot;number&quot;: &quot;+821012345678&quot;} 함수 코드에는 다음과 같이 입력한다. //AWS를 실행시키기위한 라이브러리를 가져옵니다. const AWS = require('aws-sdk'); //이전과 다른부분이 있다면 context와 callback을 파라미터로 받습니다. //context에서는 현재 실행중인 람다의 메타정보를 받고 //callback은 람다가 끝나는 시점 호출합니다. exports.handler = (event, context, callback) =&gt; { //위에 입력했던 json값이 event 즉 input으로 들어옵니다. //params에 Message와 PhonNumber 변수를 선언합니다. const params = { Message: event.text, PhoneNumber: event.number }; // SNS SDK를 가져옵니다. // SNS서비스에서 메세지를 보내는것은 한정된 리전에서만 사용할 수 있기때문에 // region을 도쿄리전으로 설정해주어야합니다. 이를 위해 인자값으로 // region에 도쿄리전의 식별자인 'ap-northeast-1'을 입력합니다. const publishTextPromise = new AWS.SNS({ apiVersion: '2010-03-31',region: 'ap-northeast-1'}).publish(params).promise(); // SDK를 실행합니다. publishTextPromise.then( function(data) { //메세지가 있다면 첫번째에 null, 두번째에 메세지를 리턴합니다. callback(null,&quot;MessageID is &quot; + data.MessageId); }).catch( function(err) { //에러가 있다면 err를 리턴합니다. callback(err); }); }; 오른쪽 상단의 테스트 버튼을 클릭하면 함수가 실행된다. 입력한 텍스트가 문자로 온 것을 확인할 수 있다","link":"/2020/10/27/Lambda-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/"},{"title":"Lightsail 시작하기","text":"lightsail은 플랫폼과 시작 이미지를 선택하는 것만으로 인스턴스를 바로 시작할 수 있다. 웹 사이트 블로그 단순 앱 개발 및 테스트 환경 소수의 서버로 구성된 비즈니스 소프트웨어 wordpress blig를 구축한다. 구축 과정 AWS Lightsail 접속 Lightsail 인스턴스 생성 Lightsail 인스턴스 확인 wordpress 사용자 설정 wordpress 관리자 설정 A. 사용자명, 패스워드 설정을 위한 원격 서버 접속 B. Bitnami(SSH) 접속을 통한 아이디 패스워드 생성/확인 C. wordpress 관리자 페이지 접속/확인 AWS console에서 lightsail 접속 인스턴스 생성을 누른다. 첫번째는 인스턴스 이미지를 선택하는 과정이다. 플랫폼과 블루푸린트 메뉴가 존재한다. 플랫폼은 Linux/Unix를 선택하며, 블루프린트는 Wordpress를 선택한다. 시작 스크립트는 맨 처음 서버가 구성될 때 실행되는 스크립트이며, 사용자에 따라 필수적으로 설치해야 하는 소프트웨어가 있을 경우 선택한다. SSH 키 페어는 원격 서버 접속을 위해 사용한다. 인스턴스 플랜은 프리티어 가입 후 첫 달 무료 서비스를 이용하기 위해 가장 저렴한 플랜을 선택한다. 인스턴스 확인에서 고유한 이름을 선택해야하며, 인스턴스 수를 늘릴경우 추가 요금이 발생할 수 있다. 처음 인스턴스를 생성하면 실행 중 메시지가 뜨며, IP 주소가 할당된다. 해당 IP 주소를 웹 브라우저에 입력하면 기본으로 생성되는 포스트와 블로그 레이아웃을 볼 수 있다. 관리자 페이지는 퍼블릭IP/wp-damin 이다. 관리자 대시보드를 이용하기 위해서는 유저명과 비밀번호를 입력해야 한다. lightsail 대시보드에 돌아가 이름 옆의 콘솔 창을 클릭한다. CLI console창이 뜬다. 1$ cat bitnami_credentials 명령어를 입력하면 default userName과 password를 출력한다. bitnami 관리자 정보는 잘 보관되어야 한다. 관리자 정보를 통하여 관리자 대시보드로 접속 가능하다. Setting의 General에서 Site Language를 한국어로 바꾸고 저장한다. wordpress와 polly wordpress 플러그인 설정 lightsail 기반 wordpress 사용을 위한 IAM 설정 A. 정책 설정 B. 정책 샐성 및 검토 C. 사용자 설정 D. 사용자 생성 E. 기존 정책과 사용자 연결 F. 사용자 키 보관 wordpress 플러그인 설정 및 사용 플러그인을 보면 AWS for WordPress가 보인다. 활성화를 클릭한다. 활성화를 하면 AWS라는 매뉴가 나타난다. 클릭하면 AWS access key와 AWS secret key를 입력하라는 메시지가 출력된다. 이를 이용하기 위해서는 IAM이 필요하다. IAM의 대시보드를 들어가면 액세스 관리에 사용자와 정책이 있다. 정책 생성을 클릭한 후 시각적 편집기가 아닌 JSON을 클릭한다. 123456789101112131415161718192021222324252627282930313233{ &quot;Version&quot;: &quot;2012-10-17&quot;, &quot;Statement&quot;: [ { &quot;Sid&quot;: &quot;Permissions1&quot;, &quot;Effect&quot;: &quot;Allow&quot;, &quot;Action&quot;: [ &quot;s3:HeadBucket&quot;, &quot;polly:SynthesizeSpeech&quot;, &quot;polly:DescribeVoices&quot;, &quot;translate:TranslateText&quot; ], &quot;Resource&quot;: &quot;*&quot; }, { &quot;Sid&quot;: &quot;Permissions2&quot;, &quot;Effect&quot;: &quot;Allow&quot;, &quot;Action&quot;: [ &quot;s3:ListBucket&quot;, &quot;s3:GetBucketAcl&quot;, &quot;s3:GetBucketPolicy&quot;, &quot;s3:PutObject&quot;, &quot;s3:DeleteObject&quot;, &quot;s3:CreateBucket&quot;, &quot;s3:PutObjectAcl&quot; ], &quot;Resource&quot;: [ &quot;arn:aws:s3:::audio_for_wordpress*&quot;, &quot;arn:aws:s3:::audio-for-wordpress*&quot; ] } ]} 해당 json 파일을 복사 &amp; 붙여넣기 한다. 정책 검토를 하면 다음과 같은 화면이 나온다. 정책 명을 policy_for_wordpress_polly으로 입력한 후 정책 생성을 클릭한다. 정책이 생성되었으면, 사용자에서 사용자 추가를 클릭한다. 사용자 이름은 userForWordpress로 하며, 액세스 유형은 일반 사용자가 아닌 워드프레스라는 애플리케이션을 통해 AWS에 서비스 접근하기 때문에 ‘프로그래밍 방식 액세스’를 선택한다. 기존 정책 직접 연결을 통하여 방금 생성한 정책을 선택한다. 태그 화면은 별도의 설정을 하지 않고 넘어간다. 이상이 없다면 사용자 만들기를 클릭한다. 프로그래밍 액세스 방식은 액세스 키와 비밀 액세스 키가 발급된다. 키는 .csv 파일로 보관할 수 있다. 앞서 생성한 키를 입력한다. 변경 사항 저장을 클릭한다. Text to Speech에서 source language를 한국어로 선택하며, Enable text-to-speech support를 체크한다. 글을 클릭한 후 새로 추가를 선택한다. 제목과 내용을 입력한 후 밑에 있는 enable Text-to-speech에 체크 박스를 선택한다. 우측 상단의 공개 버튼을 클릭한다. 다음과 같이 포스트된 글을 확인할 수 있으며, 재생 버튼을 통하여 polly 서비스를 확인할 수 있다. 다운로드도 가능하다. 첫 한달 간은 무료로 사용이 가능하지만, 그 이후로는 매달 $3.5의 금액이 나가므로, 실습 후 인스턴스를 삭제한다.","link":"/2020/09/29/Lightsail-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/"},{"title":"S3 시작하기","text":"S3은 어디서나 원하는 양의 데이터를 저장하고 검색할 수 있도록 구축된 객체 스토리지이다. S3은 스토리지 형식으로 객체 스토리지를 사용한다. 계층 구조가 없고, 고유식별 번호와 데이터 그리고 메타 데이터 등 최소한의 정보만을 가지고 있기 때문에 파일 개수가 많아져도 파일 스토리지에 비해 훨씬 많은 수의 파일들을 처리할 수 있다. 높은 내구성 손쉬운 혹장성 보안성과 편리성 관리 유연성 &lt;부트 스토립을 이용한 반응형 페이지 생성 실습&gt; 부트스트랩 홈페이지 접속 부트스트랩 템플릿 다운로드 S3버킷 생성 부트스트랩 템플릿 파일 업로드 정적 웹 사이트 설정 엔드포인트 URL을 통한 부트스트랩 index.html 확인 AWS 콘솔에서 스토리지 서비스인 S3을 검색한다. 다음과 같은 화면이 나오면 버킷 만들기를 클릭한다. 버킷 이름과 리전을 선택한다. 이 때, 버킷 이름은 저세계에서 유일해야 하며, 리전은 Educate 버전 사용 시 버지니아 북부로 해야 한다. 옵션은 기본으로 설정하고 넘어간다. 모든 퍼블릭 엑세스 차단을 해제한다. 차단을 해제 하여야 외부 사람이 접근 가능하다. 검토 후 문제가 없다면 버킷 만들기를 선택한다. 버킷이 새로 만들어 졌다. 새로 새성한 버킷을 선택하면 다음과 같은 화면이 출력된다. https://startbootstrap.com/ 부트스트랩을 이용한 반응형 웹 페이지를 만드려고 한다. 부트스트랩 사이트에서 마음에 드는 템플릿을 다운 받는다 다운받은 템플릿의 압축을 풀면 다음과 같은 파일들이 생겨난다. 해당 파일 전부를 업로드를 한다. 퍼블릭 권한 관리에서 “이 객체를 퍼블릭 읽기 엑세스 권한을 부여함”을 선택한다. 스토리지 클래스는 기본인 스탠다드를 선택한다. 완료 후 속성의 정적 웹 사이트 호스팅을 선택한다. 이 버킷을 사용하여 웹 사이트를 호스팅합니다를 선탣한다. 인덱스 문서는 엔드 포인트로 index.html을 입력한다. 엔드포인트는 다음과 같다. 해당 엔드 포인트를 웹 브라우저에 입력하면 해당하는 웹 페이지가 정상적으로 뜨는 것을 볼 수 있다.","link":"/2020/10/06/S3-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/"},{"title":"Hello World!!!","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server -p 3000 More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2019/11/30/hello-world/"},{"title":"javascript 정규식","text":"정규 표현식은 대 소문자를 구분함 정규 표현식은 띄어쓰기 개수를 구분함 ^who -&gt; who가 시작 위치에 있을 때 ^를 사용 who$ -&gt; who가 끝에 위치할 때 $를 사용 $12$ -\\ $25$ ^$ -&gt; $로 시작하는 것을 의미했더라도 $가 문자 끝을 의미해서 안됨 $ -&gt; \\는 그 기호 뒤에 따라오는 문자를 정규 표현식의 의미가 있는 문자가 아니라 단순한 문자로 바꿔줌 ^ -&gt; 단순한 문자열 ^$ -&gt; $가 처음 들어가는 문장을 의미함 $$ -&gt; $가 뒤에 들어가는 문장을 의미함 \\ -&gt; \\ 문자를 의미함 \\는 escape 문자라고 함 . -&gt; 모든 캐릭터를 매칭, 어떠한 문자 모든 것을 뜻함 …… -&gt; 어떠한 문자건 상관없이 6개의 문자를 의미 (6 덩어리씩 쪼개고 뒤에 남은 문자는 포함 안됨) . -&gt; . any character를 의미하는 의미가 아니라 .을 의미 ... -&gt; 문자. any character 문자.을 의미 (.K.) [] [oyu] -&gt; o나 y나 u를 찾는다 (first, all matches)에 따라 몇개인지 달라짐 [] 안에는 문자 하나하를 의미함 [dH]. -&gt; Ho 와 같이 d나 H 후 아무 문자 선택됨 [oyu][yow] -&gt; ow, yo 등이 추출됨 [-] -&gt; range [c-k] -&gt; c부터 k까지 범위의 문자 ([cdefghijk]와 같음) [2-6] -&gt; [23456] [c-k1-8] [^CDgh45] -&gt; [] 안의 ^는 not을 의미함, ABEF 등등이 추출됨 [^W-Z] (on|ues|rida) -&gt; on, ues, rida 각각 1덩어리, 문자를 선택함 (Mon|Tues|Fri)day -&gt; (Monday|Tuesday|Friday) ..(id|esd|nd)ay -&gt; 앞의 아무 문자 2개까지 포함 Quantifiers -&gt; 수량자 *, +, ? a*b -&gt; a가 0 ~ 여러개, (ab, aab, b) a+b -&gt; a가 1 ~ 여러개, (aab, ab) a?b -&gt; a가 0 ~ 1개, (ab, b) .* -&gt; !@#$%^^&amp;&amp;등등 모든 텍스트 등등이 전부 선택 -A*- -&gt; - 앞에 A가 0 ~ 여러개, (–, -A-) [-@]* -&gt; (-@-, – 등등) *+ =&gt; (*, **), *가 1개 이상이여야 함 -@+- -&gt; (-@@@-) @가 1개 이상있어야 함 [^ ]+ -&gt; 공백에 대한 부분이 아닌것이 전부 선택됨 -X?XX?X -&gt; (-XX) 등 -@?@?@?- -&gt; (–, -@-, -@@-, -@@@-) 원하는 수량 정하기 -&gt; {} .{5} -&gt; 모든 문자건 5글자여야 함, 만약에 12글자라면 5글자씩 2번 묶이고 2글자가 선택되지 않음 [els]{1,3} -&gt; 3개 이하 [a-z]{3,} -&gt; 3이상이란 의미 AB*A -&gt; AB{0,}A AB+A -&gt; AB{1,}A AB?A -&gt; AB{0,1}A r.* -&gt; *은 any character, r부터 모든 문자가 선택이 되어버림 r.*? -&gt; 수량자 뒤에 ? 오면은 *?는 *는 최소인 0의 의미 (r) r.+? -&gt; +는 최소인 1의 의미가 됨, (ri, rk) r.?? -&gt; ?는 최소인 0을 의미 (r) .+ -> 비어있지 않은 div 태그 선택, 탐욕적인 수량자(Greedy) .+? -> lazy 선택자, 게으른 선택자 \\w -&gt; word = [A-z0-9_] \\w* [a-z]\\w* -&gt; (c3, d_4 등등) \\w{5} -&gt; 문자 5개 충족하면 추출 \\W -&gt; word가 아니다, 공백이랑 :, . @#$% 등이 선택됨 \\d -&gt; digit, (1, 123 등) \\D -&gt; 숫자가 아닌 것들 \\b. -&gt; 바운더리 \\B. \\A… -&gt; A는 시작점을 의미 시작에서 3문자 …\\Z -&gt; 맨끝에서 3문자 선택됨 ^과 \\A의 차이점 -&gt; multi line 시 \\A 하면 멅타라인이 있더라도 맨 앞 1개만 선택됨 \\w+(?=X) -&gt; ?=는 X를 문자를 검색하는 데에는 X를 쓰지만 선택은 하지 않음, (AAAX에서 AAA만 선택됨) \\w+(?=\\w) -&gt;","link":"/2021/02/11/javascript-%EC%A0%95%EA%B7%9C%EC%8B%9D/"}],"tags":[{"name":"API Gateway","slug":"API-Gateway","link":"/tags/API-Gateway/"},{"name":"DynamoDB","slug":"DynamoDB","link":"/tags/DynamoDB/"},{"name":"EC22","slug":"EC22","link":"/tags/EC22/"},{"name":"gitBlog","slug":"gitBlog","link":"/tags/gitBlog/"},{"name":"Lambda","slug":"Lambda","link":"/tags/Lambda/"},{"name":"lightsail","slug":"lightsail","link":"/tags/lightsail/"},{"name":"S3","slug":"S3","link":"/tags/S3/"}],"categories":[{"name":"AWS","slug":"AWS","link":"/categories/AWS/"},{"name":"AWS Guide","slug":"AWS/AWS-Guide","link":"/categories/AWS/AWS-Guide/"},{"name":"Git Blog","slug":"Git-Blog","link":"/categories/Git-Blog/"}]}